<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-02-20T22:04:42+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Stack O Flow</title><subtitle>조금씩 알아가는 것을 적는 개발 노트입니다.</subtitle><author><name>Oh</name></author><entry><title type="html">🐳 Docker 기본 명령어</title><link href="http://localhost:4000/docker/docker-2/" rel="alternate" type="text/html" title="🐳 Docker 기본 명령어" /><published>2023-02-20T00:00:00+09:00</published><updated>2023-02-20T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker-2</id><content type="html" xml:base="http://localhost:4000/docker/docker-2/"><![CDATA[<p>💾 도커에서 자주 사용하는 명령어를 정리한 내용입니다.</p>

<p><br /></p>

<h1 id="-컨테이너-관련-명령어">🎯 컨테이너 관련 명령어</h1>
<p>Docker CLI 도구는 Docker 컨테이너(container)의 효과적인 관리를 위해서 다양한 커맨드(command)를 제공합니다.</p>

<h2 id="컨테이너-조회">컨테이너 조회</h2>
<p><code class="language-plaintext highlighter-rouge">docker ps</code> 커맨드는 Docker 컨테이너를 조회를 위해 사용되며 기본적으로 실행 중인 컨테이너 목록이 출력됩니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 조회</span>
<span class="nv">$ </span>docker ps

<span class="c"># -a 옵션</span>
<span class="c"># 현재 중지되어 있는 컨테이너까지 함께 출력됩니다.</span>
<span class="nv">$ </span>docker ps <span class="nt">-a</span>

<span class="c"># -s 옵션</span>
<span class="c"># 각 컨테이너의 디스크 사용량까지 볼 수 있습니다.</span>
<span class="nv">$ </span>docker ps <span class="nt">-s</span>

<span class="c"># -f 옵션</span>
<span class="c"># 조회 결과를 특정 조건에 따라 필터링해서 볼 수 있습니다.</span>
<span class="c"># 예를 들어, 특정 이미지로 부터 만들어진 컨테이어만 보고 싶다면 ancestor 필터를 사용하면 됩니다.</span>
<span class="nv">$ </span>docker ps <span class="nt">-af</span> <span class="s2">"ancestor=python:alpine"</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS               NAMES
b1bae952f7a6        python:alpine       <span class="s2">"python -m http.serv…"</span>   About an hour ago   Exited <span class="o">(</span>137<span class="o">)</span> 3 minutes ago                         amazing_chatelet
518d8bb6afaf        python:alpine       <span class="s2">"python3"</span>                About an hour ago   Exited <span class="o">(</span>0<span class="o">)</span> About an hour ago                       focused_gauss
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-실행">컨테이너 실행</h2>
<p><code class="language-plaintext highlighter-rouge">docker run</code> 커맨드는 상당히 여러가지 옵션을 통해 다양한 방식으로 컨테이너를 실행할 수 있도록 해줍니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 실행</span>
<span class="c"># $ docker run (&lt;옵션&gt;) &lt;이미지 식별자&gt; (&lt;명령어&gt;) (&lt;인자&gt;)</span>
<span class="nv">$ </span>docker run hello-world

<span class="c"># -d 옵션</span>
<span class="c"># 컨테이너를 백그라운드에서 실행</span>
<span class="c"># -d 옵션없이 실행했다면, 해당 터미널에서 Ctrl + C를 눌러서 빠져나오는 순간 해당 컨테이너는 종료될 것입니다.</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> python:3.8-alpine python <span class="nt">-m</span> http.server

<span class="c"># -it 옵션</span>
<span class="c"># -i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> python:3.8-alpine
<span class="nv">$ </span>docker run <span class="nt">-it</span> python:3.8-alpine /bin/sh

<span class="c"># -name 옵션</span>
<span class="c"># 컨테이너 이름 설정</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">--name</span> my-server python:3.8-alpine python <span class="nt">-m</span> http.server

<span class="c"># -e 옵션</span>
<span class="c"># 컨테이너 내에서 사용할 환경변수 설정</span>
<span class="c">## Docker 컨테이너의 환경변수를 설정하기 위해서는 -e 옵션을 사용합니다.</span>
<span class="c">## 또한, -e 옵션을 사용하면 Dockerfile의 ENV 설정도 덮어써지게 됩니다.</span>
<span class="nv">$ </span>docker run <span class="nt">-e</span> <span class="nv">FOO</span><span class="o">=</span>bar python:3.8-alpine <span class="nb">env</span>

<span class="c"># -p 옵션</span>
<span class="c"># 호스트와 컨테이너의 포트를 연결 (포워딩)</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 80:8000 python:3.8-alpine python <span class="nt">-m</span> http.server

<span class="c"># -v 옵션</span>
<span class="c"># 호스트와 컨테이너의 디렉토리를 연결 (마운트)</span>
<span class="nv">$ </span><span class="nb">echo </span>Hi <span class="o">&gt;</span> test.txt
<span class="nv">$ </span>docker run <span class="nt">-v</span> <span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>:/etc python:3.8-alpine <span class="nb">cat</span> /etc/test.txt
Hi

<span class="c"># -rm 옵션</span>
<span class="c"># 컨테이너가 종료될 때 컨테이너와 관련된 리소스(파일 시스템, 볼륨)까지 깨끗이 제거해줍니다.</span>
<span class="nv">$ </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> ubuntu:16.04 /bin/bash
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-중지">컨테이너 중지</h2>
<p>실행 중인 Docker 컨테이너를 중지하려면 <code class="language-plaintext highlighter-rouge">docker stop</code> 커맨드를 사용합니다. 중지하고 싶은 컨테이너의 아이디나 이름을 인자로 넘깁니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 아이디나 이름을 인자로 컨테이너 중지</span>
<span class="nv">$ </span>docker stop container_name
container_name

<span class="c"># 조회</span>
<span class="nv">$ </span>docker ps <span class="nt">-af</span> <span class="s2">"name=container_name"</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMES
b1bae952f7a6        python:alpine       <span class="s2">"python -m http.serv…"</span>   About an hour ago   Exited <span class="o">(</span>137<span class="o">)</span> 32 seconds ago                       container_name

<span class="c"># 컨테이너 전체 중지</span>
<span class="nv">$ </span>docker stop <span class="si">$(</span>docker ps <span class="nt">-a</span> <span class="nt">-q</span><span class="si">)</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-시작">컨테이너 시작</h2>
<p>중지된 Docker 컨테이너를 다시 시작하려면 <code class="language-plaintext highlighter-rouge">docker start</code> 커맨드를 사용합니다. 마찬가지로 재시작하고 싶은 컨테이너의 아이디나 이름을 인자로 넘기면 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 아이디나 이름을 인자로 컨테이너 시작</span>
<span class="nv">$ </span>docker start b1bae952f7m1
b1bae952f7m1

<span class="nv">$ </span>docker ps <span class="nt">-af</span> <span class="s2">"id=b1bae952f7m1"</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
b1bae952f7m1        python:alpine       <span class="s2">"python -m http.serv…"</span>   About an hour ago   Up About a minute                       amazing_chatelet
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-상대로-명령어-실행">컨테이너 상대로 명령어 실행</h2>
<p>실행 중인 컨테이너 상대로 명령어를 날리고 싶다면 <code class="language-plaintext highlighter-rouge">docker exec</code> 커맨드를 사용합니다. 예를 들어, 어떤 컨테이너를 상대로 <code class="language-plaintext highlighter-rouge">ls</code> 커맨드를 실행하고 싶다면 다음과 같이 하면 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">exec </span>b1bae952f7a6 <span class="nb">ls
</span>bin dev etc home lib media mnt ...생략...
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">-it</code> 옵션을 사용하면 해당 컨테이너의 쉘(shell)과 작접 상호작용하면서 연속으로 명령어를 실행할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> container_name /bin/sh

<span class="nv">$ </span><span class="nb">ls
</span>bin    etc    lib    mnt    proc   run    srv    tmp    var
dev    home   media  opt    root   sbin   sys    usr
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-로그-확인">컨테이너 로그 확인</h2>
<p>컨테이너의 로그를 확인하려면 <code class="language-plaintext highlighter-rouge">docker logs</code> 커맨드를 사용하면 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker logs b1bae952f7a6

<span class="c"># -f 옵션을 사용하면 실시간 로그를 확인할 수 있습니다.</span>
<span class="nv">$ </span>docker logs <span class="nt">-f</span> container_name

<span class="c"># 마지막 10줄만 출력</span>
<span class="nv">$ </span>docker logs <span class="nt">--tail</span> 10 container_name
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-상세-정보">컨테이너 상세 정보</h2>
<p>특정 컨테이너의 상세 정보를 확인하고 싶다면, <code class="language-plaintext highlighter-rouge">docker inspect</code> 커맨드를 사용합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker inspect 8c27a672e23c
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"Id"</span>: <span class="s2">"8c27a672e23c1c48aaaa0d2e65325aefb36db2934f724634dd4f5684397014ba"</span>,
        <span class="s2">"Created"</span>: <span class="s2">"2020-04-25T18:23:24.651490253Z"</span>,
        <span class="s2">"Path"</span>: <span class="s2">"/bin/sh"</span>,
        <span class="s2">"Args"</span>: <span class="o">[]</span>,
        <span class="s2">"State"</span>: <span class="o">{</span>
            <span class="s2">"Status"</span>: <span class="s2">"exited"</span>,
            <span class="s2">"Running"</span>: <span class="nb">false</span>,
            <span class="s2">"Paused"</span>: <span class="nb">false</span>,
            <span class="s2">"Restarting"</span>: <span class="nb">false</span>,
            <span class="s2">"OOMKilled"</span>: <span class="nb">false</span>,
            <span class="s2">"Dead"</span>: <span class="nb">false</span>,
            <span class="s2">"Pid"</span>: 0,
            <span class="s2">"ExitCode"</span>: 0,
            <span class="s2">"Error"</span>: <span class="s2">""</span>,
            <span class="s2">"StartedAt"</span>: <span class="s2">"2020-04-25T18:23:25.300618082Z"</span>,
            <span class="s2">"FinishedAt"</span>: <span class="s2">"2020-04-25T18:23:25.347690066Z"</span>
        <span class="o">}</span>,
        <span class="s2">"Image"</span>: <span class="s2">"sha256:f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a"</span>,
        ...생략...
    <span class="o">}</span>
<span class="o">]</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-제거">컨테이너 제거</h2>
<p>컨테이너를 제거하고 싶을 때는 <code class="language-plaintext highlighter-rouge">docker rm</code> 커맨드를 사용합니다. 중지되어 있는 컨테이너는 아무 옵션없이 제거할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 제거</span>
<span class="nv">$ </span>docker <span class="nb">rm </span>3722f14f4d2a
3722f14f4d2a

<span class="c"># 실행 중인 컨테이너는 다음과 같이 바로 제거가 허용되지 않습니다.</span>
<span class="c"># 이 때는, -f 옵션을 사용하면 해당 컨테이너를 먼저 정지시킨 다음에 제거해줍니다.</span>
<span class="nv">$ </span>docker <span class="nb">rm </span>d2f83048485e
Error response from daemon: You cannot remove a running container d2f83048485e4fe694dac374be152906e4e20da400305e5095bbb476bcaf718d. Stop the container before attempting removal or force remove
<span class="nv">$ </span>docker <span class="nb">rm</span> <span class="nt">-f</span> d2f83048485e

<span class="c"># 실행 중인 컨테이너는 건들지 않고 중지되어 있는 모든 컨테이너를 제거하고 싶다면 다음과 같이 하면 됩니다.</span>
<span class="nv">$ </span>docker <span class="nb">rm</span> <span class="si">$(</span>docker ps <span class="nt">-a</span> <span class="nt">-q</span><span class="si">)</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-레퍼런스-참고">컨테이너 레퍼런스 참고</h2>
<ul>
  <li><a href="https://docs.docker.com/engine/reference/run/" target="_blank">Docker run reference</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank">docker run</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/ps/" target="_blank">docker ps</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/stop/" target="_blank">docker stop</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/start/" target="_blank">docker start</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/exec/" target="_blank">docker exec</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/logs/" target="_blank">docker logs</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/attach/" target="_blank">docker attach</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/inspect/" target="_blank">docker inspect</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/rm/" target="_blank">docker rm</a>
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="-볼륨바인드-마운트-관련-명령어">🎯 볼륨/바인드 마운트 관련 명령어</h1>
<p>Docker 컨테이너(container)에 쓰여진 데이터는 기본적으로 컨테이너가 삭제될 때 함께 사라지게 됩니다. Docker에서 돌아가는 많은 애플리케이션이 컨테이너의 생명 주기와 관계없이 데이터를 영속적으로 저장을 해야하는 경우가 있습니다. 또한 여러 개의 Docker 컨테이너가 하나의 저장 공간을 공유해서 데이터를 읽거나 써야하는 경우도 있습니다.</p>

<p>이렇게 Docker 컨테이너의 생명 주기와 관계없이 데이터를 영속적으로 저장할 수 있도록 Docker는 두가지 옵션을 제공합니다. 첫번째는 Docker 볼륨(volume), 두번째는 바인드 마운트(bind mount)입니다.</p>

<p><img src="/assets/images/posts/docker/20230220/d1969bd2-2ec2-41d2-924e-38202359d740.png" alt="docker bind volume" />
<br /></p>

<h2 id="볼륨-생성">볼륨 생성</h2>
<p><code class="language-plaintext highlighter-rouge">docker volume create</code> 커맨드를 이용해서 볼륨을 생성할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume create our-vol
our-vol
</code></pre></div></div>
<p><br /></p>

<h2 id="볼륨-조회">볼륨 조회</h2>
<p><code class="language-plaintext highlighter-rouge">docker volume ls</code> 커맨드를 실행하면 볼륨을 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume <span class="nb">ls
</span>DRIVER              VOLUME NAME
<span class="nb">local               </span>our-vol
</code></pre></div></div>
<p><br /></p>

<h2 id="볼륨-상세-정보">볼륨 상세 정보</h2>
<p><code class="language-plaintext highlighter-rouge">docker volume inspect</code> 커맨드를 통해 해당 볼륨을 좀 더 상세한 정보를 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume inspect our-vol
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"CreatedAt"</span>: <span class="s2">"2020-05-09T17:03:46Z"</span>,
        <span class="s2">"Driver"</span>: <span class="s2">"local"</span>,
        <span class="s2">"Labels"</span>: <span class="o">{}</span>,
        <span class="s2">"Mountpoint"</span>: <span class="s2">"/var/lib/docker/volumes/our-vol/_data"</span>,
        <span class="s2">"Name"</span>: <span class="s2">"our-vol"</span>,
        <span class="s2">"Options"</span>: <span class="o">{}</span>,
        <span class="s2">"Scope"</span>: <span class="s2">"local"</span>
    <span class="o">}</span>
<span class="o">]</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Mountpoint</code> 항목을 보면 해당 볼륨이 컴퓨터의 어느 경로에 생성되었는지를 알 수 있습니다.
<br /></p>

<h2 id="컨테이너에-볼륨-마운트">컨테이너에 볼륨 마운트</h2>
<p>컨테이너가 볼륨을 사용하기 위해서는 볼륨을 컨테이너에 마운트(mount)해줘야 합니다. <code class="language-plaintext highlighter-rouge">docker run</code> 커맨드로 컨테이너를 실행할 때 <code class="language-plaintext highlighter-rouge">-v</code> 옵션을 사용하여 마운트합니다. 콜론(<code class="language-plaintext highlighter-rouge">:</code>)을 구분자로 해서 앞에는 마운트할 볼륨명 뒤에는 컨테이너 내의 경로를 명시해주면 됩니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># `our-vol` 볼륨을 `one` 컨테이너의 `/app` 경로에 마운트, touch 명령어로 파일 생성</span>
<span class="nv">$ </span>docker run <span class="nt">-v</span> our-vol:/app <span class="nt">--name</span> one busybox <span class="nb">touch</span> /app/test.txt
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">touch /app/test.txt</code> 커맨드를 실행하였기 때문에, test.txt 파일이 our-vol 볼륨의 경로에도 남아있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> /var/lib/docker/volumes/our-vol/_data
test.txt
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">docker inspect</code> 커맨드로 컨테이너의 상세 정보를 확인해보면 our-vol 볼륨이 volume 타입으로 마운트되어 있는 것을 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker inspect one
...생략...
    <span class="s2">"Mounts"</span>: <span class="o">[</span>
        <span class="o">{</span>
            <span class="s2">"Type"</span>: <span class="s2">"volume"</span>,
            <span class="s2">"Name"</span>: <span class="s2">"our-vol"</span>,
            <span class="s2">"Source"</span>: <span class="s2">"/var/lib/docker/volumes/our-vol/_data"</span>,
            <span class="s2">"Destination"</span>: <span class="s2">"/app"</span>,
            <span class="s2">"Driver"</span>: <span class="s2">"local"</span>,
            <span class="s2">"Mode"</span>: <span class="s2">"z"</span>,
            <span class="s2">"RW"</span>: <span class="nb">true</span>,
            <span class="s2">"Propagation"</span>: <span class="s2">""</span>
        <span class="o">}</span>
    <span class="o">]</span>,
...생략...
</code></pre></div></div>
<p><br /></p>

<h2 id="다른-컨테이너에도-볼륨-마운트">다른 컨테이너에도 볼륨 마운트</h2>
<p>같은 our-vol 볼륨을 two 컨테이너의 /app 경로에 마운트를 해보겠습니다. ls /app 커맨드를 실행해보니, one 컨테이너가 볼륨에 생성해놓은 파일이 그대로 보이는 것을 알 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-v</span> our-vol:/app <span class="nt">--name</span> two busybox <span class="nb">ls</span> /app
test.txt
</code></pre></div></div>
<p>이렇게 <strong>여러 개의 컨테이너가 하나의 볼륨에 접근할 수 있기 때문에 컨테이너 간 데이터 공유가 가능</strong>합니다.
<br /></p>

<h2 id="볼륨-삭제">볼륨 삭제</h2>
<p><code class="language-plaintext highlighter-rouge">docker volume rm</code> 커맨드를 사용해서 볼륨을 제거할 수 있습니다. 만약 제거하려는 볼륨이 마운트되어 있는 컨테이너가 있을 때는 해당 볼륨이 제거가 되지가 않습니다. 그럴 때는 해당 볼륨이 마운트되어 있는 모든 컨테이너를 먼저 삭제하고, 볼륨을 삭제해야 합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 삭제</span>
<span class="nv">$ </span>docker <span class="nb">rm</span> <span class="nt">-f</span> one two
one
two

<span class="c"># 볼륨 삭제</span>
<span class="nv">$ </span>docker volume <span class="nb">rm </span>our-vol
our-vol
</code></pre></div></div>
<p><br /></p>

<h2 id="볼륨-청소">볼륨 청소</h2>
<p><code class="language-plaintext highlighter-rouge">docker volume prune</code> 커맨드를 이용해서 마운트되어 있지 않은 모든 볼륨을 한번에 제거할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume prune
WARNING! This will remove all <span class="nb">local </span>volumes not used by at least one container.
Are you sure you want to <span class="k">continue</span>? <span class="o">[</span>y/N] y
</code></pre></div></div>
<p><br /></p>

<h2 id="바인드-마운트">바인드 마운트</h2>
<p>Docker 컨테이너에 데이터를 저장하기 위한 다른 방법으로 바인드 마운트(bind mount)라는 것도 있습니다. 바인드 마운트를 사용하면 호스트 파일 시스템의 특정 경로를 컨테이너로 바로 마운트할 수 있습니다.</p>

<p>바인드 마운트를 사용하는 방법은 <code class="language-plaintext highlighter-rouge">docker run</code> 커맨드를 실행할 때, <code class="language-plaintext highlighter-rouge">-v</code> 옵션의 콜론(<code class="language-plaintext highlighter-rouge">:</code>) 앞 부분에 마운트명 대신에 호스트의 경로를 지정해주는 것입니다.</p>

<p>예를 들어, 현재 경로에 <code class="language-plaintext highlighter-rouge">test.txt</code> 파일을 생성하고, 해당 호스트 경로를 컨테이너의 <code class="language-plaintext highlighter-rouge">/app</code> 경로에 마운트합니다. 컨테이너에 터미널에 접속하여 <code class="language-plaintext highlighter-rouge">ls /app</code> 커맨드를 실행해보면 <code class="language-plaintext highlighter-rouge">test.txt</code> 파일이 존재하는 것을 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 파일 생성</span>
<span class="nv">$ </span><span class="nb">touch </span>test.txt

<span class="c"># 바인드 마운트, 컨테이너 쉘 접속</span>
<span class="nv">$ </span>docker run <span class="nt">-v</span> <span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>:/app <span class="nt">-it</span> <span class="nt">--name</span> one busybox /bin/bash

<span class="c"># 조회</span>
<span class="nv">$ </span><span class="nb">ls</span> /app
test.txt
</code></pre></div></div>
<p>반대로 컨테이너의 /app 경로 상에서 test2.txt 파일을 실행해보면 호스트의 현재 경로에서도 해당 파일을 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 내에서 파일 생성</span>
<span class="nv">$ </span><span class="nb">touch</span> /app/test2.txt

<span class="c"># 컨테이너 쉘 종료</span>
<span class="nv">$ </span><span class="nb">exit</span>

<span class="c"># 호스트에서 조회</span>
<span class="nv">$ </span><span class="nb">ls
</span>test.txt   test2.txt
</code></pre></div></div>
<p><br /></p>

<h2 id="볼륨-vs-바인드-마운트">볼륨 VS 바인드 마운트</h2>
<p>볼륨(volume)과 바인드 마운트(bind mount)의 가장 큰 차이점은 Docker의 해당 마운트 포인트 관리 여부입니다.</p>

<p>볼륨을 사용할 때는 우리가 스스로 볼륨을 생성하거나 삭제해야하는 불편함이 있지만, 해당 볼륨은 Docker 상에서 이미지(image)나 컨테이너(container), 네트워크(network)와 비슷한 방식으로 관리가 되는 이점이 있습니다. 그래서 대부분의 상황에서는 볼륨을 사용하는 것이 권장되지만 컨테이너화된 로컬 개발 환경을 구성할 때는 바인드 마운트가 더 유리할 수 있습니다.</p>

<p>로컬에서 개발을 할 때는 일반적으로 현재 작업 디렉터리에 프로젝트 저장소를 <code class="language-plaintext highlighter-rouge">git clone</code> 받아놓고 코드를 변경합니다. 따라서 바인드 마운트를 이용해서 해당 디렉터리를 컨테이너의 특정 경로에 마운트해주면 코드를 변경할 때 마다 변경 사항을 실시간으로 컨테이너를 통해 확인할 수 있습니다. 또한 컨테이너를 통해 변경된 부분도 현재 작업 디렉터리에서 바로 확인할 수 있기 때문에 편리합니다.
<br /></p>

<h2 id="볼륨-레퍼런스-참고">볼륨 레퍼런스 참고</h2>
<ul>
  <li><a href="https://docs.docker.com/engine/reference/commandline/volume_create/" target="_blank">docker volume create</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/" target="_blank">docker volume ls</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/" target="_blank">docker volume inspect</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/volume_rm/" target="_blank">docker volume rm</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/" target="_blank">docker volume prune</a>
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="-네트워크-관련-명령어">🎯 네트워크 관련 명령어</h1>
<p>Docker 컨테이너(container)는 격리된 환경에서 돌아가기 때문에 기본적으로 다른 컨테이너와의 통신이 불가능합니다. 하지만 여러 개의 컨테이너를 하나의 Docker 네트워크(network)에 연결시키면 서로 통신이 가능해집니다.</p>

<h2 id="네트워크-종류">네트워크 종류</h2>
<p>Docker 네트워크는 <code class="language-plaintext highlighter-rouge">bridge</code>, <code class="language-plaintext highlighter-rouge">host</code>, <code class="language-plaintext highlighter-rouge">overlay</code> 등 목적에 따라 다양한 종류의 네트워크 드라이버(driver)를 지원합니다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">bridge</code> 네트워크는 하나의 호스트 컴퓨터 내에서 여러 컨테이너들이 서로 소통할 수 있도록 해줍니다.</li>
  <li><code class="language-plaintext highlighter-rouge">host</code> 네트워크는 컨테이너를 호스트 컴퓨터와 동일한 네트워크에서 컨테이너를 돌리기 위해서 사용됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">overlay</code> 네트워크는 여러 호스트에 분산되어 돌아가는 컨테이너들 간에 네트워킹을 위해서 사용됩니다.<br />
<br /></li>
</ul>

<h2 id="네트워크-생성">네트워크 생성</h2>
<p><code class="language-plaintext highlighter-rouge">docker network create</code> 커맨드를 사용해서 Docker 네트워크를 생성할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network create our-net
e6dfe4a9a5ec85abcb484662c30a3a0fc76df217dde76d52fac39fae8412ca68
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크-조회">네트워크 조회</h2>
<p><code class="language-plaintext highlighter-rouge">docker network ls</code> 커맨드를 사용하면 현재 생성되어 있는 Docker 네트워크 목록을 조회할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network <span class="nb">ls
</span>NETWORK ID          NAME                DRIVER              SCOPE
143496b94e57        bridge              bridge              <span class="nb">local
</span>311d6534f79f        host                host                <span class="nb">local
</span>aa89f58200a6        none                null                <span class="nb">local</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크-상세-정보">네트워크 상세 정보</h2>
<p><code class="language-plaintext highlighter-rouge">docker network inspect</code> 커맨드로 네트워크의 상세 정보를 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network inspect our-net
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크에-컨테이너-연결">네트워크에 컨테이너 연결</h2>
<p>먼저 컨테이너 하나를 <code class="language-plaintext highlighter-rouge">one</code> 라는 이름으로 실행해보도록 하겠습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-itd</span> <span class="nt">--name</span> one busybox
660bafdce2996378cde070dfd894731bb90745e46d2ab10d6504c0cc9f4bdea9
</code></pre></div></div>
<p>컨테이너를 실행할 때 <code class="language-plaintext highlighter-rouge">--network</code> 옵션을 명시해주지 않으면, 기본적으로 <code class="language-plaintext highlighter-rouge">bride</code> 라는 이름의 디폴트 네트워크에 붙게 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network inspect bridge
... 생략 ...
        <span class="s2">"Containers"</span>: <span class="o">{</span>
            <span class="s2">"660bafdce2996378cde070dfd894731bb90745e46d2ab10d6504c0cc9f4bdea9"</span>: <span class="o">{</span>
                <span class="s2">"Name"</span>: <span class="s2">"one"</span>,
                <span class="s2">"EndpointID"</span>: <span class="s2">"40b4bbd8385debf86eef2fc2136315e1a82fa1ef72877bfae25477d6e8e46726"</span>,
                <span class="s2">"MacAddress"</span>: <span class="s2">"02:42:ac:11:00:04"</span>,
                <span class="s2">"IPv4Address"</span>: <span class="s2">"172.17.0.4/16"</span>,
                <span class="s2">"IPv6Address"</span>: <span class="s2">""</span>
            <span class="o">}</span>,
        <span class="o">}</span>,
... 생략 ...
</code></pre></div></div>
<p><br /></p>

<p>이제 <code class="language-plaintext highlighter-rouge">one</code> 컨테이너와 <code class="language-plaintext highlighter-rouge">our-net</code> 네트워크를 연결해보도록 하겠습니다.<br />
Docker 네트워크에 컨테이너를 연결할 때는 <code class="language-plaintext highlighter-rouge">docker network connect</code> 커맨드를 사용합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network connect our-net one
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">our-net</code> 네트워크의 상세 정보를 다시 확인해보면 <code class="language-plaintext highlighter-rouge">Containers</code> 항목에 <code class="language-plaintext highlighter-rouge">one</code> 컨테이너가 추가된 것을 볼 수 있습니다. <code class="language-plaintext highlighter-rouge">one</code> 컨테이너에 IP <code class="language-plaintext highlighter-rouge">172.19.0.2</code>가 할당된 것도 확인할 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network inspect our-net
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"Name"</span>: <span class="s2">"our-net"</span>,
        <span class="s2">"Id"</span>: <span class="s2">"e6dfe4a9a5ec85abcb484662c30a3a0fc76df217dde76d52fac39fae8412ca68"</span>,
        <span class="s2">"Created"</span>: <span class="s2">"2020-04-26T19:23:04.563643516Z"</span>,
        <span class="s2">"Scope"</span>: <span class="s2">"local"</span>,
        <span class="s2">"Driver"</span>: <span class="s2">"bridge"</span>,
        <span class="s2">"EnableIPv6"</span>: <span class="nb">false</span>,
        <span class="s2">"IPAM"</span>: <span class="o">{</span>
            <span class="s2">"Driver"</span>: <span class="s2">"default"</span>,
            <span class="s2">"Options"</span>: <span class="o">{}</span>,
            <span class="s2">"Config"</span>: <span class="o">[</span>
                <span class="o">{</span>
                    <span class="s2">"Subnet"</span>: <span class="s2">"172.19.0.0/16"</span>,
                    <span class="s2">"Gateway"</span>: <span class="s2">"172.19.0.1"</span>
                <span class="o">}</span>
            <span class="o">]</span>
        <span class="o">}</span>,
        <span class="s2">"Internal"</span>: <span class="nb">false</span>,
        <span class="s2">"Attachable"</span>: <span class="nb">false</span>,
        <span class="s2">"Ingress"</span>: <span class="nb">false</span>,
        <span class="s2">"ConfigFrom"</span>: <span class="o">{</span>
            <span class="s2">"Network"</span>: <span class="s2">""</span>
        <span class="o">}</span>,
        <span class="s2">"ConfigOnly"</span>: <span class="nb">false</span>,
        <span class="s2">"Containers"</span>: <span class="o">{</span>
            <span class="s2">"660bafdce2996378cde070dfd894731bb90745e46d2ab10d6504c0cc9f4bdea9"</span>: <span class="o">{</span>
                <span class="s2">"Name"</span>: <span class="s2">"one"</span>,
                <span class="s2">"EndpointID"</span>: <span class="s2">"cc490148a533d40b3aff33a421cc9a01c731c75a8deb70ab729a5358f2fd381c"</span>,
                <span class="s2">"MacAddress"</span>: <span class="s2">"02:42:ac:13:00:02"</span>,
                <span class="s2">"IPv4Address"</span>: <span class="s2">"172.19.0.2/16"</span>,
                <span class="s2">"IPv6Address"</span>: <span class="s2">""</span>
            <span class="o">}</span>
        <span class="o">}</span>,
        <span class="s2">"Options"</span>: <span class="o">{}</span>,
        <span class="s2">"Labels"</span>: <span class="o">{}</span>
    <span class="o">}</span>
<span class="o">]</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크로부터-컨테이너-연결-해제">네트워크로부터 컨테이너 연결 해제</h2>
<p>하나의 컨테이너는 여러 개의 네트워크에 동시에 연결할 수 있습니다. 최초에 <code class="language-plaintext highlighter-rouge">one</code> 컨테이너를 생성할 때 <code class="language-plaintext highlighter-rouge">bridge</code> 네트워크 붙었기 때문에, 현재 <code class="language-plaintext highlighter-rouge">one</code> 컨테이너는 <code class="language-plaintext highlighter-rouge">our-net</code> 네트워크와 <code class="language-plaintext highlighter-rouge">bridge</code> 네트워크에 동시에 붙어있게 됩니다.</p>

<p><code class="language-plaintext highlighter-rouge">one</code> 컨테이너를 <code class="language-plaintext highlighter-rouge">bridge</code> 네트워크로부터 해제 하겠습니다. Docker 네트워크로부터 컨테이너의 연결을 끊을 때는 <code class="language-plaintext highlighter-rouge">docker network disconnect</code> 커맨드를 사용합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network disconnect bridge one
</code></pre></div></div>
<p><br /></p>

<h2 id="두번째-컨테이너-연결">두번째 컨테이너 연결</h2>
<p>하나의 컨테이너를 더 <code class="language-plaintext highlighter-rouge">our-net</code> 네트워크에 연결합니다. 이번에는 <code class="language-plaintext highlighter-rouge">--network</code> 옵션을 사용해서 컨테이너를 실행하면서 바로 연결할 네트워크를 지정해주도록 하겠습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-itd</span> <span class="nt">--name</span> two <span class="nt">--network</span> our-net busybox
0e7fe8a59f9d3f8bd545d3e557ffd34100a09b8ebe92ae5a375f37a5d072873d
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-간-네트워킹">컨테이너 간 네트워킹</h2>
<p>컨테이너 이름을 호스트네임(hostname)처럼 사용할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">exec </span>one ping two
PING two <span class="o">(</span>172.19.0.3<span class="o">)</span>: 56 data bytes
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>0 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.119 ms
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>1 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.105 ms
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>2 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.116 ms
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>3 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.883 ms
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>4 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.127 ms
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크-제거">네트워크 제거</h2>
<p><code class="language-plaintext highlighter-rouge">docker network rm</code> 커맨드를 사용해서 our-net 네트워크를 제거할 수 있습니다.</p>

<p>네트워크 상에서 실행중인 컨테이너가 있을 때는 제거가 되지 않습니다. 먼저 해당 네트워크에 연결되어 실행 중인 모든 컨테이너를 중지시키고, 네트워크를 삭제해야 합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 중지</span>
<span class="nv">$ </span>docker stop one two
one
two

<span class="c"># 네트워크 삭제</span>
<span class="nv">$ </span>docker network <span class="nb">rm </span>our-net
our-net
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크-청소">네트워크 청소</h2>
<p><code class="language-plaintext highlighter-rouge">docker network prune</code> 커맨드를 이용해서 불필요한 네트워크를 한번에 모두 제거할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network prune
WARNING! This will remove all networks not used by at least one container.
Are you sure you want to <span class="k">continue</span>? <span class="o">[</span>y/N] y
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크-레퍼런스-참고">네트워크 레퍼런스 참고</h2>
<ul>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_ls/" target="_blank">docker network ls</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_create/" target="_blank">docker network create</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/" target="_blank">docker network inspect</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_connect/" target="_blank">docker network connect</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/" target="_blank">docker network disconnect</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_rm/" target="_blank">docker network rm</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_prune/" target="_blank">docker network prune</a>
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="-이미지-관련-명령어">🎯 이미지 관련 명령어</h1>
<p>Docker CLI 도구는 Docker 이미지(image)의 효과적인 관리를 위해서 다양한 커맨드(command)를 제공합니다.
<br /></p>

<h2 id="이미지-조회">이미지 조회</h2>
<p><code class="language-plaintext highlighter-rouge">docker images</code> 커맨드로 이미지를 조회할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 이미지 조회</span>
<span class="nv">$ </span>docker images

<span class="c">## 특정 리파지토리(repository)에 해당하는 이미지만 필터링해서 보고 싶을 때는</span>
<span class="c">## 리파지토리를 인자로 넘겨주면 됩니다.</span>
<span class="nv">$ </span>docker images node
node                10-alpine           34a10d47f150        2 weeks ago         83.5MB
node                12-alpine           f77abbe89ac1        2 weeks ago         88.1MB

<span class="c"># 태그까지 인자로 넘기면 특정 이미지가 조회됩니다.</span>
<span class="nv">$ </span>docker images node:12-alpine
node                12-alpine           f77abbe89ac1        2 weeks ago         88.1MB
</code></pre></div></div>
<p><br /></p>

<h2 id="이미지-다운로드">이미지 다운로드</h2>
<p><code class="language-plaintext highlighter-rouge">docker pull</code> 커맨드를 이용하여 이미지를 다운로드 할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">run</code> 명령어를 입력하면 이미지가 없을 때 자동으로 다운받으니 <code class="language-plaintext highlighter-rouge">pull</code> 명령어를 언제 쓰는지 궁금할 수 있는데 <code class="language-plaintext highlighter-rouge">pull</code>은 이미지를 최신버전으로 다시 다운 받습니다. 같은 태그지만 이미지가 업데이트 된 경우는 <code class="language-plaintext highlighter-rouge">pull</code> 명령어를 통해 이미지를 새로 다운받을 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 이미지 다운</span>
<span class="nv">$ </span>docker pull ubuntu:14.04
</code></pre></div></div>
<p><br /></p>

<h2 id="이미지-빌드">이미지 빌드</h2>
<p><code class="language-plaintext highlighter-rouge">docker build</code> 커맨드는 Docker 이미지를 빌드(build)할 때 사용됩니다.</p>

<p>Docker 데몬이 이미지를 빌드하려면 소위 컨텍스트(context)라고도 불리는 Dockerfile을 담고 있는 디렉터리가 필요합니다. Dockerfile은 보통 같은 디렉터리 안에 있는 설정 파일이나 소스 코드를 이용해서 이미지의 빌드 절차를 정의합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 현재 작업 디렉터리 기준 이미지 빌드</span>
<span class="nv">$ </span>docker build <span class="nb">.</span>

<span class="c"># 네트워크 상의 Git repository 주소나 압축 파일 빌드</span>
<span class="nv">$ </span>docker build github.com/creack/docker-firefox

<span class="c"># -t 옵션을 사용하여 Docker 이미지에 태그(tag)를 설정</span>
<span class="c">## 태그는 리파지토리(repository):태그(tag) 형태로 지정이 가능하며</span>
<span class="c">## 태그 부분을 생략하면 latest가 태그가 됩니다.</span>
<span class="nv">$ </span>docker build <span class="nt">-t</span> <span class="nb">test</span>:1.0 <span class="nb">.</span>

<span class="c"># -f 옵션을 사용하면 디폴트인 Dockerfile 대신에 다른 파일로 부터 Docker 이미지를 빌드</span>
<span class="nv">$ </span>docker build <span class="nt">-f</span> Dockerfile.dev <span class="nb">.</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="이미지-태깅">이미지 태깅</h2>
<p>이미지 태깅은 이미지를 빌드 한 후에 별도로 해줄 수도 있는데, 이 때 <code class="language-plaintext highlighter-rouge">docker tag</code> 커맨드를 사용합니다. 첫번째 인자로 이미지ID, 두번째 인자로 리파지토리 또는 태그까지 넘겨주면 됩니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker tag 8bae72379b48 <span class="nb">test</span>:2.0
</code></pre></div></div>
<p><br /></p>

<h2 id="이미지-삭제">이미지 삭제</h2>
<p><code class="language-plaintext highlighter-rouge">docker rmi</code> 커맨드로 Docker 이미지를 삭제할 수 있습니다. 삭제하려는 이미지의 ID나 태그를 인자로 넘겨주면 해당 이미지가 삭제가 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 이미지 삭제</span>
<span class="nv">$ </span>docker rmi f77abbe89ac1
<span class="nv">$ </span>docker rmi node:12-alpine

<span class="c"># 이미지 조회</span>
<span class="nv">$ </span>docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
test2               latest              8bae72379b48        56 minutes ago      5.6MB
<span class="nb">test                </span>latest              8bae72379b48        56 minutes ago      5.6MB

<span class="c"># -f 옵션을 주고 이미지 ID를 인자로 넘기면 이미지 삭제</span>
<span class="nv">$ </span>docker rmi <span class="nt">-f</span> 8bae72379b48
Untagged: test2:latest
Untagged: <span class="nb">test</span>:latest
Deleted: sha256:8bae72379b4

<span class="c"># 사용하지 않는 이미지 전체 삭제</span>
<span class="nv">$ </span>docker rmi <span class="si">$(</span>docker images <span class="nt">-q</span><span class="si">)</span> <span class="nt">-f</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="이미지-레퍼런스-참고">이미지 레퍼런스 참고</h2>
<ul>
  <li><a href="https://docs.docker.com/engine/reference/commandline/images/" target="_blank">docker images</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank">docker build</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/rmi/" target="_blank">docker rmi</a>
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h1>
<ul>
  <li><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank">https://subicura.com</a></li>
  <li><a href="https://www.daleseo.com/?tag=Docker" target="_blank">https://www.daleseo.com</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Docker" /><category term="Docker" /><category term="Container" /><summary type="html"><![CDATA[💾 도커에서 자주 사용하는 명령어를 정리한 내용입니다.]]></summary></entry><entry><title type="html">🐳 Docker 살펴보기</title><link href="http://localhost:4000/docker/docker-1/" rel="alternate" type="text/html" title="🐳 Docker 살펴보기" /><published>2023-02-16T00:00:00+09:00</published><updated>2023-02-16T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker-1</id><content type="html" xml:base="http://localhost:4000/docker/docker-1/"><![CDATA[<p>💾 도커 기본 개념을 정리한 내용입니다.</p>

<p><br /></p>

<h1 id="-도커란">🤔 도커란?</h1>
<p>도커는 <span class="danger-color">컨테이너 기반의 오픈소스 가상화 플랫폼</span>입니다.</p>

<h2 id="컨테이너container">컨테이너(Container)</h2>
<p>컨테이너는 격리된 공간에서 프로세스가 동작하는 기술입니다. 가상화 기술의 하나지만 기존방식과는 차이가 있습니다.</p>

<p>기존의 가상화 방식은 주로 <strong>OS를 가상화</strong> 하였습니다. <strong>VMware나 VirtualBox같은 가상머신은 호스트 OS위에 게스트 OS 전체를 가상화하여 사용하는 방식</strong>입니다. 이 방식은 여러가지 OS를 가상화(리눅스에서 윈도우를 돌린다던가) 할 수 있고 비교적 사용법이 간단하지만 <strong>무겁고 느려서</strong> 운영환경에선 사용할 수 없었습니다.</p>

<p><img src="/assets/images/posts/docker/20230216/d1969bd2-2ec2-41d2-924e-38202359d727.png" alt="vm_docker" /></p>

<p>OS 가상화는 성능문제가 있었고 이를 개선하기 위해 <strong>프로세스를 격리</strong> 하는 방식이 등장합니다.</p>

<p><strong>리눅스에서는 이 방식을 리눅스 컨테이너라고 하고 단순히 프로세스를 격리시키기 때문에 가볍고 빠르게 동작합니다. CPU나 메모리는 딱 프로세스가 필요한 만큼만 추가로 사용하고 성능적으로도 거의 손실이 없습니다.</strong></p>

<p>하나의 서버에 여러개의 컨테이너를 실행하면 서로 영향을 미치지 않고 독립적으로 실행되어 마치 가벼운 Virtual Machine을 사용하는 느낌을 줍니다.
<br />
<br />
<br /></p>

<h2 id="이미지image">이미지(Image)</h2>
<p>도커에서 가장 중요한 개념은 컨테이너와 함께 이미지라는 개념입니다.</p>

<p><img src="/assets/images/posts/docker/20230216/d1969bd2-2ec2-41d2-924e-38202359d722.png" alt="docker image" /></p>

<p><strong>이미지는 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것</strong>으로 상태값을 가지지 않고 변하지 않습니다.(Immutable)</p>

<p>컨테이너는 이미지를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장됩니다. 같은 이미지에서 여러개의 컨테이너를 생성할 수 있고 컨테이너의 상태가 바뀌거나 컨테이너가 삭제되더라도 이미지는 변하지 않고 그대로 남아있습니다.</p>

<p>ubuntu 이미지는 ubuntu를 실행하기 위한 모든 파일을 가지고 있고 MySQL 이미지는 debian을 기반으로 MySQL을 실행하는데 필요한 파일과 실행 명령어, 포트 정보등을 가지고 있습니다.</p>

<p>말그대로 <strong>이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 더 이상 의존성 파일을 컴파일하고 이것저것 설치할 필요가 없습니다.</strong> 이제 새로운 서버가 추가되면 미리 만들어 놓은 이미지를 다운받고 컨테이너를 생성만 하면 됩니다.</p>

<p><strong>도커 이미지는 <a href="https://hub.docker.com/search?q=" target="_blank">Docker hub</a>에 등록하거나 Docker Registry 저장소를 직접 만들어 관리할 수 있습니다.</strong>
<br />
<br />
<br />
<br />
<br /></p>

<h1 id="-특징">🎯 특징</h1>
<h2 id="레이어layer-저장방식">레이어(Layer) 저장방식</h2>
<p>도커 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 보통 용량이 수백MB에 이릅니다. 처음 이미지를 다운받을 땐 크게 부담이 안되지만 기존 이미지에 파일 하나 추가했다고 수백MB를 다시 다운받는다면 매우 비효율적일 수 밖에 없습니다.</p>

<p><img src="/assets/images/posts/docker/20230216/d1969bd2-2ec2-41d2-924e-38202359d728.png" alt="docker layer" /></p>

<p>도커는 이런 문제를 해결하기 위해 레이어라는 개념을 사용하고 유니온 파일 시스템을 이용하여 여러개의 레이어를 하나의 파일시스템으로 사용할 수 있게 해줍니다. 이미지는 여러개의 읽기 전용 레이어로 구성되고 파일이 추가되거나 수정되면 새로운 레이어가 생성됩니다.</p>

<p>ubuntu 이미지가 A + B + C의 집합이라면, ubuntu 이미지를 베이스로 만든 nginx 이미지는 A + B + C + nginx가 됩니다.</p>

<p>webapp 이미지를 nginx 이미지 기반으로 만들었다면 A + B + C + nginx + source 레이어로 구성됩니다.</p>

<p>webapp 소스를 수정하면 A, B, C, nginx 레이어를 제외한 새로운 source(v2) 레이어만 다운받으면 되기 때문에 굉장히 효율적으로 이미지를 관리할 수 있습니다.
<br />
<br />
<br /></p>

<h2 id="이미지-경로">이미지 경로</h2>
<p><img src="/assets/images/posts/docker/20230216/d1969bd2-2ec2-41d2-924e-38202359d729.png" alt="docker layer" /></p>

<p>이미지는 url 방식으로 관리하며 태그를 붙일 수 있습니다.</p>

<p>ubuntu 14.04 이미지는 <strong>docker.io/library/ubuntu:14.04</strong> 또는 <strong>docker.io/libray/ubuntu:trusty</strong> 이고 <strong>docker.io/library</strong> 는 <strong>생략 가능</strong>하며 <strong>ubuntu:14.04</strong>로 사용할 수 있습니다.</p>

<p>이러한 방식은 이해하기 쉽고 편리하게 사용할 수 있으며 태그 기능을 잘 이용하면 테스트나 롤백도 쉽게 할 수 있습니다.
<br />
<br />
<br /></p>

<h2 id="dockerfile">Dockerfile</h2>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> subicura/vertx3:3.3.1</span>
<span class="k">MAINTAINER</span><span class="s"> chungsub.kim@purpleworks.co.kr</span>

<span class="k">ADD</span><span class="s"> build/distributions/app-3.3.1.tar /</span>
<span class="k">ADD</span><span class="s"> config.template.json /app-3.3.1/bin/config.json</span>
<span class="k">ADD</span><span class="s"> docker/script/start.sh /usr/local/bin/</span>
<span class="k">RUN </span><span class="nb">ln</span> <span class="nt">-s</span> /usr/local/bin/start.sh /start.sh

<span class="k">EXPOSE</span><span class="s"> 8080</span>
<span class="k">EXPOSE</span><span class="s"> 7000</span>

<span class="k">CMD</span><span class="s"> ["start.sh"]</span>
</code></pre></div></div>
<p>도커는 이미지를 만들기 <code class="language-plaintext highlighter-rouge">위해 Dockerfile</code> 이라는 파일에 자체 <code class="language-plaintext highlighter-rouge">DSLDomain-specific language</code> 언어를 이용하여 이미지 생성 과정을 작성합니다.
<br />
<br />
<br /></p>

<h2 id="docker-hub">Docker Hub</h2>
<p>도커 이미지의 용량은 보통 수백 MB이고, 수 GB가 넘는 경우도 흔합니다. 이렇게 큰 용량의 이미지를 서버에 저장하고 관리하는 것은 쉽지 않은데 도커는 <a href="https://hub.docker.com/search?q=" target="_blank">Docker hub</a>를 통해 공개 이미지를 무료로 관리해 줍니다. 
<br />
<br />
<br /></p>

<h2 id="command와-api">Command와 API</h2>
<p>도커 클라이언트의 커맨드 명령어는 직관적이고 사용하기 쉬우며 컨테이너의 복잡한 시스템 구성을 이해하지 못하더라도 편하게 사용할 수 있습니다. 또한 http기반의 Rest API도 지원하여 확장성이 굉장히 좋습니다.
<br />
<br />
<br /></p>

<h2 id="훌륭한-생태계">훌륭한 생태계</h2>
<p>도커는 굉장히 큰 생태계를 가지고 있고 커다란 기업과 협력하여 사실상 클라우드 컨테이너 세계의 기준이 되었습니다. 로깅, 모니터링, 스토리지, 네트워크, 컨테이너 관리, 배포등 다양한 분야에서 다양한 툴들이 존재합니다.
<br />
<br />
<br /></p>

<h2 id="커뮤니티-지원">커뮤니티 지원</h2>
<p>도커는 홍보와 커뮤니티 관리에 굉장히 신경쓰고 있습니다. 홈페이지에서는 전세계에서 열리는 밋업 상황을 볼 수 있고 일주일마다 발송되는 뉴스레터에는 다양한 개발자들의 글이 실려있습니다.
<br />
<br />
<br />
<br />
<br /></p>

<h1 id="-도커-구조">🎯 도커 구조</h1>
<p>도커는 클라이언트-서버 구조를 사용합니다.
<img src="/assets/images/posts/docker/20230216/d1969bd2-2ec2-41d2-924e-38202359d730.png" alt="도커 구조" /></p>

<h2 id="docker-daemon">Docker Daemon</h2>
<p>도커 데몬(<code class="language-plaintext highlighter-rouge">dockerd</code>)은 도커 REST API 요청을 듣고 도커 오브젝트들(이미지, 컨테이너, 네트워크, 볼륨)을 관리합니다. 또한 도커 데몬은 도커 서비스를 관리하는 다른 도커 데몬과 커뮤니케이션할 수 있습니다.
<br />
<br /></p>

<h2 id="docker-client">Docker Client</h2>
<p>도커 클라이언트(<code class="language-plaintext highlighter-rouge">docker</code>)는 도커 호스트와 통신하기 위한 기능을 수행합니다. 예를 들어, docker run 명령어를 실행하면 도커 클라이언트는 해당 명령어를 REST API Call으로 변환하여 도커 데몬(<code class="language-plaintext highlighter-rouge">dockerd</code>)으로 전송합니다.</p>

<p>도커 클라이언트의 주요 목적은 직접 레지스트리에서 이미지를 받아 호스트에서 실행할 수 있게 하는 것입니다.
<br />
<br /></p>

<h2 id="docker-registries">Docker Registries</h2>
<p>Docker Registries는 도커 이미지 저장소 역할을 수행합니다.
<br />
<br /></p>

<h2 id="docker-objects">Docker Objects</h2>
<p>Docker Object는 Docker Daemon에 의해, 생성 및 관리되는 이미지, 컨테이너, 네트워크, 볼륨 등의 개체를 말합니다.
<br />
<br />
<br />
<br />
<br /></p>

<h1 id="-도커-설치">🐳 도커 설치</h1>
<p>각 OS별 설치 방법은 다음 링크에서 확인 가능합니다.</p>
<ul>
  <li><a href="https://docs.docker.com/desktop/mac/install/" target="_blank">MacOS에서 도커 설치</a></li>
  <li><a href="https://docs.docker.com/desktop/linux/install/" target="_blank">Linux에서 도커 설치</a></li>
  <li><a href="https://docs.docker.com/desktop/windows/install/" target="_blank">Windows에서 도커 설치</a>
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h1>
<ul>
  <li><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank">https://subicura.com</a></li>
  <li><a href="https://www.daleseo.com/?tag=Docker" target="_blank">https://www.daleseo.com</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Docker" /><category term="Docker" /><category term="Container" /><summary type="html"><![CDATA[💾 도커 기본 개념을 정리한 내용입니다.]]></summary></entry><entry><title type="html">Spring Boot Test Cheat Sheet</title><link href="http://localhost:4000/spring/spring-boot-test-cheat-sheet/" rel="alternate" type="text/html" title="Spring Boot Test Cheat Sheet" /><published>2023-02-13T00:00:00+09:00</published><updated>2023-02-13T00:00:00+09:00</updated><id>http://localhost:4000/spring/spring-boot-test-cheat-sheet</id><content type="html" xml:base="http://localhost:4000/spring/spring-boot-test-cheat-sheet/"><![CDATA[<p>📝 Spring Boot Test Cheat Sheet 입니다. 설명은 없고 자주 사용하는 테스트 코드 참고용 입니다.</p>
<ul>
  <li><a href="/java/TDD(Test-Driven-Development)-테스트-주도-개발" target="_blank">JUnit 5, AssertJ Cheat Sheet</a></li>
</ul>

<p><br /></p>

<h2 id="buildgradle">build.gradle</h2>
<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencies</span> <span class="o">{</span>
    <span class="n">runtimeOnly</span> <span class="s1">'com.h2database:h2'</span>
    <span class="n">implementation</span> <span class="s1">'com.google.guava:guava:31.1-jre'</span>
    <span class="n">testImplementation</span> <span class="s1">'org.springframework.boot:spring-boot-starter-test'</span>
    <span class="n">testImplementation</span> <span class="s1">'io.rest-assured:rest-assured'</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="application-testyml">application-test.yml</h2>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">datasource</span><span class="pi">:</span>
    <span class="na">url</span><span class="pi">:</span> <span class="s">jdbc:h2:mem:test</span>
    <span class="na">username</span><span class="pi">:</span> <span class="s">sa</span>
    <span class="na">password</span><span class="pi">:</span>
    <span class="na">driver-class-name</span><span class="pi">:</span> <span class="s">org.h2.Driver</span>
  <span class="na">jpa</span><span class="pi">:</span>
    <span class="na">hibernate</span><span class="pi">:</span>
      <span class="na">ddl-auto</span><span class="pi">:</span> <span class="s1">'</span><span class="s">create-drop'</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="import">import</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">hamcrest</span><span class="o">.</span><span class="na">Matchers</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">junit</span><span class="o">.</span><span class="na">jupiter</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">assertj</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="databasecleanup">DatabaseCleanup</h2>
<p>JPA용, 애플리케이션 내 모든 엔티티 테이블 초기화 클래스</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="nd">@ActiveProfiles</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DatabaseCleanup</span> <span class="kd">implements</span> <span class="nc">InitializingBean</span> <span class="o">{</span>
    <span class="nd">@PersistenceContext</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">entityManager</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableNames</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">tableNames</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">getMetamodel</span><span class="o">().</span><span class="na">getEntities</span><span class="o">().</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">.</span><span class="na">getJavaType</span><span class="o">().</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">Entity</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="nc">CaseFormat</span><span class="o">.</span><span class="na">UPPER_CAMEL</span><span class="o">.</span><span class="na">to</span><span class="o">(</span><span class="nc">CaseFormat</span><span class="o">.</span><span class="na">LOWER_UNDERSCORE</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">entityManager</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">entityManager</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="s">"SET REFERENTIAL_INTEGRITY FALSE"</span><span class="o">).</span><span class="na">executeUpdate</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">tableName</span> <span class="o">:</span> <span class="n">tableNames</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">entityManager</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="s">"TRUNCATE TABLE "</span> <span class="o">+</span> <span class="n">tableName</span><span class="o">).</span><span class="na">executeUpdate</span><span class="o">();</span>
            <span class="n">entityManager</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="s">"ALTER TABLE "</span> <span class="o">+</span> <span class="n">tableName</span> <span class="o">+</span> <span class="s">" ALTER COLUMN ID RESTART WITH 1"</span><span class="o">).</span><span class="na">executeUpdate</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">entityManager</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="s">"SET REFERENTIAL_INTEGRITY TRUE"</span><span class="o">).</span><span class="na">executeUpdate</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="acceptance-abstract">Acceptance Abstract</h2>
<p>RestAssured 사용시 공통 부모 클래스. 랜덤포트와 테이블 초기화</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span><span class="o">(</span><span class="n">webEnvironment</span> <span class="o">=</span> <span class="nc">SpringBootTest</span><span class="o">.</span><span class="na">WebEnvironment</span><span class="o">.</span><span class="na">RANDOM_PORT</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AcceptanceTest</span> <span class="o">{</span>

    <span class="nd">@LocalServerPort</span>
    <span class="kt">int</span> <span class="n">port</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">DatabaseCleanup</span> <span class="n">databaseCleanup</span><span class="o">;</span>

    <span class="nd">@BeforeEach</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">RestAssured</span><span class="o">.</span><span class="na">port</span> <span class="o">=</span> <span class="n">port</span><span class="o">;</span>
        <span class="n">databaseCleanup</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="restassured">RestAssured</h2>
<ul>
  <li><a href="https://github.com/rest-assured/rest-assured/wiki/Usage" target="_blank">RestAssured 가이드</a></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExtractableResponse</span><span class="o">&lt;</span><span class="nc">Response</span><span class="o">&gt;</span> <span class="n">자동차_등록_요청</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">params</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>

    <span class="k">return</span> <span class="nc">RestAssured</span>
            <span class="o">.</span><span class="na">given</span><span class="o">().</span><span class="na">log</span><span class="o">().</span><span class="na">all</span><span class="o">()</span>
            <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="n">params</span><span class="o">)</span>
            <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON_VALUE</span><span class="o">)</span>
            <span class="o">.</span><span class="na">when</span><span class="o">().</span><span class="na">post</span><span class="o">(</span><span class="s">"/api/cars"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">then</span><span class="o">().</span><span class="na">log</span><span class="o">().</span><span class="na">all</span><span class="o">()</span>
            <span class="o">.</span><span class="na">extract</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">자동차_등록됨</span><span class="o">(</span><span class="nc">ExtractableResponse</span><span class="o">&lt;</span><span class="nc">Response</span><span class="o">&gt;</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">CREATED</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Location"</span><span class="o">)).</span><span class="na">isNotBlank</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExtractableResponse</span><span class="o">&lt;</span><span class="nc">Response</span><span class="o">&gt;</span> <span class="n">정보_조회_요청</span><span class="o">(</span><span class="nc">String</span> <span class="n">accessToken</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">RestAssured</span>
            <span class="o">.</span><span class="na">given</span><span class="o">().</span><span class="na">log</span><span class="o">().</span><span class="na">all</span><span class="o">()</span>
            <span class="o">.</span><span class="na">auth</span><span class="o">().</span><span class="na">oauth2</span><span class="o">(</span><span class="n">accessToken</span><span class="o">)</span>
            <span class="o">.</span><span class="na">when</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="s">"/members/me"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">then</span><span class="o">().</span><span class="na">log</span><span class="o">().</span><span class="na">all</span><span class="o">()</span>
            <span class="o">.</span><span class="na">extract</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="extendwithspringextensionclass-mockbean">@ExtendWith(SpringExtension.class), @MockBean</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">SpringExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringExtensionTest</span> <span class="o">{</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">LineRepository</span> <span class="n">lineRepository</span><span class="o">;</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">StationService</span> <span class="n">stationService</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">findAllLines</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// given</span>
        <span class="n">when</span><span class="o">(</span><span class="n">lineRepository</span><span class="o">.</span><span class="na">findAll</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Line</span><span class="o">()));</span>
        <span class="nc">LineService</span> <span class="n">lineService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LineService</span><span class="o">(</span><span class="n">lineRepository</span><span class="o">,</span> <span class="n">stationService</span><span class="o">);</span>

        <span class="c1">// when</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">LineResponse</span><span class="o">&gt;</span> <span class="n">responses</span> <span class="o">=</span> <span class="n">lineService</span><span class="o">.</span><span class="na">findLineResponses</span><span class="o">();</span>

        <span class="c1">// then</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">responses</span><span class="o">).</span><span class="na">hasSize</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="extendwithmockitoextensionclass-mock-injectmocks">@ExtendWith(MockitoExtension.class), @Mock, @InjectMocks</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MockitoExtensionTest</span> <span class="o">{</span>

    <span class="nd">@Mock</span>
    <span class="kd">private</span> <span class="nc">CarRepository</span> <span class="n">carRepository</span><span class="o">;</span>

    <span class="nd">@InjectMocks</span>
    <span class="kd">private</span> <span class="nc">CarService</span> <span class="n">carService</span><span class="o">;</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"이름을 받아 자동차를 저장한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(){</span>
        <span class="c1">// given</span>
        <span class="kd">final</span> <span class="nc">String</span> <span class="no">NAME</span> <span class="o">=</span> <span class="s">"Boong-Boong"</span><span class="o">;</span>
        <span class="n">when</span><span class="o">(</span><span class="n">carRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">any</span><span class="o">())).</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="no">NAME</span><span class="o">)));</span>
        
        <span class="c1">// when</span>
        <span class="nc">CarResponse</span> <span class="n">carResponse</span> <span class="o">=</span> <span class="n">carService</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="no">NAME</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">carResponse</span><span class="o">.</span><span class="na">getName</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="no">NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="webmvctest-mockbean-mockmvc">@WebMvcTest, @MockBean, MockMvc</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@WebMvcTest</span><span class="o">(</span><span class="nc">CarController</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CarControllerTest</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">API_BASE_PATH</span> <span class="o">=</span> <span class="s">"/api/cars"</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">CarService</span> <span class="n">carService</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"자동차를 생성한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createCar</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">//given</span>
        <span class="nc">CarRequest</span> <span class="n">carRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">carRequest</span><span class="o">(</span><span class="s">"Boong-Boong"</span><span class="o">);</span>
        <span class="nc">CarResponse</span> <span class="n">carResponse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CarResponse</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">carRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">given</span><span class="o">(</span><span class="n">carService</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">any</span><span class="o">())).</span><span class="na">willReturn</span><span class="o">(</span><span class="n">carResponse</span><span class="o">);</span>

        <span class="c1">//when, then</span>
        <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">post</span><span class="o">(</span><span class="no">API_BASE_PATH</span><span class="o">)</span>
                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">carRequest</span><span class="o">))</span>
                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isCreated</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.id"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">carResponse</span><span class="o">.</span><span class="na">getId</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="springboottest-autoconfiguremockmvc-mockmvc">@SpringBootTest, @AutoConfigureMockMvc, MockMvc</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CarControllerMockTest</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">API_BASE_PATH</span> <span class="o">=</span> <span class="s">"/api/cars"</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"자동차를 생성한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createCar</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">//given</span>
        <span class="nc">CarRequest</span> <span class="n">carRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">carRequest</span><span class="o">(</span><span class="s">"Boong-Boong"</span><span class="o">);</span>
        <span class="nc">CarResponse</span> <span class="n">carResponse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CarResponse</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">carRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>

        <span class="c1">//when, then</span>
        <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">post</span><span class="o">(</span><span class="no">API_BASE_PATH</span><span class="o">)</span>
                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">carRequest</span><span class="o">))</span>
                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isCreated</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.id"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">carResponse</span><span class="o">.</span><span class="na">getId</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="datajpatest-persistencecontext">@DataJpaTest, @PersistenceContext</h2>
<ul>
  <li>JPA 관련 설정만 로드</li>
  <li>데이터 소스, 엔티티 매니저 등 생성</li>
  <li>@Entity 어노테이션이 붙은 클래스 및 Spring Data JPA 에 대한 설정들 적용</li>
  <li>기본으로 in-memory database 사용</li>
  <li>@AutoConfigureTestDatabase를 사용하여 어떤 database를 연결할지 선택할 수 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@DataJpaTest</span>
<span class="nd">@ActiveProfiles</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
<span class="nd">@AutoConfigureTestDatabase</span><span class="o">(</span><span class="n">replace</span> <span class="o">=</span> <span class="nc">AutoConfigureTestDatabase</span><span class="o">.</span><span class="na">Replace</span><span class="o">.</span><span class="na">NONE</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">CarRepositoryTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">CarRepository</span> <span class="n">carRepository</span><span class="o">;</span>

    <span class="nd">@PersistenceContext</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">entityManager</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"자동차를 저장한다."</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        
        <span class="o">...</span>

        <span class="nc">Car</span> <span class="n">savedCar</span> <span class="o">=</span> <span class="n">carRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="s">"Boong-Boong"</span><span class="o">));</span>

        <span class="n">entityManager</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">entityManager</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="mybatistest">@MybatisTest</h2>
<ul>
  <li><a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-test-autoconfigure/index.html" target="_blank">Mybatis 테스트 가이드</a></li>
  <li>기본으로 in-memory database 사용</li>
  <li>@AutoConfigureTestDatabase를 사용하여 어떤 database를 연결할지 선택할 수 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">SpringExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@MybatisTest</span>
<span class="nd">@ActiveProfiles</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
<span class="nd">@AutoConfigureTestDatabase</span><span class="o">(</span><span class="n">replace</span> <span class="o">=</span> <span class="nc">AutoConfigureTestDatabase</span><span class="o">.</span><span class="na">Replace</span><span class="o">.</span><span class="na">NONE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">OrderMapper</span> <span class="n">orderMapper</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mybatis_test</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

        <span class="c1">// given</span>
        <span class="nc">String</span> <span class="n">seq</span> <span class="o">=</span> <span class="s">"1"</span><span class="o">;</span>

        <span class="c1">// when</span>
        <span class="nc">OrderVO</span> <span class="n">vo</span> <span class="o">=</span> <span class="n">orderMapper</span><span class="o">.</span><span class="na">getOrder</span><span class="o">(</span><span class="n">seq</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">vo</span><span class="o">.</span><span class="na">getSeq</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="mock-mockbean-차이점">@Mock, @MockBean 차이점</h2>

<table>
  <thead>
    <tr>
      <th>Mock 종류</th>
      <th>의존성 주입 대상</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>@Mock</td>
      <td>@InjectMocks</td>
    </tr>
    <tr>
      <td>@MockBean</td>
      <td>Spring Context</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@Mock</code>은 <code class="language-plaintext highlighter-rouge">@InjectMocks</code>에 대해서만 해당 클래스안에서 정의된 객체를 찾아서 의존성을 해결</li>
  <li><code class="language-plaintext highlighter-rouge">@MockBean</code>은 <code class="language-plaintext highlighter-rouge">mock</code> 객체를 스프링 컨텍스트에 등록<br />
<br />
<br /></li>
</ul>

<h2 id="mockmvc-주입방법">MockMVC 주입방법</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">@SpringBootTest</code> + <code class="language-plaintext highlighter-rouge">@AutoConfigureMockMvc</code> : MockMVC를 이용하여 통합테스트 할 때 사용</li>
  <li><code class="language-plaintext highlighter-rouge">@WebMvcTest</code> : MVC만 슬라이스(slice) 테스트 할 때 사용</li>
</ol>]]></content><author><name>Oh</name></author><category term="Spring" /><category term="Spring" /><category term="Java" /><category term="Test" /><category term="CheatSheet" /><summary type="html"><![CDATA[📝 Spring Boot Test Cheat Sheet 입니다. 설명은 없고 자주 사용하는 테스트 코드 참고용 입니다. JUnit 5, AssertJ Cheat Sheet]]></summary></entry><entry><title type="html">Test Double</title><link href="http://localhost:4000/insight/Test-Double/" rel="alternate" type="text/html" title="Test Double" /><published>2023-02-12T00:00:00+09:00</published><updated>2023-02-12T00:00:00+09:00</updated><id>http://localhost:4000/insight/Test-Double</id><content type="html" xml:base="http://localhost:4000/insight/Test-Double/"><![CDATA[<p>테스트 더블(Test Dobule)에 대해 설명합니다.</p>

<p><br /></p>

<h1 id="-테스트-더블이란">🤔 테스트 더블이란?</h1>
<ul>
  <li>Test Dobule이라 한다.</li>
  <li>테스트를 진행하기 어려운 경우 이를 <strong>대신해 테스트를 진행할 수 있도록 만들어주는 객체를 말한다.</strong></li>
  <li>제라드 메스자로스(Gerard Meszaros)가 만든 용어로,  스턴트 더블(영화 촬영에서 말하는 스턴트 대역 배우)에서 아이디어를 얻어서 만든 용어이다.</li>
</ul>

<div class="notice--info">
<p>예를 들어 우리가 데이터베이스로부터 조회한 값을 연산하는 로직을 구현했다고 하자. 해당 로직을 테스트하기 위해선 항상 데이터베이스의 영향을 받을 것이고, 이는 데이터베이스의 상태에 따라 다른 결과를 유발할 수도 있다.</p>

<p>이때 <strong>테스트하려는 객체와 연관된 객체를 사용하기가 어렵고 모호할 때 대신해 줄 수 있는 객체를 테스트 더블이라 한다.</strong></p>
</div>
<p><br /></p>

<h1 id="-테스트-더블-종류">📖 테스트 더블 종류</h1>
<p><img src="/assets/images/posts/insight/20230212/e7604428-37a2-4e06-9dd4-35e3dc4e7d77.png" alt="TestDouble" />
테스트 더블은 크게 <code class="language-plaintext highlighter-rouge">Dummy</code>, <code class="language-plaintext highlighter-rouge">Fake</code>, <code class="language-plaintext highlighter-rouge">Stub</code>, <code class="language-plaintext highlighter-rouge">Spy</code>, <code class="language-plaintext highlighter-rouge">Mock</code>으로 나눈다.</p>

<h2 id="-dummy">🎯 Dummy</h2>
<ul>
  <li>가장 기본적인 테스트 더블이다.</li>
  <li>인스턴스화 된 객체가 필요하지만 기능은 필요하지 않은 경우에 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Dummy</code> 객체의 메서드가 호출되었을 때 정상 동작은 보장하지 않는다.</li>
  <li>객체는 전달되지만 사용되지 않는 객체이다.<br />
<br /></li>
</ul>

<p><strong>Dummy 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">PringWarning</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrintWarningDummy</span> <span class="kd">implements</span> <span class="nc">PrintWarning</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 아무런 동작을 하지 않는다.</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>실제 객체는 PrintWarning 인터페이스의 구현체를 필요하지만, 특정 테스트에서는 해당 구현체의 동작이 전혀 필요하지 않을 수 있다. 실제 객체가 로그용 경고만 출력한다면 테스트 환경에서는 전혀 필요 없기 때문이다.</p>

<p>이처럼 동작하지 않아도 테스트에는 영향을 미치지 않는 객체를 <code class="language-plaintext highlighter-rouge">Dummy</code> 객체라고 한다.
<br />
<br /></p>

<h2 id="-fake">🎯 Fake</h2>
<ul>
  <li>복잡한 로직이나 객체 내부에서 필요로 하는 다른 외부 객체들의 동작을 단순화하여 구현한 객체이다.</li>
  <li>동작의 구현을 가지고 있지만 실제 프로덕션에는 적합하지 않은 객체이다.</li>
  <li>즉, <strong>동작은 하지만 실제 사용되는 객체처럼 정교하게 동작하지는 않는 객체를 말한다.</strong><br />
<br /></li>
</ul>

<p><strong>Fake 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">);</span>
    <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FakeUserRepository</span> <span class="kd">implements</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">findById</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">user</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">User</span> <span class="n">user</span> <span class="o">:</span> <span class="n">users</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">==</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>실제 데이터베이스를 연결해서 테스트해야 하지만, 실제 데이터베이스 대신 가짜 데이터베이스 역할을 하는 FakeUserRepository를 만들어 테스트 객체에 주입한다. 이렇게 하면 테스트 객체는 데이터베이스에 의존하지 않으면서도 동일하게 동작을 하는 가짜 데이터베이스를 가지게 된다.</p>

<p>이처럼 실제 객체와 동일한 역할을 하도록 만들어 사용하는 객체가 <code class="language-plaintext highlighter-rouge">Fake</code>이다.<br />
<br />
<br /></p>

<h2 id="-stub">🎯 Stub</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Dummy</code> 객체가 실제로 동작하는 것 처럼 보이게 만들어 놓은 객체이다.</li>
  <li>테스트에서 호출된 요청에 대해 미리 준비해둔 결과를 제공한다.</li>
  <li><strong>상태를 검증한다.</strong></li>
  <li>즉, <strong>테스트를 위해 프로그래밍된 내용에 대해서만 준비된 결과를 제공하는 객체이다.</strong></li>
</ul>

<p><strong>Stub 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GradeServiceTest</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Student</span> <span class="n">student</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Gradebook</span> <span class="n">gradebook</span><span class="o">;</span>

    <span class="nd">@Before</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">gradebook</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="nc">Gradebook</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">calculates_grades_average_for_student</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">when</span><span class="o">(</span><span class="n">gradebook</span><span class="o">.</span><span class="na">gradesFor</span><span class="o">(</span><span class="n">student</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">grades</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span> <span class="c1">//stubbing gradebook</span>

        <span class="kt">double</span> <span class="n">averageGrades</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GradesService</span><span class="o">(</span><span class="n">gradebook</span><span class="o">).</span><span class="na">averageGrades</span><span class="o">(</span><span class="n">student</span><span class="o">);</span>

        <span class="n">assertThat</span><span class="o">(</span><span class="n">averageGrades</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mf">8.0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>우리가 테스트에서 자주 사용하는 <code class="language-plaintext highlighter-rouge">Mockito</code> 프레임워크도 <code class="language-plaintext highlighter-rouge">Stub</code>와 같은 역할을 해준다.</p>

<p>이처럼 테스트를 위해 의도한 결과만 반환되도록 하기 위한 객체가 <code class="language-plaintext highlighter-rouge">Stub</code>이다.<br />
<br />
<br /></p>

<h2 id="-spy">🎯 Spy</h2>
<ul>
  <li>Stub의 역할을 가지면서 호출된 내용에 대해 약간의 정보를 기록한다.</li>
  <li>실제 객체처럼 동작시킬 수도 있고, 필요한 부분에 대해서는 Stub로 만들어서 동작을 지정할 수도 있다.</li>
  <li>즉, <strong>실제 기능을 사용하면서 선택적으로 Stub하는 객체이다.</strong></li>
</ul>

<p><strong>Spy 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpyTests</span> <span class="o">{</span>

    <span class="nd">@Spy</span>
    <span class="kd">private</span> <span class="nc">OrderRepository</span> <span class="n">orderRepository</span><span class="o">;</span>
    <span class="nd">@Spy</span>
    <span class="kd">private</span> <span class="nc">NotificationClient</span> <span class="n">notificationClient</span><span class="o">;</span>
    <span class="nd">@InjectMocks</span>
    <span class="kd">private</span> <span class="nc">OrderService</span> <span class="n">orderService</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createOrderTest_basic</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// given</span>
        <span class="c1">// Spy 객체의 orderRepository의 createOrder()만 Stub하고 나머지 기능은 그대로 사용</span>
        <span class="nc">Mockito</span><span class="o">.</span><span class="na">doAnswer</span><span class="o">(</span><span class="n">invocation</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"I'm spy orderRepository createOrder"</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}).</span><span class="na">when</span><span class="o">(</span><span class="n">orderRepository</span><span class="o">).</span><span class="na">createOrder</span><span class="o">();</span>
        <span class="nc">Mockito</span><span class="o">.</span><span class="na">doAnswer</span><span class="o">(</span><span class="n">invocation</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"I'm spy notificationclient"</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}).</span><span class="na">when</span><span class="o">(</span><span class="n">notificationClient</span><span class="o">).</span><span class="na">notifyToMobile</span><span class="o">();</span>


        <span class="c1">// when</span>
        <span class="n">orderService</span><span class="o">.</span><span class="na">createOrder</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="nc">Mockito</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">orderRepository</span><span class="o">,</span> <span class="nc">Mockito</span><span class="o">.</span><span class="na">times</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">createOrder</span><span class="o">();</span>
        <span class="nc">Mockito</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">notificationClient</span><span class="o">,</span> <span class="nc">Mockito</span><span class="o">.</span><span class="na">times</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">notifyToMobile</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="-mock">🎯 Mock</h2>
<ul>
  <li>Mock은 행위를 검증하기 위해 가짜 객체를 만들고 테스트하는 방법이다.</li>
  <li>테스트가 정상적으로 호출되었는지, <strong>행위를 검증한다.</strong><br />
<br /></li>
</ul>

<p><strong>Mock 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityCentral</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Window</span> <span class="n">window</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Door</span> <span class="n">door</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">SecurityCentral</span><span class="o">(</span><span class="nc">Window</span> <span class="n">window</span><span class="o">,</span> <span class="nc">Door</span> <span class="n">door</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">window</span> <span class="o">=</span> <span class="n">window</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">door</span> <span class="o">=</span> <span class="n">door</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">securityOn</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">window</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">door</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityCentralTest</span> <span class="o">{</span>
    <span class="nc">Window</span> <span class="n">windowMock</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="nc">Window</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="nc">Door</span> <span class="n">doorMock</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="nc">Door</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enabling_security_locks_windows_ans_doors</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">SecurityCentral</span> <span class="n">securityCentral</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecurityCentral</span><span class="o">(</span><span class="n">windowMock</span><span class="o">,</span> <span class="n">doorMock</span><span class="o">);</span>

        <span class="n">securityCentral</span><span class="o">.</span><span class="na">securityOn</span><span class="o">();</span>

        <span class="c1">// 행위 검증</span>
        <span class="n">verify</span><span class="o">(</span><span class="n">windowMock</span><span class="o">).</span><span class="na">close</span><span class="o">();</span>
        <span class="n">verify</span><span class="o">(</span><span class="n">doorMock</span><span class="o">).</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h1 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h1>
<ul>
  <li><a href="https://tecoble.techcourse.co.kr/post/2020-09-19-what-is-test-double/" target="_blank">https://tecoble.techcourse.co.kr</a></li>
  <li><a href="https://cobbybb.tistory.com/16" target="_blank">https://cobbybb.tistory.com/16</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Insight" /><category term="Insight" /><category term="Test" /><category term="TestDobule" /><summary type="html"><![CDATA[테스트 더블(Test Dobule)에 대해 설명합니다.]]></summary></entry><entry><title type="html">단위 테스트, 통합 테스트, 인수 테스트</title><link href="http://localhost:4000/insight/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9D%B8%EC%88%98%ED%85%8C%EC%8A%A4%ED%8A%B8/" rel="alternate" type="text/html" title="단위 테스트, 통합 테스트, 인수 테스트" /><published>2023-02-09T00:00:00+09:00</published><updated>2023-02-09T00:00:00+09:00</updated><id>http://localhost:4000/insight/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9D%B8%EC%88%98%ED%85%8C%EC%8A%A4%ED%8A%B8</id><content type="html" xml:base="http://localhost:4000/insight/%EB%8B%A8%EC%9C%84%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%9D%B8%EC%88%98%ED%85%8C%EC%8A%A4%ED%8A%B8/"><![CDATA[<p>단위 테스트, 통합 테스트, 인수  테스트에 대해 설명합니다.</p>

<p><br /></p>

<h1 id="-단위-테스트란">🤔 단위 테스트란?</h1>
<ul>
  <li>Unit Test라고 한다.</li>
  <li>개발자 관점에서 테스트한다.</li>
  <li>구현한 부분, 단위를 검증한다.</li>
  <li>단위 기능을 중심으로 다른 외부 영향을 배제하고 테스트 하는 것이 목적이다.</li>
  <li>협력 객체가 존재하는 경우에는 협력 객체가 원하는 결과를 응답하도록 모킹한다.<br />
<br /></li>
</ul>

<p><strong>단위 테스트 범위</strong></p>
<ul>
  <li>단위의 크기를 정확히 제시하기는 어렵다.</li>
  <li>일반적으로 특정한 책임을 수행하면서, 고립될 수 있는 최소 단위<br />
<br /></li>
</ul>

<p><strong>단위 테스트 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">UnitTest</span> <span class="o">{</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"이름을 받아 자동차 생성"</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createCar</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// given</span>
        <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"Boong-Boong"</span><span class="o">;</span>

        <span class="c1">// when</span>
        <span class="nc">Car</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">car</span><span class="o">).</span><span class="na">isNotNull</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"숫자 4를 받으면 자동차가 1 전진한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">moveCar</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// given</span>
        <span class="nc">Car</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="s">"Boong-Boong"</span><span class="o">);</span>

        <span class="c1">// when</span>
        <span class="n">car</span><span class="o">.</span><span class="na">move</span><span class="o">(</span><span class="mi">4</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">car</span><span class="o">.</span><span class="na">getPosition</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>협력 객체의 단위 테스트 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">ServiceTest</span> <span class="o">{</span>

    <span class="nd">@Mock</span>
    <span class="kd">private</span> <span class="nc">CarRepository</span> <span class="n">carRepository</span><span class="o">;</span>

    <span class="nd">@InjectMocks</span>
    <span class="kd">private</span> <span class="nc">CarService</span> <span class="n">carService</span><span class="o">;</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"이름을 받아 자동차를 저장한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(){</span>
        <span class="c1">// given</span>
        <span class="kd">final</span> <span class="nc">String</span> <span class="no">NAME</span> <span class="o">=</span> <span class="s">"Boong-Boong"</span><span class="o">;</span>
        <span class="n">when</span><span class="o">(</span><span class="n">carRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">any</span><span class="o">())).</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="no">NAME</span><span class="o">)));</span>
        
        <span class="c1">// when</span>
        <span class="nc">CarResponse</span> <span class="n">carResponse</span> <span class="o">=</span> <span class="n">carService</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="no">NAME</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">carResponse</span><span class="o">.</span><span class="na">getName</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="no">NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@WebMvcTest</span><span class="o">(</span><span class="nc">CarController</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CarControllerTest</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">API_BASE_PATH</span> <span class="o">=</span> <span class="s">"/api/cars"</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">CarService</span> <span class="n">carService</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"자동차를 생성한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createCar</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">//given</span>
        <span class="nc">CarRequest</span> <span class="n">carRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">carRequest</span><span class="o">(</span><span class="s">"Boong-Boong"</span><span class="o">);</span>
        <span class="nc">CarResponse</span> <span class="n">carResponse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CarResponse</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">carRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">given</span><span class="o">(</span><span class="n">carService</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">any</span><span class="o">())).</span><span class="na">willReturn</span><span class="o">(</span><span class="n">carResponse</span><span class="o">);</span>

        <span class="c1">//when, then</span>
        <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">post</span><span class="o">(</span><span class="no">API_BASE_PATH</span><span class="o">)</span>
                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">carRequest</span><span class="o">))</span>
                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isCreated</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.id"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">carResponse</span><span class="o">.</span><span class="na">getId</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h1 id="-통합-테스트란">🤔 통합 테스트란?</h1>
<ul>
  <li>Integration Test라고 한다.</li>
  <li>개발자 관점에서 테스트한다.</li>
  <li>여러 기능을 조합하여 전체 비지니스 로직이 제대로 동작하는지 확인하는 것을 의미한다.</li>
  <li>단위 기능 간의 의존성을 포함하여 테스트한다.</li>
  <li>단위 테스트와 달리 개발자가 변경할 수 없는 부분(예: 외부 라이브러리)까지 묶어 검증할 때 사용한다.<br />
<br /></li>
</ul>

<p><strong>통합 테스트 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span><span class="o">(</span><span class="n">webEnvironment</span> <span class="o">=</span> <span class="nc">SpringBootTest</span><span class="o">.</span><span class="na">WebEnvironment</span><span class="o">.</span><span class="na">MOCK</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">CarServiceTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">CarService</span> <span class="n">carService</span><span class="o">;</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"이름을 받아 자동차를 저장한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(){</span>
        <span class="c1">// given</span>
        <span class="kd">final</span> <span class="nc">String</span> <span class="no">NAME</span> <span class="o">=</span> <span class="s">"Boong-Boong"</span><span class="o">;</span>
        
        <span class="c1">// when</span>
        <span class="nc">CarResponse</span> <span class="n">car</span> <span class="o">=</span> <span class="n">carService</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="no">NAME</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">car</span><span class="o">.</span><span class="na">getName</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="no">NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h1 id="-인수-테스트란">🤔 인수 테스트란?</h1>
<ul>
  <li>Acceptance Test라고 한다.</li>
  <li>사용자 관점에서 테스트한다.</li>
  <li>사용자 스토리(시나리오)에 맞춰 수행하는 테스트이다.</li>
  <li>요구사항을 만족하는지를 검증한다.</li>
  <li>다른 의사소통집단으로부터 시나리오를 받아(인수) 개발한다는 의미를 가지고 있다.<br />
<br /></li>
</ul>

<p><strong>인수 테스트 예: MockMvc</strong></p>

<div class="notice--info">
<ul>
  <li>실제로 서버를 구동하진 않고 모킹한 Spring MVC 환경을 구현</li>
  <li>MVC 서버와 요청을 날리는 곳의 스레드가 분리되므로 <code class="language-plaintext highlighter-rouge">@Transaction</code>을 선언하여도 <code class="language-plaintext highlighter-rouge">Rollback</code>되지 않음.
    <ul>
      <li>데이터를 직접 삭제해야함</li>
    </ul>
  </li>
</ul>
</div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CarControllerMockTest</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">API_BASE_PATH</span> <span class="o">=</span> <span class="s">"/api/cars"</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"자동차를 생성한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createCar</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">//given</span>
        <span class="nc">CarRequest</span> <span class="n">carRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">carRequest</span><span class="o">(</span><span class="s">"Boong-Boong"</span><span class="o">);</span>
        <span class="nc">CarResponse</span> <span class="n">carResponse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CarResponse</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">carRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>

        <span class="c1">//when, then</span>
        <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">post</span><span class="o">(</span><span class="no">API_BASE_PATH</span><span class="o">)</span>
                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">carRequest</span><span class="o">))</span>
                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isCreated</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.id"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">carResponse</span><span class="o">.</span><span class="na">getId</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>인수 테스트 예: RestAssured</strong></p>

<div class="notice--info">
<ul>
  <li>실제 서버를 구동하여 실제와 동일한 환경에서 테스트를 지원</li>
  <li>MockMvc와 마찬가지로 MVC 서버와 요청을 날리는 곳의 스레드가 분리되므로 <code class="language-plaintext highlighter-rouge">@Transaction</code>을 선언하여도 <code class="language-plaintext highlighter-rouge">Rollback</code>되지 않음.
    <ul>
      <li>데이터를 직접 삭제해야함</li>
    </ul>
  </li>
</ul>
</div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span><span class="o">(</span><span class="n">webEnvironment</span> <span class="o">=</span> <span class="nc">SpringBootTest</span><span class="o">.</span><span class="na">WebEnvironment</span><span class="o">.</span><span class="na">RANDOM_PORT</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AcceptanceTest</span> <span class="o">{</span>

    <span class="nd">@LocalServerPort</span>
    <span class="kt">int</span> <span class="n">port</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">DatabaseCleanup</span> <span class="n">databaseCleanup</span><span class="o">;</span> <span class="c1">// 애플리케이션에 등록된 엔티티를 테이블을 비워주는 클래스를 만들어 (임의로 만든 클레스)</span>

    <span class="nd">@BeforeEach</span> <span class="c1">// 매 테스트 실행 전에</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">RestAssured</span><span class="o">.</span><span class="na">port</span> <span class="o">=</span> <span class="n">port</span><span class="o">;</span>
        <span class="n">databaseCleanup</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>  <span class="c1">// 테이블을 비워준다.</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CarAcceptanceTest</span> <span class="kd">extends</span> <span class="nc">AcceptanceTest</span><span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">API_BASE_PATH</span> <span class="o">=</span> <span class="s">"/api/cars"</span><span class="o">;</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"자동차를 생성한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createCar</span><span class="o">(){</span>
        <span class="c1">//give</span>
        <span class="nc">CarRequest</span> <span class="n">자동차</span> <span class="o">=</span> <span class="k">new</span> <span class="n">carRequest</span><span class="o">(</span><span class="s">"Boong-Boong"</span><span class="o">);</span>

        <span class="c1">//when</span>
        <span class="nc">ExtractableResponse</span><span class="o">&lt;</span><span class="nc">Response</span><span class="o">&gt;</span> <span class="n">자동차_생성_결과</span> <span class="o">=</span> <span class="n">자동차_생성_요청</span><span class="o">(</span><span class="n">자동차</span><span class="o">);</span>

        <span class="c1">//then</span>
        <span class="n">자동차_생성_완료됨</span><span class="o">(</span><span class="n">자동차_생성_결과</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">ExtractableResponse</span><span class="o">&lt;</span><span class="nc">Response</span><span class="o">&gt;</span> <span class="n">자동차_생성_요청</span><span class="o">(</span><span class="nc">CarRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">RestAssured</span>
            <span class="o">.</span><span class="na">given</span><span class="o">().</span><span class="na">log</span><span class="o">().</span><span class="na">all</span><span class="o">()</span>
            <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON_VALUE</span><span class="o">)</span>
            <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="n">request</span><span class="o">)</span>
            <span class="o">.</span><span class="na">when</span><span class="o">().</span><span class="na">post</span><span class="o">(</span><span class="no">API_BASE_PATH</span><span class="o">)</span>
            <span class="o">.</span><span class="na">then</span><span class="o">().</span><span class="na">log</span><span class="o">().</span><span class="na">all</span><span class="o">()</span>
            <span class="o">.</span><span class="na">extract</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">자동차_생성_완료됨</span><span class="o">(</span><span class="nc">ExtractableResponse</span><span class="o">&lt;</span><span class="nc">Response</span><span class="o">&gt;</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">OK</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br /></p>

<h1 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h1>
<ul>
  <li><a href="https://jerry92k.tistory.com/m/77" target="_blank">https://jerry92k.tistory.com/</a></li>
  <li><a href="https://tecoble.techcourse.co.kr/post/2021-05-25-unit-test-vs-integration-test-vs-acceptance-test/" target="_blank">https://tecoble.techcourse.co.kr</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Insight" /><category term="Insight" /><category term="Test" /><summary type="html"><![CDATA[단위 테스트, 통합 테스트, 인수 테스트에 대해 설명합니다.]]></summary></entry><entry><title type="html">JUnit 5, AssertJ Cheat Sheet</title><link href="http://localhost:4000/java/TDD(Test-Driven-Development)-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C/" rel="alternate" type="text/html" title="JUnit 5, AssertJ Cheat Sheet" /><published>2023-02-08T00:00:00+09:00</published><updated>2023-02-08T00:00:00+09:00</updated><id>http://localhost:4000/java/TDD(Test%20Driven%20Development)-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C</id><content type="html" xml:base="http://localhost:4000/java/TDD(Test-Driven-Development)-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C/"><![CDATA[<p>JUnit 5, AssertJ의 사용법을 간단하게 정리하였습니다. 😁</p>
<ul>
  <li><a href="https://junit.org/junit5/docs/current/user-guide/#overview-what-is-junit-5" target="_blank">jUnit 5 가이드 링크</a></li>
  <li><a href="https://assertj.github.io/doc/" target="_blank">AssertJ 가이드 링크</a>
<br />
<br />
<br /></li>
</ul>

<h1 id="-junit-이란">🤔 JUnit 이란?</h1>
<ul>
  <li>Java 진영의 대표적인 Test Framework</li>
  <li>단위 테스트(Unit Test)를 위한 도구를 제공
    <ul>
      <li>단위 테스트란?
        <ul>
          <li>코드의 특정 모듈이 의도된 대로 동작하는지 테스트하는 절차를 의미</li>
          <li>모든 함수와 메소드에 대해 각각의 테스트 케이스를 작성하는 것</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>어노테이션(Annotation)을 기반으로 테스트를 지원</li>
  <li>단정문(Assert)으로 테스트 케이스의 기대값에 대해 수행 결과를 확인 할 수 있다</li>
  <li>Spring Boot 2.2 버전 부터 JUnit 5 버전을 사용</li>
  <li>JUnit은 크게 Jupiter, Platform, Vintage 모듈로 구성<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="-junit-5-모듈-설명">📖 JUnit 5 모듈 설명</h1>
<p><strong>JUnit Jupiter</strong></p>
<ul>
  <li>TestEngine API 구현체로 JUnit 5를 구현하고 있다.</li>
  <li>테스트의 실제 구현체는 별도 모듈 역할을 수행하는데, 그 모듈 중 하나가 Jupiter-Engine이다.</li>
  <li>이 모듈은 Jupiter-API를 사용하여 작성한 테스트 코드를 발견하고 실행하는 역할을 수행한다.</li>
  <li>개발자가 테스트 코드를 작성할 때 사용된다.</li>
</ul>

<p><strong>JUnit Platform</strong></p>
<ul>
  <li>Test를 실행하기 위한 뼈대</li>
  <li>Test를 발견하고 테스트 계획을 생성하는 TestEngine 인터페이스를 가지고 있다.</li>
  <li>TestEngine을 통해 Test를 발견하고, 수행 및 결과를 보고한다. 그리고 각종 IDE 연동을 보조하는 역할을 수행한다.(콘솔 출력 등)</li>
  <li>Platform = TestEngine API + Console Launcher + JUnit 4 Based Runner 등</li>
</ul>

<p><strong>JUnit Vintage</strong></p>
<ul>
  <li>TestEngine API 구현체로 JUnit 3, 4를 구현하고 있다.</li>
  <li>기존 JUnit 3, 4버전으로 작성된 테스트 코드를 실행할 때 사용된다.</li>
  <li>Vintage-Engine 모듈을 포함하고 있다.</li>
</ul>

<p><img src="/assets/images/posts/java/junit5/3b581de9-e2a5-4f19-afe8-098b61a9e370.png" alt="jUnit Module" />
<br />
<br />
<br />
<br /></p>

<h1 id="-junit-5-어노테이션">📖 JUnit 5 어노테이션</h1>
<p><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations" target="_blank">어노테이션 가이드 링크</a></p>

<h2 id="라이프사이클-어노테이션">라이프사이클 어노테이션</h2>
<p>JUnit 5는 아래와 같은 테스트 라이프 사이클을 가지고 있습니다.</p>

<table>
  <thead>
    <tr>
      <th>Annotation</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>@Test</td>
      <td>테스트용 메소드를 표현하는 어노테이션</td>
    </tr>
    <tr>
      <td>@BeforeEach</td>
      <td>각 테스트 메소드가 시작되기 전에 실행되어야 하는 메소드를 표현</td>
    </tr>
    <tr>
      <td>@AfterEach</td>
      <td>각 테스트 메소드가 시작된 후 실행되어야 하는 메소드를 표현</td>
    </tr>
    <tr>
      <td>@BeforeAll</td>
      <td>테스트 시적 전에 실행되어야 하는 메소드를 표현 (static 처리 필요)</td>
    </tr>
    <tr>
      <td>@AfterAll</td>
      <td>테스트 종료 후에 실행되어야 하는 메소드를 표현 (static 처리 필요)</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h2 id="parameterizedtest">@ParameterizedTest</h2>
<p>파라미터 테스트를 할 수 있게 도와주는 어노테이션으로, <code class="language-plaintext highlighter-rouge">@ValueSource</code>, <code class="language-plaintext highlighter-rouge">@CsvSource</code>,<code class="language-plaintext highlighter-rouge">@MethodSource</code> 등을 통해 매개변수를 지정할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ParameterizedTest</span>
<span class="nd">@ValueSource</span><span class="o">(</span><span class="n">ints</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span> <span class="o">})</span>
<span class="kt">void</span> <span class="nf">isPositive</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">assertTrue</span><span class="o">(</span><span class="n">number</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ParameterizedTest</span>
<span class="nd">@CsvSource</span><span class="o">({</span>
    <span class="s">"apple,         1"</span><span class="o">,</span>
    <span class="s">"banana,        2"</span><span class="o">,</span>
    <span class="s">"'lemon, lime', 0xF1"</span><span class="o">,</span>
    <span class="s">"strawberry,    700_000"</span>
<span class="o">})</span>
<span class="kt">void</span> <span class="nf">testWithCsvSource</span><span class="o">(</span><span class="nc">String</span> <span class="n">fruit</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rank</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertNotNull</span><span class="o">(</span><span class="n">fruit</span><span class="o">);</span>
    <span class="n">assertNotEquals</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">rank</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ParameterizedTest</span>
<span class="nd">@MethodSource</span><span class="o">(</span><span class="s">"stringProvider"</span><span class="o">)</span>
<span class="kt">void</span> <span class="nf">testWithExplicitLocalMethodSource</span><span class="o">(</span><span class="nc">String</span> <span class="n">argument</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertNotNull</span><span class="o">(</span><span class="n">argument</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="nf">stringProvider</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"apple"</span><span class="o">,</span> <span class="s">"banana"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="repeatedtest">@RepeatedTest</h2>
<p>반복 테스트를 위해 사용되는 어노테이션</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RepeatedTest</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="kt">void</span> <span class="nf">repeatedTest</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"테스트 반복!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="testmethodorder">@TestMethodOrder</h2>
<p>우선 순위에 따라 테스트를 실행할 수 있도록 도와주는 어노테이션. <code class="language-plaintext highlighter-rouge">@Order</code> 를 통해 우선순위를 지정할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@TestMethodOrder</span><span class="o">(</span><span class="nc">OrderAnnotation</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">OrderedTestsDemo</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="nd">@Order</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
  <span class="kt">void</span> <span class="nf">secondTest</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"2"</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="nd">@Test</span>
  <span class="nd">@Order</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="kt">void</span> <span class="nf">firstTest</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="testinstance">@TestInstance</h2>
<p>생명주기를 지정할 수 있는 어노테이션</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@TestInstance</span><span class="o">(</span><span class="nc">Lifecycle</span><span class="o">.</span><span class="na">PER_CLASS</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">OrderedTestsDemo</span> <span class="o">{...}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="displayname">@DisplayName</h2>
<p>테스트 이름을 지정할 수 있는 어노테이션</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"기본 산수를 검증하는 테스트"</span><span class="o">)</span>
<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">basic</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">assertEquals</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="nested">@Nested</h2>
<p>중첩 클래스 테스트라는 것을 명시하는 어노테이션 <code class="language-plaintext highlighter-rouge">@BeforeAll</code> 또는 <code class="language-plaintext highlighter-rouge">@AfterAll</code> 를 사용하려면 생명 주기를 명시해야한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NestedTests</span> <span class="o">{</span>

  <span class="nd">@TestInstance</span><span class="o">(</span><span class="nc">Lifecycle</span><span class="o">.</span><span class="na">PER_CLASS</span><span class="o">)</span>
  <span class="nd">@Nested</span>
  <span class="kd">class</span> <span class="nc">Positive</span> <span class="o">{</span>

    <span class="nd">@BeforeAll</span>
    <span class="kt">void</span> <span class="nf">startTest</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"테스트 시작"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">isPositive</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">assertTrue</span><span class="o">(</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="nd">@Nested</span>
  <span class="kd">class</span> <span class="nc">Negative</span> <span class="o">{</span>
    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">isNegative</span><span class="o">()</span> <span class="o">{</span>
      <span class="n">assertTrue</span><span class="o">(-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="tag">@Tag</h2>
<p>태그를 선언하는 어노테이션. 추후에 구성 설정 파일을 통해 테스트에 포함 시킬 태그를 선택하거나, 제외시킬 태그를 선택할 수 있다. JUnit4의 <code class="language-plaintext highlighter-rouge">@Category</code>가 이 어노테이션으로 대체됨</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Tag</span><span class="o">(</span><span class="s">"number"</span><span class="o">)</span>
<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">basic</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">assertEquals</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">junitPlatform</span> <span class="o">{</span>
  <span class="n">filters</span> <span class="o">{</span>
      <span class="n">tags</span> <span class="o">{</span>
          <span class="n">include</span> <span class="s1">'number'</span><span class="o">,</span> <span class="s1">'korean'</span>
          <span class="n">exclude</span> <span class="s1">'english'</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="disabled">@Disabled</h2>
<p>테스트에서 제외시키는 어노테이션. JUnit4의 <code class="language-plaintext highlighter-rouge">@Ingore</code>와 같은 기능이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Disabled</span>
<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">ignoredTest</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"테스트 하지 않습니다!"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="timeout">@Timeout</h2>
<p>실행 시간 제한을 걸어두는 어노테이션. 시간이 초과되면 <code class="language-plaintext highlighter-rouge">TimeoutException</code>이 발생하며 테스트가 실패</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Timeout</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">mustRunIn1SecondTest</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
	<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1500</span><span class="o">);</span> <span class="c1">// 실패</span>
<span class="o">}</span>

<span class="nd">@Test</span>
<span class="nd">@Timeout</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="mi">500</span><span class="o">,</span> <span class="n">unit</span> <span class="o">=</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">)</span>
<span class="kt">void</span> <span class="nf">failsIfExecutionTimeExceeds500Milliseconds</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// fails if execution time exceeds 500 milliseconds</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br />
<br /></p>

<h1 id="-junit-assertions">📖 JUnit Assertions</h1>
<p><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations" target="_blank">Assertions 가이드 링크</a></p>

<h2 id="asserttrue--assertfalse">assertTrue &amp;&amp; assertFalse</h2>
<p>참 거짓 여부 판단. 2번째 인자가 존재하면 실패 시 2번째 인자를 메시지로 출력해준다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertTrue</span><span class="o">(</span><span class="sc">'a'</span> <span class="o">&lt;</span> <span class="sc">'b'</span><span class="o">);</span>
<span class="n">assertTrue</span><span class="o">(</span><span class="sc">'a'</span> <span class="o">&lt;</span> <span class="sc">'b'</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"message"</span><span class="o">);</span>

<span class="n">assertFalse</span><span class="o">(</span><span class="sc">'a'</span> <span class="o">&lt;</span> <span class="sc">'b'</span><span class="o">);</span>
<span class="n">assertFalse</span><span class="o">(</span><span class="sc">'a'</span> <span class="o">&lt;</span> <span class="sc">'b'</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="s">"message"</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="assertnull--assertnotnull">assertNull &amp;&amp; assertNotNull</h2>
<p>객체의 null 여부 판단</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertNull</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"my.prop"</span><span class="o">));</span>
<span class="n">assertNotNull</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"my.prop"</span><span class="o">));</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="assertequals--assertnotequals">assertEquals &amp;&amp; assertNotEquals</h2>
<p>두 값을 비교하여 일치 여부 판단. 3번째 인자가 존재하면 실패 시 3번째 인자를 메시지로 출력해준다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertEquals</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">calculator</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
<span class="n">assertEquals</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">calculator</span><span class="o">.</span><span class="na">multiply</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="s">"message"</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="assertarrayequals">assertArrayEquals</h2>
<p>두 배열을 비교하여 일치 여부 판단. 두 배열이 모두 null이어도 동일한 것으로 간주한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">[]</span> <span class="n">expected</span> <span class="o">=</span> <span class="o">{</span><span class="sc">'J'</span><span class="o">,</span><span class="sc">'u'</span><span class="o">,</span><span class="sc">'n'</span><span class="o">,</span><span class="sc">'i'</span><span class="o">,</span><span class="sc">'t'</span><span class="o">};</span>
<span class="kt">char</span><span class="o">[]</span> <span class="n">actual</span> <span class="o">=</span> <span class="s">"Junit"</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
<span class="n">assertArrayEquals</span><span class="o">(</span><span class="n">expected</span><span class="o">,</span> <span class="n">actual</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="assertall">assertAll</h2>
<p>여러 개의 <code class="language-plaintext highlighter-rouge">assertions</code>가 만족할 경우에만 테스를 통과하였다고 판단하고 싶을 경우에는 <code class="language-plaintext highlighter-rouge">assertAll()</code>을 사용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assertAll</span><span class="o">(</span>
      <span class="s">"heading"</span><span class="o">,</span>
      <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">assertEquals</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"4 is 2 times 2"</span><span class="o">),</span>
      <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">assertEquals</span><span class="o">(</span><span class="s">"java"</span><span class="o">,</span> <span class="s">"JAVA"</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">()),</span>
      <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">assertEquals</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="s">"null is equal to null"</span><span class="o">)</span>
    <span class="o">);</span>
<span class="o">}</span>

<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">dependentAssertions</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assertAll</span><span class="o">(</span><span class="s">"properties"</span><span class="o">,</span>
        <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">firstName</span> <span class="o">=</span> <span class="n">person</span><span class="o">.</span><span class="na">getFirstName</span><span class="o">();</span>
            <span class="n">assertNotNull</span><span class="o">(</span><span class="n">firstName</span><span class="o">);</span>
            <span class="n">assertAll</span><span class="o">(</span><span class="s">"first name"</span><span class="o">,</span>
                <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">assertTrue</span><span class="o">(</span><span class="n">firstName</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"J"</span><span class="o">)),</span>
                <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">assertTrue</span><span class="o">(</span><span class="n">firstName</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">"e"</span><span class="o">))</span>
            <span class="o">);</span>
        <span class="o">},</span>
        <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">lastName</span> <span class="o">=</span> <span class="n">person</span><span class="o">.</span><span class="na">getLastName</span><span class="o">();</span>
            <span class="n">assertNotNull</span><span class="o">(</span><span class="n">lastName</span><span class="o">);</span>
            <span class="n">assertAll</span><span class="o">(</span><span class="s">"last name"</span><span class="o">,</span>
                <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">assertTrue</span><span class="o">(</span><span class="n">lastName</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"D"</span><span class="o">)),</span>
                <span class="o">()</span> <span class="o">-&gt;</span> <span class="n">assertTrue</span><span class="o">(</span><span class="n">lastName</span><span class="o">.</span><span class="na">endsWith</span><span class="o">(</span><span class="s">"e"</span><span class="o">))</span>
            <span class="o">);</span>
        <span class="o">}</span>
    <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="assertsame--assertnotsame">assertSame &amp;&amp; assertNotSame</h2>
<p>예상되는 값과 실제 값이 동일한 객체를 참조하는지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">language</span> <span class="o">=</span> <span class="s">"Java"</span><span class="o">;</span>
<span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">optional</span> <span class="o">=</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">language</span><span class="o">);</span>

<span class="n">assertSame</span><span class="o">(</span><span class="n">language</span><span class="o">,</span> <span class="n">optional</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
<span class="n">assertNotSame</span><span class="o">(</span><span class="n">language</span><span class="o">,</span> <span class="n">optional</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="assertthrows">assertThrows</h2>
<p>특정 예외가 발생하였는지 확인. 첫 번째 인자는 확인할 예외 클래스, 두 번째 인자는 테스트하려는 코드</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">exceptionTesting</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Exception</span> <span class="n">exception</span> <span class="o">=</span> <span class="n">assertThrows</span><span class="o">(</span><span class="nc">ArithmeticException</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="o">()</span> <span class="o">-&gt;</span>
        <span class="n">calculator</span><span class="o">.</span><span class="na">divide</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="s">"/ by zero"</span><span class="o">,</span> <span class="n">exception</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="asserttimeout--asserttimeoutpreemptively">assertTimeout &amp; assertTimeoutPreemptively</h2>
<p>특정 시간 안에 실행이 끝나는지 확인</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">assertTimeout</code>: 시간 내 실행이 끝나는지 여부 확인 시</li>
  <li><code class="language-plaintext highlighter-rouge">assertTimeoutPreemptively</code>: 지정한 시간 내 끝나지 않으면 바로 종료</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">timeoutNotExceeded</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 시간안에 성공</span>
    <span class="n">assertTimeout</span><span class="o">(</span><span class="n">ofMinutes</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">// 2분 안에 끝나는 테스트 작성...</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">timeoutNotExceededWithResult</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 시간 안에 성공, 그리고 supplied object 리턴</span>
    <span class="nc">String</span> <span class="n">actualResult</span> <span class="o">=</span> <span class="n">assertTimeout</span><span class="o">(</span><span class="n">ofMinutes</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"a result"</span><span class="o">;</span>
    <span class="o">});</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="s">"a result"</span><span class="o">,</span> <span class="n">actualResult</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">timeoutExceeded</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 시간안에 테스트가 성공하지 못한다면 다음과 비슷한 오류 메시지 출력</span>
    <span class="c1">// execution exceeded timeout of 10 ms by 91 ms</span>
    <span class="n">assertTimeout</span><span class="o">(</span><span class="n">ofMillis</span><span class="o">(</span><span class="mi">10</span><span class="o">),</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
    <span class="o">});</span>
<span class="o">}</span>

<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">timeoutExceededWithPreemptiveTermination</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 시간안에 테스트가 성공하지 못한다면 다음과 비슷한 오류 메시지 출력</span>
    <span class="c1">// execution timed out after 10 ms</span>
    <span class="n">assertTimeoutPreemptively</span><span class="o">(</span><span class="n">ofMillis</span><span class="o">(</span><span class="mi">10</span><span class="o">),</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="c1">// 10ms 이상 소요되는 작업...</span>
        <span class="k">new</span> <span class="nf">CountDownLatch</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">await</span><span class="o">();</span>
    <span class="o">});</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br />
<br /></p>

<h1 id="-assertj-assertions">📖 AssertJ Assertions</h1>
<ul>
  <li><a href="https://assertj.github.io/doc/" target="_blank">AssertJ 가이드 링크</a></li>
  <li><a href="https://www.baeldung.com/introduction-to-assertj" target="_blank">Spring AssertJ 가이드 링크</a></li>
</ul>

<div class="notice--info">
<p><strong>참고</strong></p>

<p><code class="language-plaintext highlighter-rouge">AssertJ</code>에서 모든 테스트 코드는 <code class="language-plaintext highlighter-rouge">assertThat()</code>으로 시작한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">타겟</span><span class="o">).</span><span class="na">메소드1</span><span class="o">().</span><span class="na">메소드2</span><span class="o">();</span>
</code></pre></div></div>
</div>
<p><br /></p>

<h2 id="object-assertions">Object Assertions</h2>
<p>Objects는 두 객체의 동등성이나 객체의 필드를 검사하기 위해 다양한 방법으로 비교할 수 있습니다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="o">{</span> 
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span> 
    <span class="kd">private</span> <span class="nc">Float</span> <span class="n">weight</span><span class="o">;</span>
    
    <span class="c1">// Getters, Setters...</span>
<span class="o">}</span>

<span class="nc">Dog</span> <span class="n">fido</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"Fido"</span><span class="o">,</span> <span class="mf">5.25</span><span class="o">);</span>
<span class="nc">Dog</span> <span class="n">fidosClone</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Dog</span><span class="o">(</span><span class="s">"Fido"</span><span class="o">,</span> <span class="mf">5.25</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="isequalto">isEqualTo()</h3>
<p>참조 비교</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">fido</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="n">fidosClone</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="isequaltocomparingfieldbyfieldrecursively">isEqualToComparingFieldByFieldRecursively()</h3>
<p>내용 비교</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">fido</span><span class="o">).</span><span class="na">isEqualToComparingFieldByFieldRecursively</span><span class="o">(</span><span class="n">fidosClone</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="boolean-assertions">Boolean Assertions</h2>
<p>참, 거짓 확인</p>

<h3 id="istrue--isfalse">isTrue() &amp;&amp; isFalse()</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="s">""</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()).</span><span class="na">isTrue</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="iterablearray-assertions">Iterable/Array Assertions</h2>
<p><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractIterableAssert.html" target="_blank">Iterable/Array 가이드 링크</a><br />
<code class="language-plaintext highlighter-rouge">Iterable/Array</code>에 특정 요소가 존재하는지 다양한 방법으로 알 수 있다.</p>

<h3 id="contains">contains()</h3>
<p>요소 포함 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"2"</span><span class="o">,</span> <span class="s">"3"</span><span class="o">);</span>
<span class="n">assertThat</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="na">contains</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="doesnotcontain">doesNotContain()</h3>
<p>요소가 포함되지 않았는지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="na">doesNotContain</span><span class="o">(</span><span class="s">"4"</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="containsexactly">containsExactly()</h3>
<p>실제 그룹에 지정된 값이 순서대로 정확히 포함되어 있는지 확인한다. 일관된 반복 순서가 있는 그룹에만 사용해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Ring</span><span class="o">&gt;</span> <span class="n">elvesRings</span> <span class="o">=</span> <span class="n">newArrayList</span><span class="o">(</span><span class="n">vilya</span><span class="o">,</span> <span class="n">nenya</span><span class="o">,</span> <span class="n">narya</span><span class="o">);</span>

 <span class="c1">// 성공</span>
 <span class="n">assertThat</span><span class="o">(</span><span class="n">elvesRings</span><span class="o">).</span><span class="na">containsExactly</span><span class="o">(</span><span class="n">vilya</span><span class="o">,</span> <span class="n">nenya</span><span class="o">,</span> <span class="n">narya</span><span class="o">);</span>

 <span class="c1">// 실패</span>
 <span class="n">assertThat</span><span class="o">(</span><span class="n">elvesRings</span><span class="o">).</span><span class="na">containsExactly</span><span class="o">(</span><span class="n">nenya</span><span class="o">,</span> <span class="n">vilya</span><span class="o">,</span> <span class="n">narya</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="containsall">containsAll()</h3>
<p>실제 그룹에 지정된 <code class="language-plaintext highlighter-rouge">Iterable</code>의 모든 요소가 임의의 순서로 포함되어 있는지 확인한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">abc</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>

 <span class="c1">// 성공</span>
 <span class="n">assertThat</span><span class="o">(</span><span class="n">abc</span><span class="o">).</span><span class="na">containsAll</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">))</span>
                <span class="o">.</span><span class="na">containsAll</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">));</span>

 <span class="c1">// 실패</span>
 <span class="n">assertThat</span><span class="o">(</span><span class="n">abc</span><span class="o">).</span><span class="na">containsAll</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"d"</span><span class="o">));</span>
 <span class="n">assertThat</span><span class="o">(</span><span class="n">abc</span><span class="o">).</span><span class="na">containsAll</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">));</span>
</code></pre></div></div>

<h3 id="isnotempty">isNotEmpty()</h3>
<p>비어있지 않았는지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="na">isNotEmpty</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="startswith">startsWith()</h3>
<p>주어진 값으로 시작하는지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="character-assertions">Character Assertions</h2>
<p><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractCharacterAssert.html" target="_blank">Character 가이드 링크</a><br />
Character에 대한 비교</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">someCharacter</span><span class="o">)</span>
  <span class="o">.</span><span class="na">isNotEqualTo</span><span class="o">(</span><span class="sc">'a'</span><span class="o">)</span>             <span class="c1">// a 가 아니고</span>
  <span class="o">.</span><span class="na">inUnicode</span><span class="o">()</span>                   <span class="c1">// 유니코드 테이블에 있고</span>
  <span class="o">.</span><span class="na">isGreaterThanOrEqualTo</span><span class="o">(</span><span class="sc">'b'</span><span class="o">)</span>   <span class="c1">// b보다 크고</span>
  <span class="o">.</span><span class="na">isLowerCase</span><span class="o">();</span>                <span class="c1">// 소문자 인지 확인</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="class-assertions">Class Assertions</h2>
<p><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractClassAssert.html" target="_blank">Class 가이드 링크</a><br />
클래스에 관한 비교</p>

<h3 id="isinterface">isInterface()</h3>
<p>인터페이스인지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="nc">Runnable</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">isInterface</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="isassignablefrom">isAssignableFrom()</h3>
<p>할당 가능한지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="nc">Exception</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">isAssignableFrom</span><span class="o">(</span><span class="nc">NoSuchElementException</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="file-assertions">File Assertions</h2>
<p><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractFileAssert.html" target="_blank">File 가이드 링크</a><br />
파일에 관련된 비교</p>

<h3 id="exists">exists()</h3>
<p>존재 여부</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">someFile</span><span class="o">).</span><span class="na">exists</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="isfile">isFile()</h3>
<p>파일유형인지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">someFile</span><span class="o">).</span><span class="na">isFile</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="canread">canRead()</h3>
<p>읽을 수 있는지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">someFile</span><span class="o">).</span><span class="na">canRead</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="canwrite">canWrite()</h3>
<p>쓸 수 있는지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">someFile</span><span class="o">).</span><span class="na">canWrite</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="doublefloatintegerassertions">Double/Float/Integer Assertions</h2>
<p><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractDoubleAssert.html" target="_blank">Double/Float/Integer 가이드 링크</a><br />
숫자에 대한 비교</p>

<h3 id="isbetween">isBetween()</h3>
<p>값이 두 값 사이에 존재하는지 확인 (start, end 포함)</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="mi">3</span><span class="o">).</span><span class="na">isBetween</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="isstrictlybetween">isStrictlyBetween()</h3>
<p>값이 두 값 사이에 존재하는지 확인 (start, end 미포함)</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="mi">3</span><span class="o">).</span><span class="na">isStrictlyBetween</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="ispositive">isPositive()</h3>
<p>양수인지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="mi">3</span><span class="o">).</span><span class="na">isPositive</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="isnegative">isNegative()</h3>
<p>음수인지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(-</span><span class="mi">1</span><span class="o">).</span><span class="na">isNegative</span><span class="o">();</span>
</code></pre></div></div>

<h3 id="iszero">isZero()</h3>
<p>값이 0인지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">isZero</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="mapassertions">Map Assertions</h2>
<p><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractMapAssert.html" target="_blank">Map 가이드 링크</a><br />
맵에 특정 항목, entry, key/value 값이 포함되어 있는지 확인한다.</p>

<h3 id="containskey">containsKey()</h3>
<p>키가 존재하지는 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">map</span><span class="o">).</span><span class="na">containsKey</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="doesnotcontainkeys">doesNotContainKeys()</h3>
<p>키가 존재하지 않는지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">map</span><span class="o">).</span><span class="na">doesNotContainKeys</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="entry">entry()</h3>
<p>map의 키, 값을 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">map</span><span class="o">).</span><span class="na">contains</span><span class="o">(</span><span class="n">entry</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"a"</span><span class="o">));</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="throwable-assertions">Throwable Assertions</h2>
<p><a href="https://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractThrowableAssert.html" target="_blank">Throwable 가이드 링크</a><br />
예외 메시지, 스택 추적 검사, 예외 발생했는지 확인</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Throwable</span> <span class="n">thrown</span> <span class="o">=</span> <span class="n">catchThrowable</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="o">(</span><span class="s">"boom!"</span><span class="o">);</span>
<span class="o">});</span>

<span class="n">assertThat</span><span class="o">(</span><span class="n">thrown</span><span class="o">).</span><span class="na">isInstanceOf</span><span class="o">(</span><span class="nc">Exception</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">hasMessageContaining</span><span class="o">(</span><span class="s">"boom"</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="assertthatthrownby">assertThatThrownBy()</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThatThrownBy</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"boom!"</span><span class="o">);})</span>
<span class="o">.</span><span class="na">isInstanceOf</span><span class="o">(</span><span class="nc">Exception</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="o">.</span><span class="na">hasMessageContaining</span><span class="o">(</span><span class="s">"boom"</span><span class="o">);</span>
</code></pre></div></div>

<h3 id="assertthatexceptionoftype">assertThatExceptionOfType()</h3>
<p>특정 타입으로 검사</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThatExceptionOfType</span><span class="o">(</span><span class="nc">IOException</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="o">.</span><span class="na">isThrownBy</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IOException</span><span class="o">(</span><span class="s">"boom!"</span><span class="o">);</span> <span class="o">})</span>
<span class="o">.</span><span class="na">withMessage</span><span class="o">(</span><span class="s">"%s!"</span><span class="o">,</span> <span class="s">"boom"</span><span class="o">)</span>
<span class="o">.</span><span class="na">withMessageContaining</span><span class="o">(</span><span class="s">"boom"</span><span class="o">)</span>
<span class="o">.</span><span class="na">withNoCause</span><span class="o">();</span>
</code></pre></div></div>
<p>그 밖에 특정 타입을 검사하는 <code class="language-plaintext highlighter-rouge">exceptions</code>를 이용할 수 있다.</p>
<ul>
  <li>assertThatNullPointerException</li>
  <li>assertThatIllegalArgumentException</li>
  <li>assertThatIllegalStateException</li>
  <li>assertThatIOException<br />
<br /></li>
</ul>

<h2 id="describing-assertions">Describing Assertions</h2>

<h3 id="as">as()</h3>
<p>테스트의 설명 작성</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">assertThat</span><span class="o">(</span><span class="n">person</span><span class="o">.</span><span class="na">getAge</span><span class="o">())</span>
    <span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">"%s's age should be equal to 100"</span><span class="o">,</span> <span class="n">person</span><span class="o">.</span><span class="na">getName</span><span class="o">())</span>
    <span class="o">.</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>

<span class="c1">// 출력</span>
<span class="c1">// [Alex's age should be equal to 100] expected:&lt;100&gt; but was:&lt;34&gt;</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="junit-assumptions">JUnit Assumptions</h2>
<p>특정 환경일 때만 테스트를 진행하도록 하고 싶을 때 사용</p>

<h3 id="assumetrue--assumefalse">assumeTrue() &amp;&amp; assumeFalse()</h3>
<p>테스트가 성공, 실패일 때 계속 진행</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">trueAssumption</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assumeTrue</span><span class="o">(</span><span class="s">"PRD"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"ENV"</span><span class="o">)));</span>
    <span class="c1">// 계속 진행...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">falseAssumption</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assumeFalse</span><span class="o">(</span><span class="mi">5</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">);</span>
    <span class="c1">// 계속 진행...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="assumingthat">assumingThat()</h3>
<p>첫번째 인자 성공시, 두번째 인자 실행</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">assumptionThat</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assumingThat</span><span class="o">(</span><span class="s">"CI"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getenv</span><span class="o">(</span><span class="s">"ENV"</span><span class="o">)),</span>
        <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="c1">// CI서버에서만 이 테스트를 실행한다.</span>
            <span class="n">assertEquals</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">calculator</span><span class="o">.</span><span class="na">divide</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">));</span>
        <span class="o">});</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br />
<br /></p>

<h1 id="-junit-import-static">📖 JUnit import static</h1>
<p>기본 import static 해놓으면 좋은 것들을 정리</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">hamcrest</span><span class="o">.</span><span class="na">Matchers</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">junit</span><span class="o">.</span><span class="na">jupiter</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">assertj</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>
</code></pre></div></div>
<p><br />
<br /></p>]]></content><author><name>Oh</name></author><category term="Java" /><category term="Java" /><category term="JUnit 5" /><category term="AssertJ" /><category term="Test" /><category term="CheatSheet" /><summary type="html"><![CDATA[JUnit 5, AssertJ의 사용법을 간단하게 정리하였습니다. 😁 jUnit 5 가이드 링크 AssertJ 가이드 링크]]></summary></entry><entry><title type="html">TDD(Test Driven Development) - 테스트 주도 개발</title><link href="http://localhost:4000/insight/TDD(Test-Driven-Development)-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C/" rel="alternate" type="text/html" title="TDD(Test Driven Development) - 테스트 주도 개발" /><published>2023-02-07T00:00:00+09:00</published><updated>2023-02-07T00:00:00+09:00</updated><id>http://localhost:4000/insight/TDD(Test%20Driven%20Development)-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C</id><content type="html" xml:base="http://localhost:4000/insight/TDD(Test-Driven-Development)-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C/"><![CDATA[<p><br /></p>

<h1 id="-tddtest-driven-development란">🤔 TDD(Test Driven Development)란?</h1>
<ul>
  <li>TDD란 Test Driven Development의 약자로 테스트 주도 개발이라 합니다.</li>
  <li>TDD는 소프트웨어 개발 방법론 중의 하나로 <strong>자동화된 테스트 코드를 작성한 후, 테스트를 통과하기 위한 코드를 개선하는 방식의 개발 방식</strong>을 말합니다. <br />
<br />
<br /></li>
</ul>

<h1 id="️️-tdd-개발-방법">⛹️‍♀️ TDD 개발 방법</h1>
<p><img src="/assets/images/posts/insight/tdd/9d2d7f30-25c2-4ef7-ae08-e67eb8cf2bb5.png" alt="TDD lifecycle" /></p>

<ol>
  <li>테스트 작성, 기능이 아직 구현되지 않았기 때문에 테스트가 실패한다.</li>
  <li>테스트를 성공하도록 프로덕션 코드 작성</li>
  <li>프로덕션 코드와 테스트 코드를 리팩토링</li>
</ol>

<p>위 3단계를 반복하며, 더 간단하고 개선된 디자인 패턴과 높은 품질의 코드를 작성하게 됩니다.
<br />
<br /></p>

<h1 id="-tdd-원칙">🎯 TDD 원칙</h1>
<ol>
  <li>실패하는 단위 테스트를 작성할 때까지 프로덕션 코드(production code)를 작성하지 않는다.</li>
  <li>컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.</li>
  <li>현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
<br />
<br /></li>
</ol>

<h1 id="-tdd의-효과">🎯 TDD의 효과</h1>

<ol>
  <li>
    <p><strong>빠르게 피드백 받을 수 있다.</strong><br />
TDD를 통해 시스템 구현(<em>“시스템이 동작하는가?”</em>)과 설계의 품질(<em>“시스템이 잘 구조화 되있는가?”</em>)에 관한 피드백을 받을 수 있습니다.</p>
  </li>
  <li>
    <p><strong>디버깅 시간을 단축 할 수 있다.</strong><br />
TDD의 경우 자동화 된 유닛테스팅을 전재하므로 특정 버그를 손 쉽게 찾아낼 수 있습니다.</p>
  </li>
  <li>
    <p><strong>객체 지향적인 코드가 된다.</strong><br />
TDD를 사용하면 자연스럽게 단순한 단위로 작업을 진행하게 됩니다. 그러다 보면 기능별로 모듈화가 이루어집니다. 즉 강렬한 디자인 사고 때문이 아니라 상호 연결된 많은 작은 모듈의 상호 작용으로 복잡한 기능을 처리하기 때문에 더 나은 코드를 갖게 됩니다.</p>
  </li>
  <li>
    <p><strong>프로그래머의 오버 엔지니어링을 방지한다.</strong><br />
프로그래머들은 간혹 계획하지 않았던 코드를 추가하여 오버 엔지니어링하는 경우가 있습니다. 하지만 TDD의 원칙 중 하나는, 테스트를 통과하기 위한 최소한의 코드만 작성 및 개선해야 한다는 것입니다. 기능 단위로 테스트를 진행하기 때문에, 문제가 발견되지 않은 코드에 영향을 줄 수 있는 오버 코딩은 하지 않습니다.</p>
  </li>
  <li>
    <p><strong>문서의 역할을 한다.</strong><br />
TDD를 사용하면, 테스트 코드를 작성하는 과정에서 히스토리가 남습니다. TDD를 통해 작성한 테스트 코드를 트래킹하면서 과거에 어떤 인과관계로 의사결정을 했는지 확인하기 쉽습니다.</p>
  </li>
  <li>
    <p><strong>유지보수(리팩토링)이 용이하다.</strong><br />
TDD의 경우 단위 테스트 기반의 테스트 코드를 작성하기 때문에 추후 문제가 발생하였을 때 각각의 모듈별로 테스트를 진행해보면 문제의 지점을 쉽게 찾을 수 있습니다.</p>
  </li>
  <li>
    <p><strong>변화, 추가 구현이 용이하다.</strong><br />
개발이 완료된 소프트웨어에 어떤 기능을 추가할 때 가장 우려되는 점은 해당 기능이 기존 코드에 어떤 영향을 미칠지 알지 못한다는 것입니다. 하지만 TDD의 경우 자동화된 유닛 테스팅을 전제하므로 테스트 기간을 획기적으로 단축시킬 수 있습니다.<br />
<br />
<br /></p>
  </li>
</ol>

<h1 id="-tdd의-한계">😓 TDD의 한계</h1>
<p>이론적으로, 그리고 실제로 많은 경우에 TDD는 소프트웨어 개발에 많은 장점이 있습니다. 그러나 아래와 같은 한계도 존재합니다.</p>

<ol>
  <li>
    <p><strong>레거시 코드</strong><br />
코드가 이미 작성되었기 때문에 레거시 코드에 적용되지 않습니다.</p>
  </li>
  <li>
    <p><strong>생산성의 저하</strong><br />
장기적으로 보면 생산성이 증가합니다. 하지만 이는 <strong>“급하지 않은 환경”</strong>에서의 경우입니다. 납기일 준수가 중요한 SI프로젝트 같은 경우 이러한 조건과 모순됩니다.</p>
  </li>
  <li>
    <p><strong>불완전한 테스트 사례</strong><br />
프로그래머가 테스트 시나리오를 누락한다면, TDD는 사용자를 보호하지 않습니다.<br />
<br />
<br /></p>
  </li>
</ol>

<h1 id="-tdd-필요한가">🤔 TDD 필요한가?</h1>
<p>점점 더 많은 개발자들이 TDD로 전환하고 있습니다. 하지만 일부는 TDD가 실제 코딩 대신 테스트를 작성하는 데 시간을 더 소비한다고 주장합니다.</p>

<p>빠르게 코딩하고 빠르게 제품을 만들어야 하는 스타트업 개발자와 같이 시간이 제한된 개발자에게는 이러한 시간 소비가 치명적일 수 있습니다. 또한 관리자와 고객의 TDD의 장점에 대한 이해 부족과 개발자 교육의 투자 비용은 TDD를 사용하지 않게 합니다.</p>

<p>하지만 리소스를 보유하고 있으며 코드 품질이 가장 중요한 기업은 TDD로 전환을 하는 것이 좋습니다.
<br />
<br /></p>]]></content><author><name>Oh</name></author><category term="Insight" /><category term="Insight" /><category term="Test" /><category term="TDD" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">📖 자바 ORM 표준 JPA 프로그래밍</title><link href="http://localhost:4000/books/%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/" rel="alternate" type="text/html" title="📖 자바 ORM 표준 JPA 프로그래밍" /><published>2023-01-16T00:00:00+09:00</published><updated>2023-01-16T00:00:00+09:00</updated><id>http://localhost:4000/books/%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D</id><content type="html" xml:base="http://localhost:4000/books/%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"><![CDATA[<p><a href="https://product.kyobobook.co.kr/detail/S000000935744" target="_blank">자바 ORM 표준 JPA 프로그래밍</a> 책을 읽고 내용을 아주 간단하게 정리한 글입니다. 책에는 자세한 설명과 예제가 많으니 <strong>꼭 구입해서 읽는것을 추천</strong>합니다~👍</p>

<hr />

<h1 id="1-jpa-소개">1. JPA 소개</h1>
<h2 id="11-sql을-직접-다룰-때-발생하는-문제점">1.1 SQL을 직접 다룰 때 발생하는 문제점</h2>
<ul>
  <li>자바로 개발하는 애플리케이션은 대부분 관계형 데이터베이스를 데이터 저장소로 사용한다.</li>
  <li>JDBC API를 사용해 SQL을 전달한다.</li>
</ul>

<h3 id="111-반복-반복-그리고-반복">1.1.1 반복, 반복 그리고 반복</h3>
<p>객체를 데이터베이스에 CURD 하려면 너무많은 SQL과 JDBC API를 코드로 작성해야 한다. 테이블이 여러개라면 무수히 많은 SQL을 작성해야 한다.</p>

<h3 id="112-sql에-의존적인-개발">1.1.2 SQL에 의존적인 개발</h3>
<p>애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점</p>
<ul>
  <li>진정한 의미의 계층 분할이 어렵다.</li>
  <li>엔티티를 신뢰할 수 없다.</li>
  <li>SQL에 의존적인 개발을 피하기 어렵다.</li>
</ul>

<h3 id="113-jpa와-문제-해결">1.1.3 JPA와 문제 해결</h3>
<p>JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 SQL을 작성하는 것이 아니라 JPA가 제공하는 API를 사용하면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 저장</span>
<span class="n">jpa</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

<span class="c1">// 조회</span>
<span class="nc">String</span> <span class="n">memberId</span> <span class="o">=</span> <span class="s">"helloId"</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">jpa</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">memberId</span><span class="o">);</span>

<span class="c1">// 수정</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">jpa</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">memberId</span><span class="o">);</span>
<span class="n">member</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"이름변경"</span><span class="o">);</span> <span class="c1">// jpa는 update 메소드가 따로 없다.</span>

<span class="c1">// 연관된 객체 조회</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">jpa</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">memberId</span><span class="o">);</span>
<span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">();</span>
</code></pre></div></div>

<h2 id="12-패러다임-불일치">1.2 패러다임 불일치</h2>
<ul>
  <li>객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르다.</li>
  <li>기능과 표현 방법도 다르다.</li>
  <li>객체 구조를 테이블 구조에 저장하는 데는 한계가 있다.</li>
</ul>

<h3 id="121-상속">1.2.1 상속</h3>
<p>객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다.(일부 데이터베이스는 상속 기능을 지원하지만 객체의 상속과는 약간 다르다.)</p>

<center><img src="/assets/images/posts/books/2/1_2_객체상속모델.png" alt="객체상속모델" width="90%" height="90%" /></center>

<p><br /></p>

<p>데이터베이스 모델링에서는 슈퍼타입 서브타입 관계를 사용하면 유사하게 만들 수 있다.</p>

<center><img src="/assets/images/posts/books/2/1_2_테이블모델.png" alt="테이블모델" width="90%" height="90%" /></center>

<p><br /></p>

<p>위의 구조를 JDBC API를 사용해서 구현하려면 작성해야 할 코드량이 만만치 않다.</p>
<ul>
  <li>INSERT INTO ITEM…</li>
  <li>INSERT INTO ALBUM…</li>
</ul>

<p><br /></p>

<p><strong>JPA와 상속</strong><br />
JPA는 상속과 관련된 패러다임 불일치 문제를 개발자 대신 해결해 준다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 저장</span>
<span class="n">jpa</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">album</span><span class="o">);</span>

<span class="c1">// JPA에서 실행 해주는 SQL</span>
<span class="no">INSERT</span> <span class="no">INTO</span> <span class="no">ITEM</span><span class="o">...</span>
<span class="no">INSERT</span> <span class="no">INTO</span> <span class="no">ALBUM</span><span class="o">...</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="122-연관관계">1.2.2 연관관계</h3>
<ul>
  <li><strong>객체는 참조를 사용해 다른 객체와 연관관계</strong>를 가진다. 참조에 접근해서 연관된 객체를 조회한다.</li>
  <li><strong>테이블은 외래 키를 사용해 다른 테이블과 연관관계</strong>를 가진다. 조인을 사용해서 연관된 테이블을 조회한다.</li>
  <li><strong>객체는 참조가 있는 방향으로만 조회할 수 있다.</strong></li>
</ul>
<center><img src="/assets/images/posts/books/2/1_2_연관관계.png" alt="연관관계" width="90%" height="90%" /></center>

<p><br /></p>

<p><strong>객체를 테이블에 맞추어 모델링</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 관계형 데이터베이스가 사용하는 방식에 맞추면 객체 참조를 통해 조회할 수 없다.</span>
<span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>   <span class="c1">// MEMBER_ID 컬럼 사용</span>
    <span class="nc">Long</span> <span class="n">teamId</span><span class="o">;</span> <span class="c1">// TEAM_ID FK 컬럼 사용</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>객체지향 모델링</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 패러다임 불일치를 해결하려고 소모하는 코드가 많다.</span>
<span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>   <span class="c1">// MEMBER_ID 컬럼 사용</span>
    <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span> <span class="c1">// 참조로 연관관계를 맺는다.</span>
<span class="o">}</span>

<span class="c1">// 데이터베이스에 저장</span>
<span class="n">member</span><span class="o">.</span><span class="na">getId</span><span class="o">();</span>
<span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">.</span><span class="na">getId</span><span class="o">();</span> <span class="c1">// TEAM_ID FK를 직접 구해야 함</span>
<span class="o">...</span><span class="na">생략</span><span class="o">...</span>

<span class="c1">// 조회</span>
<span class="no">SQL</span> <span class="n">실행</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span> <span class="o">();</span>
<span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">();</span>
<span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="n">member</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team</span><span class="o">);</span> <span class="c1">// 직접 회원과 팀 관계 설정</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>JPA와 연관관계</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JPA는 연관관계와 관련된 패러다임 불일치 문제를 해결해준다.</span>

<span class="c1">// 저장</span>
<span class="n">member</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team</span><span class="o">);</span>
<span class="n">jpa</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span> <span class="c1">// TEAM_ID FK를 직접 지정할 필요 없음</span>

<span class="c1">// 조회</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">jpa</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">memberId</span><span class="o">);</span>
<span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">();</span> <span class="c1">// 바로 사용 가능</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="123-객체-그래프-탐색">1.2.3 객체 그래프 탐색</h3>
<p>객체에서 회원에 소속된 팀을 조회할 때는 다음처럼 참조를 사용해서 연관된 팀을 찾으면 되는데, 이것을 객체 그래프 탐색이라 한다.</p>

<center><img src="/assets/images/posts/books/2/1_2_객체그래프탐색.png" alt="객체그래프탐색" width="90%" height="90%" /></center>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 객체 그래프 탐색</span>
<span class="n">member</span><span class="o">.</span><span class="na">getOrder</span><span class="o">().</span><span class="na">getOrderItem</span><span class="o">()...</span>

<span class="c1">// 문제 발생</span>
<span class="n">member</span><span class="o">.</span><span class="na">getOrder</span><span class="o">();</span> <span class="c1">// 만약 null이라면?</span>
</code></pre></div></div>

<p><strong>SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.</strong> 이는 객체 그래프가 언제 끊어질지 모르기 때문에 함부로 탐색할 수 없다.</p>

<p><strong>JPA와 객체 그래프 탐색</strong><br />
JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다(<strong>지연로딩</strong>). 따라서 JPA를 사용하면 연관된 객체를 신뢰하고 조회할 수 있다.</p>

<h3 id="124-비교">1.2.4 비교</h3>
<ul>
  <li>데이터베이스는 기본 키의 값으로 각 row를 구분</li>
  <li>객체는 동일성, 동등성 비교.
    <ul>
      <li>동일성은 == 비교. 객체 인스턴스의 주소 값을 비교한다.</li>
      <li>동등성은 equals() 비교. 객체 내부의 값을 비교한다.</li>
    </ul>
  </li>
</ul>

<p><strong>JDBC API 비교</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">memberId</span> <span class="o">=</span> <span class="s">"100"</span><span class="o">;</span>
<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="n">memberDAO</span><span class="o">.</span><span class="na">getMember</span><span class="o">(</span><span class="n">memberID</span><span class="o">);</span>
<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="n">memberDAO</span><span class="o">.</span><span class="na">getMember</span><span class="o">(</span><span class="n">memberID</span><span class="o">);</span>

<span class="c1">// false</span>
<span class="n">member1</span> <span class="o">==</span> <span class="n">member2</span><span class="o">;</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>JPA 비교</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">memberId</span> <span class="o">=</span> <span class="s">"100"</span><span class="o">;</span>
<span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="n">jpa</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">memberID</span><span class="o">);</span>
<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="n">jpa</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="n">memberID</span><span class="o">);</span>

<span class="c1">// true</span>
<span class="n">member1</span> <span class="o">==</span> <span class="n">member2</span><span class="o">;</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="125-정리">1.2.5 정리</h3>
<ul>
  <li><strong>객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다르다.</strong></li>
  <li>이 패러다임 차이를 극복하려고 개발자가 너무 많은 시간과 코드를 소비한다.</li>
  <li>결국, 객체 모델링은 힘을 잃고 점점 데이터 중심의 모델로 변해간다.</li>
  <li><strong>JPA는 패러다임 불일치 문제를 해결하고, 정교한 객체 모델링을 유지하게 도와준다.</strong></li>
</ul>

<p><br />
<br /></p>

<h2 id="13-jpa란-무엇인가">1.3 JPA란 무엇인가?</h2>
<p><strong>JPA란?</strong></p>
<ul>
  <li>JPA(java persistence API)는 자바진영 ORM 기술 표준이다. 애플리케이션과 JDBC 사이에서 동작한다.</li>
</ul>
<center><img src="/assets/images/posts/books/2/1_3_JPA.png" alt="JPA" width="90%" height="90%" /></center>
<p><br />
<br /></p>

<p><strong>ORM이란?</strong></p>
<ul>
  <li>ORM(Object-Relational Mapping)은 <strong>객체와 관계형 데이터베이스를 매핑한다는 뜻</strong>이다.</li>
  <li>다양한 ORM 프레임워크들이 있는데 자바 진영에서는 <strong>하이버네이트 프레임워크가 가장 많이 사용</strong>된다.</li>
</ul>

<center><img src="/assets/images/posts/books/2/1_3_JPA조회.png" alt="JPA조회" width="80%" height="80%" /></center>
<p><br />
<br />
<br /></p>

<h3 id="131-jpa-소개">1.3.1 JPA 소개</h3>
<center><img src="/assets/images/posts/books/2/1_3_JPA표준인터페이스와구현체.png" alt="JPA표준인터페이스와구현체" width="80%" height="80%" /></center>
<p><br /></p>

<ul>
  <li><strong>JPA는 자바 ORM 기술에 대한 API 표준 명세다.</strong></li>
  <li>쉽게 이야기해서 인터페이스를 모아둔 것이다.</li>
  <li>따라서 JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 한다.</li>
  <li>ORM 프레임워크 중 <strong>하이버네이트가 가장 대중적</strong>이다.<br />
<br />
<br /></li>
</ul>

<h3 id="132-왜-jpa를-사용해야-하는가">1.3.2 왜 JPA를 사용해야 하는가?</h3>
<ul>
  <li>생산성</li>
  <li>유지보수</li>
  <li>패러다임 불일치 해결</li>
  <li>성능 (캐시)</li>
  <li>데이터 접근 추상화와 벤더 독립성
    <ul>
      <li>데이터베이스마다 사용법이 다르다 (예: 페이징 쿼리)</li>
      <li>JPA에게 데이터베이스만 알려주면 자동으로 해결된다</li>
    </ul>
  </li>
  <li>표준
    <ul>
      <li>자바 진영 ORM 기술 표준</li>
      <li>표준을 사용하면 다른 구현 기술로 손쉽게 변경 가능</li>
    </ul>
  </li>
</ul>

<center><img src="/assets/images/posts/books/2/1_3_벤더독립성.png" alt="벤더독립성" width="80%" height="80%" /></center>
<p><br />
<br /></p>

<h2 id="14-정리">1.4 정리</h2>
<ul>
  <li>SQL을 직접 다룰 때 발생하는 다양한 문제</li>
  <li>객체지향 언어와 관계형 데이터베이스 사이의 패러다임 불일치 문제</li>
  <li>JPA가 각 문제를 어떻게 해결하는지</li>
  <li>JPA가 무엇인지</li>
  <li>JPA 장점<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="2-jpa-시작">2. JPA 시작</h1>
<h2 id="21-이클립스-설치와-프로젝트-불러오기">2.1 이클립스 설치와 프로젝트 불러오기</h2>
<h2 id="22-h2-데이터베이스-설치">2.2 H2 데이터베이스 설치</h2>
<h2 id="23-라이브러리와-프로젝트-구조">2.3 라이브러리와 프로젝트 구조</h2>
<h2 id="24-객체-매핑-시작">2.4 객체 매핑 시작</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 객체 매핑 예</span>
<span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"MEMBER"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"NAME"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Integer</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th><strong>어노테이션</strong></th>
      <th><strong>설명</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>@Entity</td>
      <td>이 클래스를 테이블과 매핑한다고 JPA에게 알려준다. @Entity가 사용된 클래스를 엔티티 클래스라 한다.</td>
    </tr>
    <tr>
      <td>@Table</td>
      <td>엔티티 클래스에 매핑할 테이블 정보를 알려준다. 이 어노테이션을 생략하면 클래스 이름을 테이블 이름으로 매핑한다. (정확히는 엔티티 이름을 사용함)</td>
    </tr>
    <tr>
      <td>@Id</td>
      <td>엔티티 클래스의 필드를 테이블 기본키(primary key)에 매핑한다. @Id가 사용된 필드를 식별자 필드라 한다.</td>
    </tr>
    <tr>
      <td>@Column</td>
      <td>필드를 컬럼에 매핑한다.</td>
    </tr>
    <tr>
      <td>매핑 정보가 없는 필드</td>
      <td>필드명을 사용해서 컬럼명으로 매핑한다. 대소문자를 구분하는 데이터베이스를 사용하면 @Column(name=”AGE”)처럼 명시적으로 매핑해야 한다.</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h2 id="25-객체-매핑-시작">2.5 객체 매핑 시작</h2>
<h3 id="251-데이터베이스-방언">2.5.1 데이터베이스 방언</h3>
<p>데이터베이스마다 SQL 문법과 함수가 조금씩 다르다는 문제점이 있다.</p>
<ul>
  <li>데이터 타입: 가변 문자 타입으로 MySQL은 VARCHAR, 오라클은 VARCHAR2 사용</li>
  <li>다른 함수명: 문자열을 자르는 함수로 SQL 표준은 SUBSTRING(), 오라클은 SUBSTR()</li>
  <li>페이징 처리: MySQL은 LIMIT, 오라클은 ROWNUM</li>
</ul>

<p><strong>데이터베이스만의 고유한 기능을 JPA에서는 방언(Dialect)이라 한다.</strong> 하이버네이트를 포함한 대부분의 JPA 구현체들은 위와 같은 문제점을 해결하려고 다양한 데이터베이스 방언 클래스를 제공한다. <strong>방언만 교체하면 데이터베이스에 맞는 SQL이 알아서 실행된다.</strong></p>

<center><img src="/assets/images/posts/books/2/2_5_방언.png" alt="방언" width="80%" height="80%" /></center>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 필수 속성 --&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"javax.persistence.jdbc.driver"</span> <span class="na">value=</span><span class="s">"org.h2.Driver"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"javax.persistence.jdbc.user"</span> <span class="na">value=</span><span class="s">"sa"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"javax.persistence.jdbc.password"</span> <span class="na">value=</span><span class="s">""</span><span class="nt">/&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"javax.persistence.jdbc.url"</span> <span class="na">value=</span><span class="s">"jdbc:h2:tcp://localhost/~/test"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.dialect"</span> <span class="na">value=</span><span class="s">"org.hibernate.dialect.H2Dialect"</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 방언 설정 --&gt;</span>

<span class="c">&lt;!-- 옵션 --&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.show_sql"</span> <span class="na">value=</span><span class="s">"true"</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 하이버네이트가 실행한 SQL을 출력한다 --&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.format_sql"</span> <span class="na">value=</span><span class="s">"true"</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 하이버네이트가 실행한 SQL을 보기 쉽게 정렬한다 --&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.use_sql_comments"</span> <span class="na">value=</span><span class="s">"true"</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- 쿼리를 출력할 때 주석도 함께 출력한다 --&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.id.new_generator_mappings"</span> <span class="na">value=</span><span class="s">"true"</span> <span class="nt">/&gt;</span> <span class="c">&lt;!-- JPA 표준에 맞춘 새로운 키 생성 전략을 사용한다. --&gt;</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="26-애플리케이션-개발">2.6 애플리케이션 개발</h2>
<p>시작코드를 살펴보자</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JpaMain</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">//엔티티 매니저 팩토리 생성</span>
        <span class="nc">EntityManagerFactory</span> <span class="n">emf</span> <span class="o">=</span> <span class="nc">Persistence</span><span class="o">.</span><span class="na">createEntityManagerFactory</span><span class="o">(</span><span class="s">"jpabook"</span><span class="o">);</span>
        <span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span> <span class="c1">//엔티티 매니저 생성</span>

        <span class="nc">EntityTransaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span> <span class="c1">//트랜잭션 기능 획득</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span> <span class="c1">//트랜잭션 시작</span>
            <span class="n">logic</span><span class="o">(</span><span class="n">em</span><span class="o">);</span>  <span class="c1">//비즈니스 로직</span>
            <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span><span class="c1">//트랜잭션 커밋</span>

        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="n">tx</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span> <span class="c1">//트랜잭션 롤백</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">//엔티티 매니저 종료</span>
        <span class="o">}</span>

        <span class="n">emf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">//엔티티 매니저 팩토리 종료</span>
    <span class="o">}</span>

    <span class="c1">// 비즈니스 로직</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">logic</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{...}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>코드는 크게 3부분으로 나뉘어 있다</p>
<ul>
  <li>엔티티 매니저 생성</li>
  <li>트랜잭션 관리</li>
  <li>비즈니스 로직<br />
<br />
<br /></li>
</ul>

<h3 id="261-엔티티-매니저-설정">2.6.1 엔티티 매니저 설정</h3>
<p><strong>엔티티 매니저 팩토리 생성</strong><br />
JPA를 시작하려면 우선 엔티티 매니저 팩토리를 생성해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityManagerFactory</span> <span class="n">emf</span> <span class="o">=</span> <span class="nc">Persistence</span><span class="o">.</span><span class="na">createEntityManagerFactory</span><span class="o">(</span><span class="s">"jpabook"</span><span class="o">);</span>
</code></pre></div></div>
<p><strong>엔티티 매니저 팩토리</strong>는 JPA를 동작시키기 위한 기반 객체를 만들고 데이터베이스 커넥션 풀도 생성하므로 <strong>생성 비용은 아주 크다.</strong> 따라서 <strong>엔티티 매니저 팩토리는 애플리케이션 전체에 딱 한 번만 생성하고 공유해서 사용해야 한다.</strong><br />
<br /></p>

<p><strong>엔티티 매니저 생성</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
</code></pre></div></div>
<p>JPA의 기능 대부분은 엔티티 매니저가 제공한다. 대표적으로 엔티티를 데이터베이스에 등록,수정,삭제,조회할 수 있다. <strong>엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안된다.</strong><br />
<br /></p>

<p><strong>종료</strong><br />
사용이 끝난 엔티티 매니저, 엔티티 매니저 팩토리는 반드시 종료해야한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 엔티티 매니저 종료</span>
<span class="n">emf</span><span class="o">.</span><span class="na">close</span><span class="o">()</span> <span class="c1">// 엔티티 매니저 팩토리 종료</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h3 id="262-트랜잭션-관리">2.6.2 트랜잭션 관리</h3>
<p><strong>JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다.</strong> 트랜잭션 없이 데이터를 변경하면 예외가 발생한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityTransaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span> <span class="c1">//트랜잭션 기능 획득</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span> <span class="c1">//트랜잭션 시작</span>
    <span class="n">logic</span><span class="o">(</span><span class="n">em</span><span class="o">);</span>  <span class="c1">//비즈니스 로직</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span><span class="c1">//트랜잭션 커밋</span>

<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="n">tx</span><span class="o">.</span><span class="na">rollback</span><span class="o">();</span> <span class="c1">//트랜잭션 롤백</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">//엔티티 매니저 종료</span>
<span class="o">}</span>

<span class="n">emf</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">//엔티티 매니저 팩토리 종료</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h3 id="263-비즈니스-로직">2.6.3 비즈니스 로직</h3>
<p>JPA를 이용한 등록, 수정, 조회, 삭제 예는 아래와 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">logic</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">String</span> <span class="n">id</span> <span class="o">=</span> <span class="s">"id1"</span><span class="o">;</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"지한"</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

        <span class="c1">//등록</span>
        <span class="c1">// INSERT INTO MEMBER ...</span>
        <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

        <span class="c1">//수정</span>
        <span class="c1">// JPA는 엔티티 변경 추적 기능이 있어 엔티티의 값만 변경하면 수정됨</span>
        <span class="c1">// UPDATE MEMBER SET AGE=20, NAME='지한' WHERE ID = 'id1';</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>

        <span class="c1">//한 건 조회</span>
        <span class="c1">// SELECT * FROM MEMBER WHERE ID = 'id1';</span>
        <span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"findMember="</span> <span class="o">+</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getUsername</span><span class="o">()</span> <span class="o">+</span> <span class="s">", age="</span> <span class="o">+</span> <span class="n">findMember</span><span class="o">.</span><span class="na">getAge</span><span class="o">());</span>

        <span class="c1">//목록 조회</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select m from Member m"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"members.size="</span> <span class="o">+</span> <span class="n">members</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>

        <span class="c1">//삭제</span>
        <span class="c1">// DELETE FROM MEMBER WHERE ID = 'id1';</span>
        <span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h3 id="264-jpql">2.6.4 JPQL</h3>
<p>JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어를 제공한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//목록 조회</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select m from Member m"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"members.size="</span> <span class="o">+</span> <span class="n">members</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</code></pre></div></div>

<p><strong>JPQL과 SQL의 가장 큰 차이점</strong></p>
<ul>
  <li><strong>JPQL은 엔티티 객체를 대상으로 쿼리</strong>한다.</li>
  <li>SQL은 데이터베이스 테이블을 대상으로 쿼리한다.</li>
</ul>

<div class="notice--warning">
<p><strong>JPQL은 데이터베이스 테이블을 전혀 알지 못한다.</strong></p>
</div>
<p><br />
<br /></p>

<h2 id="27-정리">2.7 정리</h2>
<ul>
  <li>JPA를 사용하기 위한 개발 환경 설정</li>
  <li>JPA를 사용</li>
  <li>JPQL 설명<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="3-영속성-관리">3. 영속성 관리</h1>
<h2 id="31-엔티티-매니저-팩토리와-엔티티-매니저">3.1 엔티티 매니저 팩토리와 엔티티 매니저</h2>
<ul>
  <li>엔티티 매니저 팩토리를 만드는 비용은 상당히 크다.</li>
  <li>따라서 애플리케이션 전체에서 공유하도록 설계되어 있다. (그래서 일반적으로 하나만 생성 한다)</li>
  <li><strong>엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전</strong>하다.</li>
  <li><strong>엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생</strong>한다.</li>
</ul>
<center><img src="/assets/images/posts/books/2/3_1_일반적인웹애플리케이션.png" alt="일반적인웹애플리케이션" width="80%" height="80%" /></center>

<p><br />
<br /></p>

<h2 id="32-영속성-컨텍스트란">3.2 영속성 컨텍스트란?</h2>
<p>영속성 컨텍스트(persistence context)란 해석하자면 <strong>엔티티를 영구 저장하는 환경</strong>이란 뜻이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이 메소드는 정확히 표현하자면 '엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다' 이다.</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memeber</span><span class="o">);</span>
</code></pre></div></div>
<p>영속성 컨텍스트는</p>
<ul>
  <li>엔티티 매니저를 생성할 때 하나 만들어진다.</li>
  <li>엔티티 매니저를 통해서 접근할 수 있다.</li>
  <li>엔티티 매니저를 통해 관리받는다.</li>
  <li>여러 엔티티 매니저가 접근할 수도 있다.<br />
<br />
<br />
<br /></li>
</ul>

<h2 id="33-엔티티의-생명주기">3.3 엔티티의 생명주기</h2>
<p>엔티티에는 4가지 상태가 존재한다.</p>
<ul>
  <li>비영속(new / transient): 영속성 컨텍스트와 전혀 관계가 없는 상태</li>
  <li>영속(managed): 영속성 컨텍스트에 저장된 상태</li>
  <li>준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태</li>
  <li>삭제(removed): 삭제된 상태</li>
</ul>
<center><img src="/assets/images/posts/books/2/3_3_생명주기.png" alt="생명주기" width="90%" height="90%" /></center>
<p><br />
<br />
<br /></p>

<h2 id="34-영속성-컨텍스트의-특징">3.4 영속성 컨텍스트의 특징</h2>
<p>영속성 컨텍스트의 특징은 다음과 같다.</p>

<ul>
  <li><strong>영속성 컨텍스트는 엔티티를 식별자값(@Id)으로 구분한다.</strong> 영속 상태는 식별자 값이 반드시 있어야 한다.</li>
  <li>JPA는 보통 <strong>트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 플러시(flush)라 한다.</strong></li>
</ul>

<div class="notice--info">
<p><strong>영속성 컨텍스트가 엔티티를 관리할 때 장점</strong></p>
<ul>
  <li>1차 캐시</li>
  <li>동일성 보장</li>
  <li>트랜잭션을 지원하는 쓰기 지연</li>
  <li>변경 감지</li>
  <li>지연로딩</li>
</ul>
</div>
<p><br />
<br /></p>

<h3 id="341-엔티티-조회">3.4.1 엔티티 조회</h3>
<p>영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다. 영속 상태의 엔티티는 모두 이곳에 저장된다.</p>

<p><strong>1차 캐시에서 조회</strong></p>
<center><img src="/assets/images/posts/books/2/3_4_1차캐시에서조회.png" alt="1차캐시에서조회" width="90%" height="90%" /></center>

<ul>
  <li>1차 캐시의 키는 식별자(@Id) 값.</li>
  <li>식별자 값은 데이터베이스 기본 키와 매핑.</li>
  <li>1차 캐시에서 엔티티를 찾고 엔티티가 없으면 데이터베이스에서 조회한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 비영속 상태</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
<span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"회원1"</span><span class="o">);</span>

<span class="c1">// 영속 상태 (1차 캐시에 저장됨)</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

<span class="c1">// 1차 캐시에서 조회</span>
<span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<p><strong>데이터베이스에서 조회</strong></p>
<ul>
  <li>조회시 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성.</li>
  <li>1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.</li>
</ul>

<center><img src="/assets/images/posts/books/2/3_4_1차캐시에없으면데이터베이스서조회.png" alt="1차캐시에없으면데이터베이스서조회" width="90%" height="90%" /></center>
<p><br />
<br /></p>

<p><strong>영속 엔티티의 동일성 보장</strong><br />
영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">a</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
<span class="nc">Member</span> <span class="n">b</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">);</span>
</code></pre></div></div>

<div class="notice--warning">
<p><strong>동일성과 동등성</strong></p>
<ul>
  <li>동일성(identity): 실제 인스턴스가 같다. 따라서 참조 값을 비교하는 == 비교의 값이 같다.</li>
  <li>동등성(equality): 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다.</li>
</ul>
</div>
<p><br />
<br /></p>

<h3 id="342-엔티티-등록">3.4.2 엔티티 등록</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span> 
<span class="nc">EntityTransaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
<span class="c1">// 엔티티 매니저는 데이터 변경 시 트랜잭션을 시작해야 한다.</span>
<span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span> <span class="c1">//트랜잭션 시작</span>

<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberA</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberB</span><span class="o">);</span>
<span class="c1">// 여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.</span>

<span class="c1">// 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.</span>
<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</code></pre></div></div>
<ol>
  <li>엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아둔다.</li>
  <li>트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보낸다. 이를 트랜잭션을 지원하는 쓰기 지연이라 한다.</li>
</ol>

<center><img src="/assets/images/posts/books/2/3_4_쓰기지연1.png" alt="쓰기지연" width="90%" height="90%" /></center>
<p><br /></p>
<center><img src="/assets/images/posts/books/2/3_4_쓰기지연2.png" alt="쓰기지연" width="90%" height="90%" /></center>
<p><br /></p>
<center><img src="/assets/images/posts/books/2/3_4_쓰기지연3.png" alt="쓰기지연" width="90%" height="90%" /></center>

<div class="notice--info">
<p><strong>플러시</strong></p>
<ul>
  <li>플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는 작업</li>
  <li>구체적으로 이야기하면 쓰기 지연 SQL을 데이터베이스에 보내는 작업이다.</li>
</ul>
</div>

<div class="notice--info">
<p><strong>트랜잭션을 지원하는 쓰기 지연이 가능한 이유</strong></p>
<ul>
  <li>등록 쿼리를 그때 그때 데이터베이스에 전달해도 트랜잭션을 커밋하지 않으면 아무 소용 없다.</li>
  <li>결국 데이터베이스에 SQL을 그때 그때 전달하나, 커밋 직전에만 전달하나 결과는 같다.</li>
</ul>
</div>
<p><br />
<br /></p>

<h3 id="343-엔티티-수정">3.4.3 엔티티 수정</h3>
<p><strong>SQL 수정 쿼리의 문제점</strong></p>
<ul>
  <li>수정 쿼리가 많아진다.</li>
  <li>비즈니스 로직을 분석하기 위해 SQL을 계속 확인해야한다.</li>
  <li>결국 직간접적으로 <strong>비즈니스 로직이 SQL에 의존한다.</strong><br />
<br /></li>
</ul>

<p><strong>JPA의 수정: 변경감지</strong></p>
<ul>
  <li><strong>JPA에서 엔티티 수정은 단순히 엔티티를 조회해서 데이터만 변경</strong>하면 된다.</li>
  <li>이렇게 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 <strong>변경 감지</strong>라 한다.</li>
  <li><strong>변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span> 
<span class="nc">EntityTransaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>

<span class="c1">// 트랜잭션 시작</span>
<span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>

<span class="c1">// 영속 엔티티 조회</span>
<span class="nc">Member</span> <span class="n">memberA</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"memberA"</span><span class="o">);</span>

<span class="c1">// 영속 엔티티 데이터 수정</span>
<span class="n">memberA</span><span class="o">.</span><span class="na">setUserName</span><span class="o">(</span><span class="s">"hi"</span><span class="o">);</span>
<span class="n">memberA</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>

<span class="c1">// 트랜잭션 커밋</span>
<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</code></pre></div></div>

<center><img src="/assets/images/posts/books/2/3_4_변경감지.png" alt="변경감지" width="100%" height="100%" /></center>
<p><br /></p>

<ul>
  <li><strong>JPA의 수정 기본전략은 엔티티의 모든 필드를 업데이트</strong> 한다.</li>
  <li>필드가 너무 많거나 저장되는 내용이 너무 크면 수정된 데이터만 사용해서 <strong>동적으로 UPDATE SQL을 생성하는 전략을 선택할 수 있다.</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@org</span><span class="o">.</span><span class="na">hibernate</span><span class="o">.</span><span class="na">annotations</span><span class="o">.</span><span class="na">DynamicUpdate</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span><span class="o">{...}</span>
</code></pre></div></div>

<div class="notice--info">
<p><strong>참고</strong><br />
상황에 따라 다르겠지만 컬럼이 대략 30개 정도가 아니라면 기본 전략의 수정 쿼리가 빠르다.<br />
추가로 <strong>INSERT SQL을 동적으로 생성하는 <code class="language-plaintext highlighter-rouge">@DynamicInsert</code>도 있다.</strong></p>
</div>
<p><br />
<br /></p>

<h3 id="344-엔티티-삭제">3.4.4 엔티티 삭제</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 영속 엔티티 조회</span>
<span class="nc">Member</span> <span class="n">memberA</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"memberA"</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">memberA</span><span class="o">);</span>
</code></pre></div></div>
<ol>
  <li><code class="language-plaintext highlighter-rouge">em.remove();</code> 호출</li>
  <li>호출 순간 영속성 컨텍스트에서 엔티티 제거</li>
  <li>쓰기 지연 SQL 저장소에 삭제 쿼리 등록</li>
  <li>트랜잭션 커밋시 플러시 (실제 데이터베이스에 삭제 쿼리 전달)</li>
  <li>데이터베이스 트랜잭션 커밋<br />
<br />
<br /></li>
</ol>

<h2 id="35-플러시">3.5 플러시</h2>
<p><strong>플러시는(<code class="language-plaintext highlighter-rouge">flush()</code>)는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.</strong> 동작 순서는 다음과 같다.</p>
<ol>
  <li>변경 감지가 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.</li>
  <li>수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.</li>
  <li>쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.(등록,수정,삭제 쿼리)<br />
<br /></li>
</ol>

<p><strong>영속성 컨텍스트를 플러시하는 방법 3가지</strong></p>
<ol>
  <li>직접 호출 (<code class="language-plaintext highlighter-rouge">em.flush()</code>)</li>
  <li>트랜잭션 커밋</li>
  <li>JPQL 쿼리 실행
    <ul>
      <li>JPQL은 SQL로 변환되어 데이터베이스에서 엔티티 조회</li>
      <li>만약 엔티티가 데이터베이스에 없으면 조회 불가</li>
      <li>따라서 플러시를 통해 변경 내용을 데이터베이스에 반영해야 함</li>
    </ul>
  </li>
</ol>

<div class="notice--info">
<p><strong>참고</strong><br />
식별자를 기준으로 조회하는 <code class="language-plaintext highlighter-rouge">find()</code> 메소드를 호출할 때는 플러시가 실행되지 않는다.</p>
</div>
<p><br />
<br /></p>

<h3 id="351-플러시-모드-옵션">3.5.1 플러시 모드 옵션</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">FlushModeType.AUTO</code>: 커밋이나 쿼리를 실행할 때 플러시(기본값)</li>
  <li><code class="language-plaintext highlighter-rouge">FlushModeType.COMMIT</code>: 커밋할 때만 플러시</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">setFlushMode</span><span class="o">(</span><span class="nc">FlushModeType</span><span class="o">.</span><span class="na">COMMIT</span><span class="o">);</span> <span class="c1">// 플러시 모드 직접 설정</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="36-준영속">3.6 준영속</h2>
<ul>
  <li>영속성 컨텍스트가 관리하는 <strong>영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 준영속 상태</strong>라 한다.</li>
  <li><strong>준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.</strong><br />
<br /></li>
</ul>

<p><strong>영속 상태의 엔티티를 준영속 상태로 만드는 방법</strong></p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">em.detach(entity)</code>: 특정 엔티티만 준영속 상태로 전환</li>
  <li><code class="language-plaintext highlighter-rouge">em.clear()</code>: 영속성 컨텍스트를 완전히 초기화</li>
  <li><code class="language-plaintext highlighter-rouge">em.close()</code>: 영속성 컨텍스트를 종료<br />
<br />
<br /></li>
</ol>

<h3 id="361-엔티티를-준영속-상태로-전환-detach">3.6.1 엔티티를 준영속 상태로 전환: detach()</h3>
<p>특정 엔티티만 준영속 상태로 전환</p>
<center><img src="/assets/images/posts/books/2/3_6_detach1.png" width="100%" height="100%" /></center>
<center><img src="/assets/images/posts/books/2/3_6_detach2.png" width="100%" height="100%" /></center>
<p><br /></p>

<h3 id="362-영속성-컨텍스트-초기화-clear">3.6.2 영속성 컨텍스트 초기화: clear()</h3>
<p>영속성 컨텍스트를 초기화해서 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만듬</p>
<center><img src="/assets/images/posts/books/2/3_6_clear1.png" width="100%" height="100%" /></center>
<center><img src="/assets/images/posts/books/2/3_6_clear2.png" width="100%" height="100%" /></center>
<p><br /></p>

<h3 id="363-영속성-컨텍스트-종료-close">3.6.3 영속성 컨텍스트 종료: close()</h3>
<p>영속성 컨텍스트를 종료하면 해당 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모둔 준영속 상태가 된다.</p>
<center><img src="/assets/images/posts/books/2/3_6_close.png" width="100%" height="100%" /></center>
<center><img src="/assets/images/posts/books/2/3_6_close2.png" width="100%" height="100%" /></center>
<p><br /></p>

<h3 id="364-준영속-상태의-특징">3.6.4 준영속 상태의 특징</h3>
<ul>
  <li>거의 비영속 상태에 가깝다.</li>
  <li>식별자 값을 가지고 있다. <em>(준영속 상태는 이미 한 번 영속 상태였으므로 식별자 값을 가지고 있다)</em></li>
  <li>지연 로딩을 할 수 없다.<br />
<br />
<br /></li>
</ul>

<h3 id="365-병합-merge">3.6.5 병합: merge()</h3>
<p>준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용한다. <code class="language-plaintext highlighter-rouge">merge()</code> 메소드는 준영속 상태의 엔티티를 받아서 그 정보로 <strong>새로운 영속 상태의 엔티티를 반환한다.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">mergeMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>준영속 병합</strong><br />
준영속 상태인 <code class="language-plaintext highlighter-rouge">member</code>엔티티와 영속 상태인 <code class="language-plaintext highlighter-rouge">mergeMember</code> 엔티티는 서로 다른 인스턴스다. 따라서 다음과 같이 참조하도록 사용하는 것이 안전하다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Member mergeMember = em.merge(member); // 이 코드는 위험</span>
<span class="n">member</span> <span class="o">=</span> <span class="n">em2</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">member</span><span class="o">);</span> <span class="c1">// 이렇게 사용</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>비영속 병합</strong><br />
병합은 비영속 엔티티도 영속 상태로 만들 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="nc">Mmeber</span> <span class="n">newMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">merge</span><span class="o">(</span><span class="n">member</span><span class="o">);</span> <span class="c1">// 비영속 병합</span>
<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>병합 동작 순서</strong></p>
<ol>
  <li>파라미터로 넘어온 엔티티의 식별자 값으로 영속성 컨텍스트 조회</li>
  <li>찾는 엔티티가 없으면 데이터베이스 조회</li>
  <li>데이터베이스에서도 없으면 엔티티 생성해서 병합<br />
<br />
<br /></li>
</ol>

<h2 id="37-정리">3.7 정리</h2>
<ul>
  <li>엔티티 매니저는 앤티티 매니저 팩토리에서 생성한다.</li>
  <li>영속성 컨텍스트는 엔티티 매니저를 통해서 접근할 수 있다.</li>
  <li><strong>영속성 컨텍스트는 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할</strong>을 한다.</li>
  <li>영속성 컨텍스트 덕분에 <strong>1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기지연, 변경 감지, 지연 로딩 기능</strong>을 사용할 수 있다.</li>
  <li>영속성 컨텍스트에 저장한 <strong>엔티티는 플러시 시점에 데이터베이스에 반영</strong>된다.</li>
  <li><strong>플러시는 일반적으로 트랜잭션을 커밋할 때 동작</strong>한다.</li>
  <li><strong>영속 상태: 영속성 컨텍스트가 관리하는 엔티티</strong></li>
  <li><strong>준영속 상태: 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 준영속 상태</strong></li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<h1 id="4-엔티티-매핑">4. 엔티티 매핑</h1>
<ul>
  <li>객체와 테이블 매핑: <code class="language-plaintext highlighter-rouge">@Entity</code>, <code class="language-plaintext highlighter-rouge">@Table</code></li>
  <li>기본 키 매핑: <code class="language-plaintext highlighter-rouge">@Id</code></li>
  <li>필드와 컬럼 매핑: <code class="language-plaintext highlighter-rouge">@Column</code></li>
  <li>연관관계 매핑: <code class="language-plaintext highlighter-rouge">@ManyToOne</code>, <code class="language-plaintext highlighter-rouge">@JoinColumn</code></li>
</ul>

<p><br /></p>

<h2 id="41-entity">4.1 @Entity</h2>
<p>JPA를 사용해서 테이블과 매핑할 클래스</p>

<table>
  <thead>
    <tr>
      <th><strong>속성</strong></th>
      <th><strong>기능</strong></th>
      <th><strong>기본값</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>name</td>
      <td>JPA에서 사용할 엔티티 이름을 지정한다. 기본값은 클래스 이름이다. 만약 다른 패키지에 이름이 같은 엔티티 클래스가 있다면 출돌한다.</td>
      <td>클래스이름 (예: Member)</td>
    </tr>
  </tbody>
</table>

<div class="notice--warning">
<p><strong>주의사항</strong></p>
<ul>
  <li>기본 생성자는 필수 (<code class="language-plaintext highlighter-rouge">public</code> 또는 <code class="language-plaintext highlighter-rouge">protected</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">final, enum, interface, inner</code> 클래스에는 사용할 수 없다.</li>
  <li>저장할 필드에 <code class="language-plaintext highlighter-rouge">final</code>을 사용하면 안된다.</li>
</ul>
</div>
<p><br />
<br /></p>

<h2 id="42-table">4.2 @Table</h2>
<p>엔티티와 매핑할 테이블을 지정. 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용한다.</p>

<table>
  <thead>
    <tr>
      <th><strong>속성</strong></th>
      <th><strong>기능</strong></th>
      <th><strong>기본값</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>name</td>
      <td>매핑할 테이블 이름</td>
      <td>엔티티 이름을 사용한다.</td>
    </tr>
    <tr>
      <td>catalog</td>
      <td>catalog 기능이 있는 데이터베이스에서 catalog를 매핑한다.</td>
      <td> </td>
    </tr>
    <tr>
      <td>schema</td>
      <td>schema 기능이 있는 데이터베이스에서 schema를 매핑한다.</td>
      <td> </td>
    </tr>
    <tr>
      <td>uniqueConstraints</td>
      <td>DDL 생성 시 유니크 제약조건을 만든다. 2개 이상의 복합 유니크 제약조건도 만들 수 있다. 이 기능은 스키마 자동 생성 기능을 사용해서 DDL을 만들 때만 사용된다.</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h2 id="43-다양한-매핑-사용">4.3 다양한 매핑 사용</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"MEMBER"</span><span class="o">,</span>
    <span class="n">uniqueConstraints</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@UniqueConstraint</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"NAME_AGE_UNIQUE"</span><span class="o">,</span>
        <span class="n">columnNames</span> <span class="o">=</span> <span class="o">{</span><span class="s">"NAME"</span><span class="o">,</span> <span class="s">"AGE"</span><span class="o">}</span> 
    <span class="o">)}</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>

    <span class="c1">// enum을 사용하려면 @Enumerated 어노테이션으로 매핑</span>
    <span class="nd">@Enumerated</span><span class="o">(</span><span class="nc">EnumType</span><span class="o">.</span><span class="na">STRING</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">RoleType</span> <span class="n">roleType</span><span class="o">;</span>

    <span class="c1">// 자바의 날짜 타입은 @Temporal 어노테이션으로 매핑</span>
    <span class="nd">@Temporal</span><span class="o">(</span><span class="nc">TemporalType</span><span class="o">.</span><span class="na">TIMESTAMP</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Date</span> <span class="n">createdDate</span><span class="o">;</span>

    <span class="c1">// CLOB, BLOB타입은 @Lob 어노테이션으로 매핑</span>
    <span class="nd">@Lob</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">description</span><span class="o">;</span>

    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="44-데이터베이스-스키마-자동-생성">4.4 데이터베이스 스키마 자동 생성</h2>
<p>JPA는 데이터베이스 스키마를 자동으로 생성하는 기능을 지원한다.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 스키마 자동 생성 --&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.hbm2ddl.auto"</span> <span class="na">value=</span><span class="s">"create"</span> <span class="nt">/&gt;</span>

<span class="c">&lt;!-- 콘솔에 테이블 생성 DDL 출력 --&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.show_sql"</span> <span class="na">value=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>hibernate.hbm2ddl.auto 속성</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>옵션</strong></th>
      <th><strong>설명</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>create</td>
      <td>기존 테이블을 삭제하고 새로 생성한다. DROP + CREATE</td>
    </tr>
    <tr>
      <td>create-drop</td>
      <td>create 속성에 추가로 애플리케이션을 종료할 때 생성한 DDL을 제거한다. DROP + CREATE + DROP</td>
    </tr>
    <tr>
      <td>update</td>
      <td>데이터베이스 테이블과 엔티티 매핑정보를 비교해서 변경 사항만 수정한다.</td>
    </tr>
    <tr>
      <td>validate</td>
      <td>데이터베이스 테이블과 엔티티 매핑정보를 비교해서 차이가 있으면 경고를 남기고 애플리케이션을 실행하지 않는다.</td>
    </tr>
    <tr>
      <td>none</td>
      <td>자동 생성 기능을 사용하지 않으려면 hibernate.hbm2ddl.auto 속성 자체를 삭제하거나 유효하지 않은 옵션 값을 주면 된다.</td>
    </tr>
  </tbody>
</table>

<div class="notice--warning">
<p><strong>hibernate.hbm2ddl.auto 주의사항</strong><br />
운영 서버에서는 DDL을 수정하는 옵션은 절대 사용하면 안된다.</p>
<ul>
  <li>개발 초기 단계: <code class="language-plaintext highlighter-rouge">create</code>, <code class="language-plaintext highlighter-rouge">update</code></li>
  <li>초기화 상태로 테스트, CI서버: <code class="language-plaintext highlighter-rouge">create</code>, <code class="language-plaintext highlighter-rouge">create-drop</code></li>
  <li>테스트 서버: <code class="language-plaintext highlighter-rouge">update</code>, <code class="language-plaintext highlighter-rouge">validate</code></li>
  <li>스테이징, 운영 서버: <code class="language-plaintext highlighter-rouge">validate</code>, <code class="language-plaintext highlighter-rouge">none</code></li>
</ul>
</div>
<p><br />
<br /></p>

<p><strong>기본 이름 매핑 전략 변경하기</strong><br />
테이블 명이나 컬럼 명이 생략되면 자바의 카멜 표기법을 데이터베이스 테이블의 언더스코어 표기법으로 매핑한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">"hibernate.ejb.naming_strategy"</span> <span class="n">value</span><span class="o">=</span><span class="s">"org.hibernate.cfg.ImprovedNamingStrategy"</span> <span class="o">/&gt;</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="45-ddl-생성-기능">4.5 DDL 생성 기능</h2>
<p><strong>제약 조건 추가</strong><br />
스키마 자동 생성하기를 통해 DDL에 제약조건을 추가할 수 있다. 다만 <strong>DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"MEMBER"</span><span class="o">,</span> 
    <span class="cm">/** 
     *  유니크 제약조건 추가
     *  ALET TABLE MEMBER
     *      ADD CONSTRAINT NAME_AGE_UNIQUE UNIQUE (NAME, AGE)
     */</span>
    <span class="n">uniqueConstraints</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@UniqueConstraint</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"NAME_AGE_UNIQUE"</span><span class="o">,</span>
        <span class="n">columnNames</span> <span class="o">=</span> <span class="o">{</span><span class="s">"NAME"</span><span class="o">,</span> <span class="s">"AGE"</span><span class="o">}</span> 
    <span class="o">)}</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>

    <span class="c1">// 컬럼명 NAME, not null, 문자크기 10</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"NAME"</span><span class="o">,</span> <span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">10</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="46-ddl-생성-기능">4.6 DDL 생성 기능</h2>
<p>JPA가 제공하는 데이터베이스 기본 키 생성 전략은 다음과 같다.</p>
<ul>
  <li>직접 할당: 애플리케이션에서 직접 할당</li>
  <li>자동 생성: 대리 키 사용 방식
    <ul>
      <li>IDENTITY: 기본 키 생성을 데이터베이스에 위임</li>
      <li>SEQUENCE: 데이터베이스 시퀀스를 사용</li>
      <li>TABLE: 키 생성 테이블을 사용</li>
    </ul>
  </li>
</ul>

<p>자동 생성 전략이 다양한 이유는 데이터베이스 벤더마다 지원하는 방식이 다르기 때문이다. 키 생성 전략을 사용하려면 다음 속성을 추가한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">"hibernate.id.new_generator_mappings"</span> <span class="n">value</span><span class="o">=</span><span class="s">"true"</span> <span class="o">/&gt;</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="461-기본-키-직접-할당-전략">4.6.1 기본 키 직접 할당 전략</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Id</span>
<span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ID"</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Board</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Board</span><span class="o">();</span>
<span class="n">board</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span> <span class="c1">// 기본 키 직접 할당</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="462-identity-전략">4.6.2 IDENTITY 전략</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">IDENTITY</code>는 기본 키 생성을 데이터베이스에 위임하는 전략이다.</li>
  <li><code class="language-plaintext highlighter-rouge">IDENTITY</code> 식별자 생성 전략은 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있다.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">em.persist()</code>를 호출하는 즉시 <code class="language-plaintext highlighter-rouge">INSERT SQL</code>이 데이터베이스에 전달된다.</strong></li>
  <li>따라서 <strong>트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Id</span>
<span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Board</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Board</span><span class="o">();</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>
<span class="n">board</span><span class="o">.</span><span class="na">getId</span><span class="o">();</span> <span class="c1">// 1</span>
</code></pre></div></div>

<div class="notice--info">
<p><strong>참고</strong><br />
IDENTITY 전략은 데이터를 데이터베이스에 INSERT한 후에 기본 키값을 조회할 수있다. 따라서 엔티티에 식별자 값을 할당하려면 JPA는 추가로 데이터베이스를 조회해야 한다. 하지만 <strong>하이버네이트는 JDBC3에 추가된 <code class="language-plaintext highlighter-rouge">Statement.getGeneratedKeys()</code> 메소드를 사용해서 데이터베이스와 한번만 통신한다.</strong></p>
</div>
<p><br />
<br /></p>

<h3 id="463-sequence-전략">4.6.3 SEQUENCE 전략</h3>
<p>SEQUENCE 전략은 데이터베이스 시퀀스를 이용해 기본 키를 생성한다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 데이터베이스 시퀀스 생성</span>
<span class="k">CREATE</span> <span class="n">SEQUENCE</span> <span class="n">BOARD_SEQ</span> <span class="k">START</span> <span class="k">WITH</span> <span class="mi">1</span> <span class="k">INCREMENT</span> <span class="k">BY</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@SequenceGenerator</span><span class="o">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_SEQ_GENERATOR"</span><span class="o">,</span>
    <span class="n">sequenceName</span> <span class="o">=</span> <span class="s">"BOARD_SEQ"</span><span class="o">,</span> <span class="c1">// 매핑할 데이터베이스 시퀀스 이름</span>
    <span class="n">initialValue</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span>
    <span class="n">allocationsSize</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BOARD</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span>
        <span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">SEQUENCE</span><span class="o">,</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="s">"BOARD_SEQ_GENERATOR"</span>
    <span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>@SequenceGenerator</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>속성</strong></th>
      <th><strong>기능</strong></th>
      <th><strong>기본값</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>name</td>
      <td>식별자 생성기 이름</td>
      <td>필수</td>
    </tr>
    <tr>
      <td>sequenceName</td>
      <td>데이터베이스에 등록되어 있는 시퀀스 이름</td>
      <td>hibernate_sequence</td>
    </tr>
    <tr>
      <td>initialValue</td>
      <td>DDL 생성 시에만 사용됨. 시퀀스 DDL을 생성할 때 처음 시작하는 수를 지정한다.</td>
      <td>1</td>
    </tr>
    <tr>
      <td>allocationsSize</td>
      <td>시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용됨)</td>
      <td>50</td>
    </tr>
    <tr>
      <td>catalog, schema</td>
      <td>데이터베이스 catalog, schema 이름</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>SEQUENCE 전략과 최적화</strong><br />
SEQUENCE 전략은 데이터베이스와 2번 통신한다.</p>
<ol>
  <li>식별자 구하기 <em>(SELECT BOARD_SEQ.NEXTVAL FROM DUAL)</em></li>
  <li>조회한 시퀀스를 기본 키 값으로 사용해 데이터베이스에 저장 <em>(INSERT INTO BOARD …)</em></li>
</ol>

<p>JPA는 시퀀스 접근하는 횟수를 줄이기 위해 <code class="language-plaintext highlighter-rouge">@SequenceGenerator.allocationsSize</code>를 사용한다. 여기에 설정한 값만큼 한 번에 시퀀스 값을 증가시키고, 그만큼 메모리에 시퀀스 값을 할당한다. 이 방법은 시퀀스 값을 선점하므로 여러 JVM이 동시에 동작해도 기본 키 값이 충돌하지 않는다. 반면에 시퀀스 값을 한 번에 많이 증가시킨다. 이런 상황이 부담스럽고 <code class="language-plaintext highlighter-rouge">INSERT</code> 성능이 중요하지 않으면 <code class="language-plaintext highlighter-rouge">allocationsSize</code>값을 1로 설정한다.<br />
<br />
<br /></p>

<h3 id="464-table-전략">4.6.4 TABLE 전략</h3>
<p>TABLE 전략은 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 컬럼을 만들어 데이터베이스 시퀀스를 흉내내는 전략이다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 데이터베이스 키 생성 용도 테이블 생성</span>
<span class="k">create</span> <span class="k">table</span> <span class="n">MY_SEQUENCES</span> <span class="p">(</span>
    <span class="n">sequence_name</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">)</span> <span class="k">not</span> <span class="k">null</span><span class="p">,</span>
    <span class="n">next_val</span> <span class="nb">bigint</span><span class="p">,</span>
    <span class="k">primary</span> <span class="k">key</span> <span class="p">(</span><span class="n">sequence_name</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@TableGenerator</span><span class="o">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_SEQ_GENERATOR"</span><span class="o">,</span>
    <span class="n">table</span> <span class="o">=</span> <span class="s">"MY_SEQUENCES"</span><span class="o">,</span>
    <span class="n">pkColumnValue</span> <span class="o">=</span> <span class="s">"BOARD_SEQ"</span><span class="o">,</span>
    <span class="n">allocationsSize</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BOARD</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span>
        <span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">TABLE</span><span class="o">,</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="s">"BOARD_SEQ_GENERATOR"</span>
    <span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>@TableGenerator</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>속성</strong></th>
      <th><strong>기능</strong></th>
      <th><strong>기본값</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>name</td>
      <td>식별자 생성기 이름</td>
      <td>필수</td>
    </tr>
    <tr>
      <td>table</td>
      <td>키생성 테이블명</td>
      <td>hibernate_sequences</td>
    </tr>
    <tr>
      <td>pkColumnName</td>
      <td>시퀀스 컬럼명</td>
      <td>sequence_name</td>
    </tr>
    <tr>
      <td>valueColumnName</td>
      <td>시퀀스 값 컬럼명</td>
      <td>next_val</td>
    </tr>
    <tr>
      <td>pkColumnValue</td>
      <td>키로 사용할 값 이름</td>
      <td>엔티티 이름</td>
    </tr>
    <tr>
      <td>initialValue</td>
      <td>초기 값, 마지막으로 생성된 값이 기준이다.</td>
      <td>0</td>
    </tr>
    <tr>
      <td>allocationsSize</td>
      <td>시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용됨)</td>
      <td>50</td>
    </tr>
    <tr>
      <td>catalog, schema</td>
      <td>데이터베이스 catalog, schema 이름</td>
      <td> </td>
    </tr>
    <tr>
      <td>uniqueConstraints(DDL)</td>
      <td>유니크 제약 조건을 지정할 수 있다.</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>TABLE 전략과 최적화</strong><br />
TABLE 전략은 값을 조회하면서 SELECT 쿼리를 사용하고, 다음 값으로 증가시키기 위해 UPDATE 쿼리를 사용한다. SEQUENCE 전략과 비교해서 데이터베이스와 한 번 더 통신하는 단점이 있다.<br />
<br />
<br /></p>

<h3 id="465-auto-전략">4.6.5 AUTO 전략</h3>
<p>데이터베이스의 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택한다. <strong><code class="language-plaintext highlighter-rouge">@GeneratedValue.strategy</code>의 기본값은 <code class="language-plaintext highlighter-rouge">AUTO</code>다.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="466-기본-키-매핑-정리">4.6.6 기본 키 매핑 정리</h3>
<ul>
  <li>직접 할당: 애플리케이션에서 직접 식별자 값을 할당</li>
  <li>SEQUENCE: 데이터베이스 시퀀스에서 식별자 값을 획득 후 영속성 컨텍스트에 저장</li>
  <li>TABLE: 데이터베이스 시퀀스 생성용 테이블에서 식별자 값을 획등 후 영속성 컨텍스트에 저장</li>
  <li>IDENTITY: 데이터베이스에 엔티티를 저장해서 식별자 값을 획득한 후 영속성 컨텍스트에 저장<br />
<br /></li>
</ul>

<p><strong>식별자 선택 전략</strong><br />
테이블의 기본 키를 선택하는 전략은 크게 2가지가 있다.</p>
<ol>
  <li>자연 키(natural key)
    <ul>
      <li>비즈니스에 의미가 있는 키</li>
      <li>예) 주민등록번호, 이메일, 전화번호</li>
    </ul>
  </li>
  <li>대리 키(surrogate key)
    <ul>
      <li>비즈니스와 관련이 없는 임의로 만들어진 키, 대체 키로도 불린다</li>
      <li>예) 오라클 시퀀스, auto_increment, 키 생성 테이블 사용</li>
    </ul>
  </li>
</ol>

<div class="notice--info">
<p><strong>권장하는 식별자 선택 전략</strong><br />
자연 키보다는 <strong>대리 키를 권장</strong>한다.</p>
<ul>
  <li>자연 키는 변경될 수 있다.</li>
  <li>비즈니스 환경은 언젠가 변한다.</li>
  <li>테이블은 한 번 정의하면 변경하기 어렵다.</li>
</ul>
</div>
<p><br />
<br />
<br /></p>

<h2 id="47-필드와-컬럼-매핑-레퍼런스">4.7 필드와 컬럼 매핑: 레퍼런스</h2>
<table>
    <thead>
        <tr>
            <th>분류</th>
            <th>매핑 어노테이션</th>
            <th>설명</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="5">필드와 컬럼 매핑</td>
            <td>@Column</td>
            <td>컬럼을 매핑한다.</td>
        </tr>
        <tr>
            <td>@Enumerated</td>
            <td>자바의 enum 타입을 매핑한다.</td>
        </tr>
        <tr>
            <td>@Temporal</td>
            <td>날짜 타입을 매핑한다.</td>
        </tr>
        <tr>
            <td>@Lob</td>
            <td>BLOB, CLOB 타입을 매핑한다.</td>
        </tr>
        <tr>
            <td>@Transient</td>
            <td>특정 필드를 데이터베이스에 매핑하지 않는다.</td>
        </tr>
        <tr>
            <td>기타</td>
            <td>@Access</td>
            <td>JPA가 엔티티에 접근하는 방식을 지정한다.</td>
        </tr>
    </tbody>
</table>
<p><br />
<br /></p>

<h3 id="471-column">4.7.1 @Column</h3>
<p>@Column은 객체 필드를 테이블 컬럼에 매핑한다.</p>

<table>
  <thead>
    <tr>
      <th><strong>속성</strong></th>
      <th><strong>기능</strong></th>
      <th><strong>기본값</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>name</td>
      <td>필드와 매핑할 테이블의 컬럼 이름</td>
      <td>객체의 필드 이름</td>
    </tr>
    <tr>
      <td>insertable (거의 사용하지 않음)</td>
      <td>엔티티 저장 시 이 필드도 같이 저장한다. false로 설정하면 이 필드는 데이터베이스에 저장하지 않는다.</td>
      <td>true</td>
    </tr>
    <tr>
      <td>updatable (거의 사용하지 않음)</td>
      <td>엔티티 수정 시 이 필드도 같이 수정한다. false로 설정하면 이 필드는 데이터베이스에 수정하지 않는다.</td>
      <td>true</td>
    </tr>
    <tr>
      <td>table (거의 사용하지 않음)</td>
      <td>하나의 엔티티를 두 개 이상의 테이블에 매핑할 때 사용한다. 지정한 필드를 다른 테이블에 매핑할 수 있다.</td>
      <td>현재 클래스가 매핑된 테이블</td>
    </tr>
    <tr>
      <td>nullable (DDL)</td>
      <td>null 값의 허용 여부 설정.</td>
      <td>true</td>
    </tr>
    <tr>
      <td>unique (DDL)</td>
      <td>@Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용한다. 만약 두 컬럼 이상을 사용해서 유니크 제약조건을 사용하려면 @Table.uniqueConstraints를 사용해야 한다.</td>
      <td> </td>
    </tr>
    <tr>
      <td>length (DDL)</td>
      <td>문자 길이 제약조건, String 타입에만 사용한다.</td>
      <td>255</td>
    </tr>
    <tr>
      <td>precision, scale (DDL)</td>
      <td>BigDecimal 타입에서 사용한다. precision은 소수점을 포함한 전체 자릿수, scale은 소수의 자릿수다. double, float타입에는 적용되지 않는다.</td>
      <td>precision = 19, scale=2</td>
    </tr>
    <tr>
      <td>columnDefinition</td>
      <td>데이터베이스 컬럼 정보를 직접 줄 수 있다.</td>
      <td>필드의 자바 타입과 방언 정보를 사용해서 적절한 컬럼 타입을 생성한다.</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h3 id="472-enumerated">4.7.2 @Enumerated</h3>
<p>자바의 enum 타입을 매핑할 때 사용한다.</p>
<table>
    <thead>
        <tr>
            <th>속성</th>
            <th>기능</th>
            <th>기본값</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>value</td>
            <td style="word-break:break-all">EnumType.ORDINAL: enum 순서를 데이터베이스에 저장 <br />
            EnumType.STRING: enum 이름을 데이터베이스에 저장
            </td>
            <td>EnumType.ORDINAL</td>
        </tr>
    </tbody>
</table>
<p><br />
<br /></p>

<h3 id="473-temporal">4.7.3 @Temporal</h3>
<p>날짜 타입(<code class="language-plaintext highlighter-rouge">java.util.Date</code>, <code class="language-plaintext highlighter-rouge">java.util.Calendar</code>)을 매핑할 때 사용한다.</p>
<table>
    <thead>
        <tr>
            <th>속성</th>
            <th>기능</th>
            <th>기본값</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>value</td>
            <td style="word-break:break-all">
            - TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑 (예: 2013-10-11)
            <br />
            - TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑 (예: 11:11:11)
            <br />
            - TemporalType.TIMESTAMP: 날짜와 시간, 데이터베이스 timestamp 타입과 매핑 (예: 2013-10-11 11:11:11)
            </td>
            <td>TemporalType은 필수 지정</td>
        </tr>
    </tbody>
</table>
<p><br /></p>

<h3 id="474-lob">4.7.4 @Lob</h3>
<p>데이터베이스 BLOB, CLOB 타입과 매핑한다. 매핑하는 필드 타입에 따라 매핑을 달리한다.</p>
<ul>
  <li>CLOB: String, char[], java.sql.CLOB</li>
  <li>BLOB: byte[], java.sql.BLOB<br />
<br />
<br /></li>
</ul>

<h3 id="475-transient">4.7.5 @Transient</h3>
<p>이 필드는 매핑하지 않는다. 따라서 데이터베이스에 저장하지 않고 조회하지 않는다.<br />
<br />
<br /></p>

<h3 id="476-access">4.7.6 @Access</h3>
<p>JPA가 엔티티 데이터에 접근하는 방식을 지정한다.</p>
<ul>
  <li>AccessType.FIELD: 필드 접근</li>
  <li>AccessType.PROPERTY: 프로퍼티 접근, 접근자(Getter) 사용</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Access</span><span class="o">(</span><span class="nc">AccessType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{...}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Access</span><span class="o">(</span><span class="nc">AccessType</span><span class="o">.</span><span class="na">PROPERTY</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{...}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 두 접근 방식을 함께 사용할 수도 있다.
 *
 * @Id는 필드 접근 방식
 * getFullName()는 프로퍼티 접근 방식
 * Member 엔티티를 저장하면 테이블의 FULLNAME 컬럼에
 * firstName + lastName의 결과가 저장된다.
 */</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    
    <span class="nd">@Id</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Transient</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">firstName</span><span class="o">;</span>

    <span class="nd">@Transient</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">lastName</span><span class="o">;</span>

    <span class="nd">@Access</span><span class="o">(</span><span class="nc">AccessType</span><span class="o">.</span><span class="na">PROPERTY</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getFullName</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">firstName</span> <span class="o">+</span> <span class="n">lastName</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br />
<br />
<br /></p>

<h1 id="5-연관관계-매핑-기초">5. 연관관계 매핑 기초</h1>
<p>연관관계 매핑 키워드 정리</p>
<ul>
  <li>방향(Direction): <strong>[단방향, 양방향]</strong>이 있다. 방향은 객체관계에서만 존재하고 테이블 관계는 항상 양방향이다.</li>
  <li>다중성(Multiplcity): <strong>[다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)]</strong> 다중성이 있다.</li>
  <li>연관관계 주인(Owner): <strong>객체를 양방향 연관관계로 만들면 연관관계 주인을 정해야 한다.</strong><br />
<br />
<br /></li>
</ul>

<h2 id="51-단방향-연관관계">5.1 단방향 연관관계</h2>
<center><img src="/assets/images/posts/books/2/5_1_객체테이블연관관계.png" width="100%" height="100%" /></center>
<p><br /></p>

<p><strong>객체 연관관계와 테이블 연관관계의 차이</strong></p>
<ul>
  <li>객체
    <ul>
      <li>참조(주소)로 연관관계를 맺는다.</li>
      <li>언제나 단방향</li>
      <li>양방향을 하려면 서로다른 단방향 관계 2개로 구현</li>
    </ul>
  </li>
  <li>테이블
    <ul>
      <li>외래 키로 연관관계를 맺는다.</li>
      <li>외래 키 하나로 양방향 조인 가능<br />
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h3 id="511-순수한-객체-연관관계">5.1.1 순수한 객체 연관관계</h3>
<p>객체 참조를 사용해서 연관관계를 탐색할 수 있는데 이것을 <strong>객체 그래프 탐색</strong>이라 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Memeber</span><span class="o">(</span><span class="s">"member1"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">);</span>
    <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Memeber</span><span class="o">(</span><span class="s">"member2"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">);</span>
    <span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team"</span><span class="o">,</span> <span class="s">"팀"</span><span class="o">);</span>

    <span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team</span><span class="o">);</span>
    <span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team</span><span class="o">);</span>

    <span class="c1">// 객체 그래프 탐색</span>
    <span class="nc">Team</span> <span class="n">findTeam</span> <span class="o">=</span> <span class="n">member1</span><span class="o">.</span><span class="na">getTeam</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="512-테이블-연관관계">5.1.2 테이블 연관관계</h3>
<p>외래 키를 사용해서 연관관계를 탐색할 수 잇는데 이것을 조인이라 한다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">T</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span> <span class="n">MEMBER</span> <span class="n">M</span>
    <span class="k">JOIN</span> <span class="n">TEAM</span> <span class="n">T</span> <span class="k">ON</span> <span class="n">M</span><span class="p">.</span><span class="n">TEAM_ID</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">ID</span>
<span class="k">WHERE</span> <span class="n">M</span><span class="p">.</span><span class="n">MEMBER_ID</span> <span class="o">=</span> <span class="s1">'member1'</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="513-객체-관계-매핑">5.1.3 객체 관계 매핑</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="c1">//연관 관계 매핑</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

    <span class="c1">//연관관계 설정</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTeam</span><span class="o">(</span><span class="nc">Team</span> <span class="n">team</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">=</span> <span class="n">team</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
    
    <span class="nd">@Id</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>@ManyToOne</strong></p>
<ul>
  <li>다대일(N:1) 관계라는 매핑 정보</li>
  <li>연관관계 매핑할 때 다중성을 나타내는 어노테이션 필수로 사용해야 한다.<br />
<br /></li>
</ul>

<p><strong>@JoinColumn(name=”TEAM_ID”)</strong></p>
<ul>
  <li>조인컬럼은 외래 키를 매핑할 때 사용한다.</li>
  <li>name 속성에 매핑할 외래 키 이름을 지정한다. (여기선 팀 테이블의 TEAM_ID)</li>
  <li>생략할 수 있다.<br />
<br />
<br /></li>
</ul>

<h3 id="514-joincolumn">5.1.4 @JoinColumn</h3>
<p>@JoinColumn은 외래 키를 매핑할 때 사용한다.</p>

<table>
  <thead>
    <tr>
      <th><strong>속성</strong></th>
      <th><strong>기능</strong></th>
      <th><strong>기본값</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>name</td>
      <td>매핑할 외래 키 이름</td>
      <td>필드명 + _ + 참조하는 테이블의 컬러명</td>
    </tr>
    <tr>
      <td>referencedColumnName</td>
      <td>외래 키가 참조하는 대상 테이블의 컬럼명</td>
      <td>참조하는 테이블의 기본 키 컬럼명</td>
    </tr>
    <tr>
      <td>foreignKey (DDL)</td>
      <td>외래 키 제약조건을 직접 지정할 수 있다. 이 속성은 테이블을 생성할 때만 사용한다.</td>
      <td> </td>
    </tr>
    <tr>
      <td>unique, nullable, insertable, updatable, columnDefinition, table</td>
      <td>@Column의 속성과 같다.</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h3 id="515-manytoone">5.1.5 @ManyToOne</h3>
<p>@ManyToOne 어노테이션은 다대일 관계에서 사용한다.</p>

<table>
  <thead>
    <tr>
      <th><strong>속성</strong></th>
      <th><strong>기능</strong></th>
      <th><strong>기본값</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>optional</td>
      <td>false로 설정하면 연관된 엔티티가 항상 있어야 한다.</td>
      <td>true</td>
    </tr>
    <tr>
      <td>fetch</td>
      <td>글로벌 페치 전략을 설정한다.</td>
      <td>@ManyToOne=FetchType.EAGER   @OneToMany=FetchType.LAZY</td>
    </tr>
    <tr>
      <td>cascade</td>
      <td>영속성 전이 기능을 사용한다.</td>
      <td> </td>
    </tr>
    <tr>
      <td>targetEntity (거의 사용하지 않음)</td>
      <td>연관된 엔티티의 타입 정보를 설정한다. 이 기능을 사용하지 않고 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다.</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h2 id="52-연관관계-사용">5.2 연관관계 사용</h2>
<p>연관관계를 등록, 수정, 삭제, 조회하는 예제를 통해 연관관계를 어떻게 사용하는지 알아본다.<br />
<br />
<br /></p>

<h3 id="521-저장">5.2.1 저장</h3>
<p>JPA에서 엔티티를 저장할때 <strong>연관된 모든 엔티티는 영속 상태</strong>여야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSave</span><span class="o">()</span> <span class="o">{</span>

    <span class="c1">// 팀1 저장</span>
    <span class="nc">Team</span> <span class="n">team1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team1"</span><span class="o">,</span> <span class="s">"팀1"</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span>

    <span class="c1">// 회원1 저장</span>
    <span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member1"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">);</span>
    <span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정 member1 -&gt; team1</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>

    <span class="c1">// 회원2 저장</span>
    <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member2"</span><span class="o">,</span> <span class="s">"회원2"</span><span class="o">);</span>
    <span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정 member2 -&gt; team1</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="522-조회">5.2.2 조회</h3>
<p>연관관계가 있는 엔티티 조회 방법은 크게 2가지다.</p>
<ul>
  <li>객체 그래프 탐색(객체 연관관계를 사용한 조회)</li>
  <li>객체지향 쿼리 사용(JPQL)<br />
<br /></li>
</ul>

<p><strong>객체 그래프 탐색</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
<span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">();</span> <span class="c1">// 객체 그래프 탐색</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"팀 이름 = "</span> <span class="o">+</span> <span class="n">team</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>객체 지향 쿼리 사용</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">testJPQL</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">jpql1</span> <span class="o">=</span> <span class="s">"select m from Member m join m.team t where t.name=:teamName"</span><span class="o">;</span>

    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">jpql1</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
        <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"teamName"</span><span class="o">,</span> <span class="s">"팀1"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>

    <span class="k">for</span> <span class="o">(</span><span class="nc">Member</span> <span class="n">member</span> <span class="o">:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"[query] member.username = "</span> <span class="o">+</span> <span class="n">member</span><span class="o">.</span><span class="na">getUsername</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*
* 결과
* [query] member.username=회원1
* [query] member.username=회원2
*/</span>
</code></pre></div></div>
<p>실행되는 SQL은 다음과 같다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">M</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">MEMBER</span> <span class="n">MEMBER</span> 
<span class="k">INNER</span> <span class="k">JOIN</span> 
    <span class="n">TEAM</span> <span class="n">TEAM</span> <span class="k">ON</span> <span class="n">MEMBER</span><span class="p">.</span><span class="n">TEAM_ID</span> <span class="o">=</span> <span class="n">TEAM1_</span><span class="p">.</span><span class="n">ID</span> 
<span class="k">WHERE</span>
    <span class="n">TEAM1_</span><span class="p">.</span><span class="n">NAME</span><span class="o">=</span><span class="s1">'팀1'</span>
</code></pre></div></div>
<p>실행된 SQL과 JPQL을 비교하면 <strong>JPQL은 객체(엔티티)를 대상</strong>으로 하고 SQL보다 간결하다.<br />
<br />
<br /></p>

<h3 id="523-수정">5.2.3 수정</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">updateRelation</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// 새로운 팀2</span>
    <span class="nc">Team</span> <span class="n">team2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team2"</span><span class="o">,</span> <span class="s">"팀2"</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">team2</span><span class="o">);</span>

    <span class="c1">//회원1에 새로운 팀2 설정</span>
    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>실행되는 수정 SQL은 다음과 같다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">MEMBER</span>
<span class="k">SET</span>
    <span class="n">TEAM_ID</span><span class="o">=</span><span class="s1">'team2'</span><span class="p">,</span> <span class="p">...</span>
<span class="k">WHERE</span> <span class="n">ID</span> <span class="o">=</span> <span class="s1">'member1'</span> 
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="524-연관관계-제거">5.2.4 연관관계 제거</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">deleteRelation</span><span class="o">(</span><span class="nc">EntityManager</span> <span class="n">em</span><span class="o">)</span> <span class="o">{</span>

    <span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
    <span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">//연관관계 제거</span>
<span class="o">}</span>
</code></pre></div></div>
<p>실행되는 연관관계 제거 SQL은 다음과 같다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">UPDATE</span> <span class="n">MEMBER</span>
<span class="k">SET</span>
    <span class="n">TEAM_ID</span><span class="o">=</span><span class="k">null</span><span class="p">,</span> <span class="p">...</span>
<span class="k">WHERE</span> <span class="n">ID</span> <span class="o">=</span> <span class="s1">'member1'</span> 
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="525-연관관계-삭제">5.2.5 연관관계 삭제</h3>
<p>연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다. 그렇지 않으면 외래 키 제약조건으로 인해, 데이터베이스에서 오류가 발생한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// 회원1 연관관계 제거</span>
<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span> <span class="c1">// 회원2 연관관계 제거</span>
<span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">team</span><span class="o">);</span>       <span class="c1">// 팀 삭제</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="53-양방향-연관관계">5.3 양방향 연관관계</h2>
<p><strong>객체</strong></p>
<center><img src="/assets/images/posts/books/2/5_3_양방향객체연관관계1.png" width="100%" height="100%" /></center>

<ul>
  <li>회원과 팀은 다대일 관계</li>
  <li>팀에서 회원의 관계는 일대다 관계<br />
<br /></li>
</ul>

<p><strong>데이터베이스 테이블</strong></p>
<center><img src="/assets/images/posts/books/2/5_3_양방향테이블연관관계.png" width="100%" height="100%" /></center>

<ul>
  <li>데이터베이스 테이블은 외래 키 하나로 양방향 조회<br />
<br />
<br /></li>
</ul>

<h3 id="531-양방항-연관관계-매핑">5.3.1 양방항 연관관계 매핑</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>

    <span class="c1">// 연관 관계 매핑</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>

    <span class="c1">// @OneToMany 매핑 정보를 사용했다.</span>
    <span class="c1">// mappedBy 속성은 양방향 매핑일 때 사용하는데 반대쪽 매핑의 필드 이름을 값으로 주면 된다.</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"team"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;();</span>
    
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>  
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="54-연관관계-주인">5.4 연관관계 주인</h2>
<ul>
  <li>객체에는 양방향 연관관계라는 것이 없다.</li>
  <li>서로 다른 단방향 연관관계 2개를 양방향인 것처럼 보이게 할 뿐이다.</li>
  <li>엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 왜래 키는 하나다.</li>
  <li>JPA에서는 <strong>두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리해야 하는데 이것을 연관관계의 주인</strong>이라 한다.<br />
<br />
<br /></li>
</ul>

<h3 id="541-양방향-매핑의-규칙-연관관계의-주인">5.4.1 양방향 매핑의 규칙: 연관관계의 주인</h3>
<ul>
  <li>두 연관관계 중 하나를 연관관계 주인으로 정해야 한다.</li>
  <li>연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 왜래 키를 관리(등록,수정,삭제)할 수 있다.</li>
  <li>주인이 아닌 쪽은 읽기만 할 수 있다.<br />
<br /></li>
</ul>

<p><strong>mappedBy</strong></p>
<ul>
  <li>주인은 <code class="language-plaintext highlighter-rouge">mappedBy</code> 속성을 사용하지 않는다.</li>
  <li>주인이 아니면 <code class="language-plaintext highlighter-rouge">mappedBy</code> 속성을 사용해서 속성의 값으로 연관관계 주인을 지정한다. (‘내가 상대에게 매핑되었다’라고 생각하면 편함)<br />
<strong>연관관계 주인을 정한다는 것은 외래 키 관리자를 선택하는 것이다.</strong><br />
<br />
<br /></li>
</ul>

<h3 id="542-연관관계의-주인은-외래-키가-있는-곳">5.4.2 연관관계의 주인은 외래 키가 있는 곳</h3>
<center><img src="/assets/images/posts/books/2/5_4_연관관계의주인과반대편.png " width="100%" height="100%" /></center>

<ul>
  <li>연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 한다.</li>
  <li>다대일, 일대다 관계에서는 <strong>항상 다 쪽이 외래 키를 가진다</strong>.</li>
  <li>다 쪽인 <code class="language-plaintext highlighter-rouge">@ManyToOne</code>은 항상 연관관계의 주인이 되므로 <code class="language-plaintext highlighter-rouge">mappedBy</code>를 설정할 수 없다.</li>
  <li>따라서 <code class="language-plaintext highlighter-rouge">@ManyToOne</code>에는 <code class="language-plaintext highlighter-rouge">mappedBy</code> 속성이 없다.<br />
<br />
<br />
<br /></li>
</ul>

<h2 id="55-양방향-연관관계-저장">5.5 양방향 연관관계 저장</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSave</span><span class="o">()</span> <span class="o">{</span>

    <span class="c1">// 팀1 저장</span>
    <span class="nc">Team</span> <span class="n">team1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team1"</span><span class="o">,</span> <span class="s">"팀1"</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span>

    <span class="c1">// 회원1 저장</span>
    <span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member1"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">);</span>
    <span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정 member1 -&gt; team1</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>

    <span class="c1">// 회원2 저장</span>
    <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member2"</span><span class="o">,</span> <span class="s">"회원2"</span><span class="o">);</span>
    <span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정 member2 -&gt; team1</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 주인이 아닌 곳에 입력된 값은 외래 키에 영향을 주지 않는다. </span>
<span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span> <span class="c1">//무시(연관관계의 주인이 아님)</span>
<span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span> <span class="c1">//무시(연관관계의 주인이 아님)</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Member.team은 연관관계의 주인이다.</span>
<span class="c1">// 엔티티 매니저는 이곳에 입력된 값을 사용해 외래 키 관리한다.</span>
<span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정(연관관계의 주인)</span>
<span class="n">member2</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">//연관관계 설정(연관관계의 주인)</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="56-양방향-연관관계의-주의점">5.6 양방향 연관관계의 주의점</h2>
<p>가장 흔한 실수는 연관관계 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSaveNonOwner</span><span class="o">()</span> <span class="o">{</span>

    <span class="c1">// 회원1 저장</span>
    <span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member1"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>

    <span class="c1">// 회원2 저장</span>
    <span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="s">"member2"</span><span class="o">,</span> <span class="s">"회원2"</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>

    <span class="nc">Team</span> <span class="n">team1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team1"</span><span class="o">,</span> <span class="s">"팀1"</span><span class="o">);</span>

    <span class="c1">// 주인이 아닌 곳에 연관관계 설정</span>
    <span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>
    <span class="n">team2</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>

    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>조회 결과는 다음과 같다.</p>

<table>
  <thead>
    <tr>
      <th><strong>MEMBER_ID</strong></th>
      <th><strong>USERNAME</strong></th>
      <th><strong>TEAM_ID</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>member1</td>
      <td>회원1</td>
      <td>null</td>
    </tr>
    <tr>
      <td>member2</td>
      <td>회원2</td>
      <td>null</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h3 id="561-순수한-객체까지-고려한-양방향-연관관계">5.6.1 순수한 객체까지 고려한 양방향 연관관계</h3>
<p>그렇다면 정말 연관관계의 주인에만 값을 저장하고 주인이 아닌 곳에는 값을 저장하지 않아도 될까? <strong>객체 관점에서는 양쪽 방향 모두 값을 입력해주는 것이 가장 안전하다.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">// 회원 -&gt; 팀</span>
<span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span> <span class="c1">// 팀 -&gt; 회원</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="562-연관관계-편의-메소드">5.6.2 연관관계 편의 메소드</h3>
<p>한 번에 양방향 관계를 설정하는 메소드를 연관관계 편의 메소드라 한다. 이렇게 하면 실수도 줄어들고 좀 더 편하게 양방향 연관관계를 설정할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTeam</span><span class="o">(</span><span class="nc">Team</span> <span class="n">team</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">=</span> <span class="n">team</span><span class="o">;</span>
        <span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="563-연관관계-편의-메소드-작성-시-주의사항">5.6.3 연관관계 편의 메소드 작성 시 주의사항</h3>
<p>연관관계를 변경할 때는 기존 팀이 있으면 기존 팀과 회원의 연관관계를 삭제하는 코드를 추가해야 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">teamA</span><span class="o">);</span> <span class="c1">// 1</span>
<span class="n">member1</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="n">teamB</span><span class="o">);</span> <span class="c1">// 2</span>
<span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">teamA</span><span class="o">.</span><span class="na">getMember</span><span class="o">();</span> <span class="c1">// member1이 여전히 조회된다.</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTeam</span><span class="o">(</span><span class="nc">Team</span> <span class="n">team</span><span class="o">)</span> <span class="o">{</span>

    <span class="c1">// 기존 팀과 관계를 제거</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>    
    <span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">=</span> <span class="n">team</span><span class="o">;</span>
    <span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="57-정리">5.7 정리</h2>
<ul>
  <li>단방향 매핑은 언제나 연관관계 주인이다.</li>
  <li>양방향은 단방향에 주인이 아닌 연관관계를 하나 추가했을 뿐이다.</li>
  <li>양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것 뿐이다.</li>
  <li>주인의 반대편은 <code class="language-plaintext highlighter-rouge">mappedBy</code>로 주인을 지정해야 한다.</li>
  <li>주인의 반대편은 단순히 보여주는 일만 할 수 있다.</li>
  <li>연관관계 주인은 외래 키의 위치와 관련해서 정해야지 비즈니스 중요도로 접근하면 안된다.<br />
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="6-다양한-연관관계-매핑">6. 다양한 연관관계 매핑</h1>
<p>엔티티 연관관계를 매핑할 때 고려사항</p>

<ul>
  <li><strong>다중성</strong>
    <ul>
      <li>다대일(@ManyToOne)</li>
      <li>일대다(@OneToMany)</li>
      <li>일대일(@OneToOne)</li>
      <li>다대다(@ManyToMany)</li>
    </ul>
  </li>
  <li><strong>단방향, 양방향</strong>
    <ul>
      <li>단방향: 한쪽만 참조하는 것</li>
      <li>양방향: 양쪽이 서로 참조하는 것</li>
    </ul>
  </li>
  <li><strong>연관관계 주인</strong><br />
<br /></li>
</ul>

<h2 id="61-다대일">6.1 다대일</h2>
<p>데이터베이스 테이블의 일대다 관계에서 외래 키는 항상 다쪽에 있다. 따라서 객체 양방향 관계에서 연관관계의 주인은 항상 다쪽이다.<br />
<br />
<br /></p>

<h3 id="611-다대일-단방향-n1">6.1.1 다대일 단방향 [N:1]</h3>
<center><img src="/assets/images/posts/books/2/6_1_다대일단방향.png" width="100%" height="100%" /></center>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@ManyToOne</code> 어노테이션을 사용해서 다대일 관계를 매핑한다.</li>
  <li><code class="language-plaintext highlighter-rouge">@JoinColumn</code>은 필드를 외래 키와 매핑할 때 사용한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinCoulmn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="612-다대일-양방향-n1-1n">6.1.2 다대일 양방향 [N:1, 1:N]</h3>
<center><img src="/assets/images/posts/books/2/6_1_다대일양방향.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinCoulmn</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTeam</span><span class="o">(</span><span class="nc">Team</span> <span class="n">team</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">team</span> <span class="o">=</span> <span class="n">team</span><span class="o">;</span>

        <span class="c1">// 무한루프에 빠지지 않도록 체크</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="k">this</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">team</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"team"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addMember</span><span class="o">(</span><span class="nc">Member</span> <span class="n">member</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">members</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>

        <span class="c1">// 무한루프에 빠지지 않도록 체크</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">getTeam</span><span class="o">()</span> <span class="o">!=</span> <span class="k">this</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">member</span><span class="o">.</span><span class="na">setTeam</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>양방향은 외래 키가 있는 쪽이 연관관계 주인이다.</li>
  <li>양방향 연관관계는 항상 서로를 참조해야 한다.<br />
<br />
<br />
<br /></li>
</ul>

<h2 id="62-일대다">6.2 일대다</h2>
<p>일대다 관계는 엔티티를 하나 이상 참조할 수 있으므로 자바 컬렉션인 Collection, List, Set, Map 중에 하나를 사용해야 한다.</p>

<h3 id="621-일대다-단방향-1n">6.2.1 일대다 단방향 [1:N]</h3>
<center><img src="/assets/images/posts/books/2/6_1_일대다단방향.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@OneToMany</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span> <span class="c1">// MEMBER 테이블의 TEAM_ID (FK)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>일대다 관계에서는 일이 연관관계의 주인이다.</li>
  <li>일 쪽에서 외래키를 관리하겠다는 의미가 된다.</li>
  <li>일대 다 단방향 관계를 매핑할 때는 <code class="language-plaintext highlighter-rouge">@JoinColumn</code>을 명시해야 한다.</li>
  <li>그렇지 않으면 JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인 테이블 전략을 기본으로 사용한다.<br />
<br /></li>
</ul>

<p><strong>일대다 문제점</strong></p>
<ul>
  <li>엔티티를 매핑한 테이블이 아닌 다을 테이블의 외래 키를 관리해야 한다.</li>
  <li>성능 문제</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">member1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Memeber</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
<span class="nc">Member</span> <span class="n">member2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Memeber</span><span class="o">(</span><span class="s">"member2"</span><span class="o">);</span>

<span class="nc">Team</span> <span class="n">team1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Team</span><span class="o">(</span><span class="s">"team1"</span><span class="o">);</span>
<span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span>
<span class="n">team1</span><span class="o">.</span><span class="na">getMembers</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span>

<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member1</span><span class="o">);</span> <span class="c1">// INSERT MEMBER1</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member2</span><span class="o">);</span> <span class="c1">// INSERT MEMBER2</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">team1</span><span class="o">);</span> <span class="c1">// INSERT TEAM, UPDATE MEMBER1, UPDATE MEMBER2</span>

<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
</code></pre></div></div>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 업데이트 쿼리가 추가된다.</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">Member</span> <span class="p">(</span><span class="n">MEMBER_ID</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="o">?</span><span class="p">);</span>
<span class="k">insert</span> <span class="k">into</span> <span class="n">Team</span> <span class="p">(</span><span class="n">TEAM_ID</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="o">?</span><span class="p">);</span>
<span class="k">update</span> <span class="n">Member</span> <span class="k">set</span> <span class="n">TEAM_ID</span><span class="o">=?</span> <span class="k">where</span> <span class="n">MEMBER_ID</span><span class="o">=?</span>
</code></pre></div></div>

<div class="notice--info">
<p>일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자</p>
</div>
<p><br />
<br /></p>

<h3 id="622-일대다-양방향-1n-n1">6.2.2 일대다 양방향 [1:N, N:1]</h3>
<center><img src="/assets/images/posts/books/2/6_2_일대다양방향.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@OneToMany</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinCoulmn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">,</span>
        <span class="n">insertable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">updatable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span> <span class="c1">// 읽기 전용 매핑</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>일대다 단방향 매핑이 가지는 단점을 그대로 가진다.<br />
<br />
<br />
<br /></p>

<h2 id="63-일대일-11">6.3 일대일 [1:1]</h2>
<p>일대일 관계 특징</p>
<ul>
  <li>일대일 관계는 그 반대도 일대일 관계다.</li>
  <li>테이블 관계에서 일대다, 다대일은 항상 다(N)쪽이 외래 키를 가진다. 반면 일대일 관계는 <strong>주 테이블이나 대상 테이블 둘 중 어느 곳이나 외래 키를 가질 수 있다.</strong><br />
<br />
<br /></li>
</ul>

<h3 id="631-주-테이블에-외래-키">6.3.1 주 테이블에 외래 키</h3>
<p>주 테이블에 외래 키가 있는 단방향 관계를 먼저 살펴보고, 양방향 관계도 살펴 보자.</p>

<p><strong>단방향</strong></p>
<center><img src="/assets/images/posts/books/2/6_3_주테이블단방향.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="c1">// @OneToOne을 사용해 일대일 매핑한다.</span>
    <span class="nd">@OneToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"LOCKER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Locker</span> <span class="n">locker</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Locker</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"LOCKER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>양방향</strong></p>
<center><img src="/assets/images/posts/books/2/6_3_주테이블양방향.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@OneToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"LOCKER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Locker</span> <span class="n">locker</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Locker</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"LOCKER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@OneToOne</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"locker"</span><span class="o">)</span> <span class="c1">// 연관관계 주인 필드명을 선언</span>
    <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>

    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="632-대상-테이블에-외래-키">6.3.2 대상 테이블에 외래 키</h3>
<p>대상 테이블에 외래 키가 있는 일대일 관계를 알아본다.</p>

<p><strong>단방향</strong></p>
<center><img src="/assets/images/posts/books/2/6_3_대상테이블단방향.png" width="100%" height="100%" /></center>
<p>일대일 단방향은 이런 매핑을 허용하지 않는다.<br />
<br /></p>

<p><strong>양방향</strong></p>
<center><img src="/assets/images/posts/books/2/6_3_대상테이블양방향.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@OneToOne</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"member"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Locker</span> <span class="n">locker</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Locker</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"LOCKER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@OneToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>

    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>일대일 매핑에서 대상 테이블에 외래 키를 두고 싶으면 이렇게 양방향으로 매핑한다.<br />
<br />
<br />
<br /></p>

<h2 id="64-다대다-nn">6.4 다대다 [N:N]</h2>
<center><img src="/assets/images/posts/books/2/6_4_다대다1.png" width="100%" height="100%" /></center>
<p>테이블 2개로는 다대다 관계를 표현할 수 없다.<br />
<br /></p>

<center><img src="/assets/images/posts/books/2/6_4_다대다2.png" width="100%" height="100%" /></center>
<p>중간에 연결 테이블을 추가해야 한다.<br />
<br />
<br /></p>

<h3 id="641-다대다-단방향">6.4.1 다대다: 단방향</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToMany</span>
    <span class="nd">@JoinTable</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_PRODUCT"</span><span class="o">,</span> <span class="c1">// 연결 테이블 지정</span>
        <span class="n">joinColumn</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">),</span> <span class="c1">// 현재 엔티티와 매핑할 연결 테이블의 조인 컬럼</span>
        <span class="n">inverseJoinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PRODUCT_ID"</span><span class="o">)</span> <span class="c1">// 상대 엔티티와 매핑할 연결 테이블의 조인 컬럼</span>
    <span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;();</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PRODUCT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="642-다대다-양방향">6.4.2 다대다: 양방향</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToMany</span>
    <span class="nd">@JoinTable</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_PRODUCT"</span><span class="o">,</span> <span class="c1">// 연결 테이블 지정</span>
        <span class="n">joinColumn</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">),</span> <span class="c1">// 현재 엔티티와 매핑할 연결 테이블의 조인 컬럼</span>
        <span class="n">inverseJoinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PRODUCT_ID"</span><span class="o">)</span> <span class="c1">// 상대 엔티티와 매핑할 연결 테이블의 조인 컬럼</span>
    <span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;();</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PRODUCT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"products"</span><span class="o">)</span> <span class="c1">// 역방향 추가</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="643-다대다-매핑의-한계와-극복-연결-엔티티-사용">6.4.3 다대다: 매핑의 한계와 극복, 연결 엔티티 사용</h3>
<p>연결테이블의 기본 키를 <code class="language-plaintext highlighter-rouge">@IdClass</code> 사용한 복합 키 사용 예제라서 넘김.<br />
<br />
<br /></p>

<h3 id="644-다대다-새로운-기본-키-사용">6.4.4 다대다: 새로운 기본 키 사용</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@ManyToMany</code>는 편리하지만, 실무에서 사용하기에는 한계가 있다.</li>
  <li>보통은 <strong>연결 테이블에 새로운 컬럼이 추가되기 마련</strong>이다.</li>
  <li>결국 <strong>연결 테이블을 매핑하는 연결 엔티티를 만들고 일대다, 다대일 관계로 풀어야 한다</strong>.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"member"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberProduct</span><span class="o">&gt;</span> <span class="n">memberProducts</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PRODUCT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="c1">// 상품 엔티티에서 회원상품 엔티티로 객체 그래프 탐색 기능이 필요 없다 판단.</span>
    <span class="c1">// 연관관계를 만들지 않았다.</span>
    <span class="c1">// @OneToMany(mappedBy = "product")</span>
    <span class="c1">// private List&lt;MemberProduct&gt; memberProducts = new ArrayList&lt;&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberProduct</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PRODUCT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Product</span> <span class="n">product</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="645-다대다-연관관계-정리">6.4.5 다대다 연관관계 정리</h3>
<ul>
  <li>다대다 관계를 일대다, 다대일 관계로 풀어낸다.</li>
  <li>연결 테이블을 만들 때 식별자를 어떻게 구성할지 선택한다.
    <ul>
      <li>식별 관계: 받아온 식별자를 기본 키 + 외래 키로 사용한다.</li>
      <li>비식별 관계: 받아온 식별자는 외래 키로만 사용하고 새로운 식별자를 추가한다. 추천 👍<br />
<br />
<br />
<br />
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h1 id="7-고급-매핑">7. 고급 매핑</h1>
<p>다룰 내용은 다음과 같다.</p>
<ul>
  <li><strong>상속 관계 매핑</strong>: 객체의 상속 관계를 데이터베이스에 어떻게 매핑하는지</li>
  <li><strong>@MappedSuperclass</strong>: 등록일, 수정일 같이 여러 엔티티에서 공통으로 사용하는 매핑 정보만 상속받고 싶을 때</li>
  <li><strong>복합 키와 식별 관계 매핑</strong>: 데이터베이스의 식별자가 하나 이상일 때 매핑하는 방법</li>
  <li><strong>조인 테이블</strong>: 연결 테이블을 매핑하는 방법</li>
  <li><strong>엔티티 하나에 여러 테이블 매핑</strong>하는 방법<br />
<br />
<br /></li>
</ul>

<h2 id="71-상속-관계-매핑">7.1 상속 관계 매핑</h2>
<center><img src="/assets/images/posts/books/2/7_1_객체상속모델.png" width="100%" height="100%" /></center>

<p><br /></p>

<p>슈퍼타입 서브타입 논리 모델을 테이블로 구현하는 3가지 방법</p>
<ul>
  <li><strong>각각의 테이블로 변환</strong>: JPA에서는 <strong>조인 전략</strong>이라 한다.</li>
  <li><strong>통합 테이블로 변환</strong>: JPA에서는 <strong>단일 테이블 전략</strong>이라 한다.</li>
  <li><strong>서브타입 테이블로 변환</strong>: JPA에서는 <strong>구현 클래스마다 테이블 전략</strong>이라 한다.<br />
<br />
<br /></li>
</ul>

<h3 id="711-조인-전략">7.1.1 조인 전략</h3>
<p>엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략</p>
<center><img src="/assets/images/posts/books/2/7_1_조인전략.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Inheritance</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">InheritanceType</span><span class="o">.</span><span class="na">JOIN</span><span class="o">)</span> <span class="c1">// 부모 클래스에 상속 매핑, 전략 지정</span>
<span class="nd">@DiscriminatorColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"DTYPE"</span><span class="o">)</span> <span class="c1">// 부모 클래스에 구분 컬럼 지정</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ITEM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span> <span class="c1">//이름</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>   <span class="c1">//가격</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"A"</span><span class="o">)</span> <span class="c1">// 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Album</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">artist</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"M"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Movie</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">director</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">actor</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"B"</span><span class="o">)</span>
<span class="nd">@PrimaryKeyJoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BOOK_ID"</span><span class="o">)</span> <span class="c1">// 기본 키 컬럼명 변경, 기본값은 부모 테이블 ID 컬럼명</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">isbn</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><strong>장점</strong></p>
<ul>
  <li>테이블이 정규화된다.</li>
  <li>외래 키 참조 무결성 제약조건을 활용할 수 있다.</li>
  <li>저장공간을 효율적으로 사용한다.</li>
</ul>

<p><strong>단점</strong></p>
<ul>
  <li>조회할 때 조인이 많이 사용되어 성능이 저하될 수 있다.</li>
  <li>조회 쿼리가 복잡하다.</li>
  <li>데이터를 등록할 때 INSERT SQL이 두 번 실행된다.</li>
</ul>

<p><strong>특징</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@DiscriminatorColumn</code> 없이도 동작할 수 있다.</li>
</ul>

<p><strong>관련 어노테이션</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@PrimaryKeyJoinColumn</code>, <code class="language-plaintext highlighter-rouge">@DiscriminatorColumn</code>, <code class="language-plaintext highlighter-rouge">@DiscriminatorValue</code><br />
<br />
<br />
<br /></li>
</ul>

<h3 id="712-단일-테이블-전략">7.1.2 단일 테이블 전략</h3>
<center><img src="/assets/images/posts/books/2/7_1_단일테이블전략.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Inheritance</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">InheritanceType</span><span class="o">.</span><span class="na">SINGLE_TABLE</span><span class="o">)</span> <span class="c1">// 부모 클래스에 상속 매핑, 전략 지정</span>
<span class="nd">@DiscriminatorColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"DTYPE"</span><span class="o">)</span> <span class="c1">// 부모 클래스에 구분 컬럼 지정</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ITEM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"A"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Album</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{...}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"M"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Movie</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{...}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"B"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{...}</span>
</code></pre></div></div>

<p><strong>장점</strong></p>
<ul>
  <li>조인이 필요 없으므로 조회 성능이 빠르다.</li>
  <li>조회 쿼리가 단순하다.</li>
</ul>

<p><strong>단점</strong></p>
<ul>
  <li>자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다.</li>
  <li>단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 그러므로 상황에 따라서는 조회 성능이 오히려 느려질 수 있다.</li>
</ul>

<p><strong>특징</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@DiscriminatorColumn</code>을 꼭 설정해야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">@DiscriminatorValue</code>를 지정하지 않으면 기본으로 엔티티 이름을 사용한다.</li>
</ul>

<p><br />
<br /></p>

<h3 id="713-구현-클래스마다-테이블-전략">7.1.3 구현 클래스마다 테이블 전략</h3>
<center><img src="/assets/images/posts/books/2/7_1_구현클래스마다테이블전략.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Inheritance</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">InheritanceType</span><span class="o">.</span><span class="na">TABLE_PER_CLASS</span><span class="o">)</span>
<span class="nd">@DiscriminatorColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"DTYPE"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ITEM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"A"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Album</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{...}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"M"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Movie</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{...}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"B"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{...}</span>
</code></pre></div></div>

<p><strong>일반적으로 추천하지 않는 전략이다.</strong></p>

<p><strong>장점</strong></p>
<ul>
  <li>서브 타입을 구분해서 처리할 때 효과적이다.</li>
  <li>not null 제약 조건을 사용할 수 있다.</li>
</ul>

<p><strong>단점</strong></p>
<ul>
  <li>여러 자식 테이블을 함께 조회할 때 성능이 느리다. (UNION을 사용해야 한다)</li>
  <li>자식 테이블을 통합해서 쿼리하기 어렵다.</li>
</ul>

<p><strong>특징</strong></p>
<ul>
  <li>구분 컬럼을 사용하지 않는다.<br />
<br />
<br />
<br /></li>
</ul>

<h2 id="72-mappedsuperclass">7.2 @MappedSuperclass</h2>
<p><strong>부모 클래스는 테이블과 매핑하지 않고 자식 클래스에게 매핑 정보만 제공</strong>하고 싶으면 <code class="language-plaintext highlighter-rouge">@MappedSuperclass</code>을 사용한다.</p>

<center><img src="/assets/images/posts/books/2/7_2_mappedSuperclass.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 공통 매핑 정보 정의</span>
<span class="nd">@MappedSuperclass</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">BaseEntity</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="kd">extends</span> <span class="nc">BaseEntity</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>
<span class="o">}</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Seller</span> <span class="kd">extends</span> <span class="nc">BaseEntity</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">shopName</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>연관관계를 재정의 하려면 <code class="language-plaintext highlighter-rouge">@AssociationOverrides</code>, <code class="language-plaintext highlighter-rouge">@AssociationOverride</code> 사용한다.</li>
  <li><strong>부모로부터 물려받은 매핑 정보를 재정의 하려면 <code class="language-plaintext highlighter-rouge">@AttributeOverrides</code>, <code class="language-plaintext highlighter-rouge">@AttributeOverride</code> 사용한다.</strong></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 매핑 정보 재정의</span>
<span class="c1">// 부모에게 상속받은 id 속성의 컬럼명을 MEMBER_ID로 재정의</span>
<span class="nd">@Entity</span>
<span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"id"</span><span class="o">,</span> <span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">))</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="kd">extends</span> <span class="nc">BaseEntity</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 둘 이상의 매핑 정보 재정의</span>
<span class="nd">@Entity</span>
<span class="nd">@AttributeOverrides</span><span class="o">({</span>
    <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"id"</span><span class="o">,</span> <span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)),</span>
    <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"name"</span><span class="o">,</span> <span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_NAME"</span><span class="o">))</span>
<span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="kd">extends</span> <span class="nc">BaseEntity</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>@MappedSuperclass 특징</strong></p>
<ul>
  <li>테이블과 매핑되지 않는다.</li>
  <li>자식 클래스에게 엔티티의 매핑 정보를 상속하기 위해 사용한다.</li>
  <li>엔티티가 아니므로 <code class="language-plaintext highlighter-rouge">em.find()</code>, <code class="language-plaintext highlighter-rouge">JPQL</code>에서 사용할 수 없다.</li>
  <li>직접 생성해서 사용할 일이 거의 없으므로 추상 클래스로 만드는 것을 권장한다.</li>
  <li>등록일자, 수정일자, 등록자, 수정자 같은 곹오 속성을 효과적으로 관리할 수 있다.<br />
<br />
<br />
<br /></li>
</ul>

<h2 id="73-복합-키와-식별-관계-매핑">7.3 복합 키와 식별 관계 매핑</h2>
<p>복합 키를 매핑하는 방법과 식별 관계, 비식별 관계를 매핑하는 방법을 알아본다.<br />
<br /></p>

<h3 id="731-식별-관계-vs-비식별-관계">7.3.1 식별 관계 vs 비식별 관계</h3>
<p><strong>식별 관계</strong><br />
부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용하는 관계다.</p>
<center><img src="/assets/images/posts/books/2/7_3_식별관계.png" width="100%" height="100%" /></center>
<p><br /></p>

<p><strong>비식별 관계</strong><br />
부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계다.</p>
<center><img src="/assets/images/posts/books/2/7_3_비식별관계.png" width="100%" height="100%" /></center>
<ul>
  <li>필수적 비식별 관계(Mandatory): 외래 키에 null을 허용하지 않는다. 연관관계를 필수적으로 맺어야 한다.</li>
  <li>선택적 비식별 관계(Optional): 외래 키에 null을 허용한다. 연관관계를 맺을지 말지 선택할 수 있다.</li>
</ul>

<div class="notice--info">
<p><strong>참고</strong><br />
최근에는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별 관계를 사용하는 추세</p>
</div>
<p><br />
<br /></p>

<h3 id="732-복합-키-비식별-관계-매핑">7.3.2 복합 키: 비식별 관계 매핑</h3>
<p>JPA는 복합 키를 지원하기 위해 다음 2가지 방법을 제공한다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@IdClass</code>: 관계형 데이터베이스에 가까운 방법</li>
  <li><code class="language-plaintext highlighter-rouge">@EmbeddedId</code>: 객체지향에 가까운 방법<br />
<br /></li>
</ul>

<p><strong>@IdClass</strong></p>
<center><img src="/assets/images/posts/books/2/7_3_복합키테이블.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@IdClass</span><span class="o">(</span><span class="nc">ParentId</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID1"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id1</span><span class="o">;</span>

    <span class="nd">@Id</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID2"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id1</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParentId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id1</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id2</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ParentId</span><span class="o">()</span> <span class="o">{}</span>

    <span class="o">...</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{...}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{...}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>@IdClass를 사용할 때 식별자 클래스는 다음 조건을 만족해야 한다.</strong></p>
<ul>
  <li>식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Serializable</code> 인터페이스를 구현해야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">equals</code>, <code class="language-plaintext highlighter-rouge">hashCode</code>를 구현해야 한다.</li>
  <li>기본 생성자가 있어야 한다.</li>
  <li>식별자 클래스는 <code class="language-plaintext highlighter-rouge">public</code>이어야 한다.<br />
<br /></li>
</ul>

<p><strong>사용방법</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 저장</span>
<span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Parent</span><span class="o">();</span>
<span class="n">parent</span><span class="o">.</span><span class="na">setId1</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>
<span class="n">parent</span><span class="o">.</span><span class="na">setId2</span><span class="o">(</span><span class="s">"2"</span><span class="o">);</span>

<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 조회</span>
<span class="nc">ParentId</span> <span class="n">parentId</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParentId</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">);</span>
<span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Parent</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">parentId</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>자식 클래스</strong><br />
자식 테이블에서 외래 키 매핑 방법</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumns</span><span class="o">({</span>
        <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID1"</span><span class="o">,</span> <span class="n">referencedColumnName</span> <span class="o">=</span> <span class="s">"PARENT_ID1"</span><span class="o">),</span>
        <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID2"</span><span class="o">,</span> <span class="n">referencedColumnName</span> <span class="o">=</span> <span class="s">"PARENT_ID2"</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="kd">private</span> <span class="nc">Parent</span> <span class="n">parent</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<p><strong>@EmbeddedId</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

    <span class="nd">@EmbeddedId</span>
    <span class="kd">private</span> <span class="nc">ParentId</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParentId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID1"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id1</span><span class="o">;</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID2"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id2</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ParentId</span><span class="o">()</span> <span class="o">{}</span>

    <span class="o">...</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{...}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{...}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>@EmbeddedId를 사용할 때 식별자 클래스는 다음 조건을 만족해야 한다.</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@Embeddable</code> 어노테이션을 붙여주어야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Serializable</code> 인터페이스를 구현해야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">equals</code>, <code class="language-plaintext highlighter-rouge">hashCode</code>를 구현해야 한다.</li>
  <li>기본 생성자가 있어야 한다.</li>
  <li>식별자 클래스는 <code class="language-plaintext highlighter-rouge">public</code>이어야 한다.<br />
<br /></li>
</ul>

<p><strong>사용방법</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 저장</span>
<span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Parent</span><span class="o">();</span>
<span class="nc">ParentId</span> <span class="n">parentId</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParentId</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">);</span>
<span class="n">parent</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="n">parentId</span><span class="o">);</span>

<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 조회</span>
<span class="nc">ParentId</span> <span class="n">parentId</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ParentId</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">);</span>
<span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Parent</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">parentId</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<p><strong>@IdClass vs @EmbeddedId</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@IdClass</code>: 관계형 데이터베이스에 가까운 방법</li>
  <li><code class="language-plaintext highlighter-rouge">@EmbeddedId</code>: 객체지향에 가까운 방법</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JPQL</span>
<span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select p.id.id1, p.id.id2 from Parent p"</span><span class="o">);</span> <span class="c1">// @EmbeddedId</span>
<span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select p.id1, p.id2 from Parent p"</span><span class="o">);</span> <span class="c1">// @IdClass</span>
</code></pre></div></div>

<div class="notice--info">
<p><strong>참고</strong><br />
복합 키에는 <code class="language-plaintext highlighter-rouge">@GenerateValue</code>를 사용할 수 없다. 복합 키를 구성하는 여러 컬럼중 하나에도 사용할 수 없다.</p>
</div>
<p><br />
<br />
<br /></p>

<h3 id="733-복합-키-식별-관계-매핑">7.3.3 복합 키: 식별 관계 매핑</h3>
<center><img src="/assets/images/posts/books/2/7_3_식별관계구현.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 부모</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 자식</span>
<span class="nd">@Entity</span>
<span class="nd">@IdClass</span><span class="o">(</span><span class="nc">ChildId</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Parent</span> <span class="n">parent</span><span class="o">;</span>

    <span class="nd">@Id</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">childId</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 자식 ID</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChildId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">parent</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">childId</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 손자</span>
<span class="nd">@Entity</span>
<span class="nd">@IdClass</span><span class="o">(</span><span class="nc">GrandChildId</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GrandChild</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumns</span><span class="o">({</span>
        <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">),</span>
        <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="kd">private</span> <span class="nc">Child</span> <span class="n">child</span><span class="o">;</span>

    <span class="nd">@Id</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"GRANDCHILD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 손자 ID</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GrandChildId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="nc">ChildId</span> <span class="n">child</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<p><strong>@EmbeddedId와 식별 관계</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 부모</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 자식</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

    <span class="nd">@EmbeddedId</span>
    <span class="kd">private</span> <span class="nc">ChildId</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@MapsId</span><span class="o">(</span><span class="s">"parentId"</span><span class="o">)</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Parent</span> <span class="n">parent</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 자식 ID</span>
<span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChildId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">parentId</span><span class="o">;</span> <span class="c1">// @MapsId("parentId")로 매핑</span>
    
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 손자</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GrandChild</span> <span class="o">{</span>

    <span class="nd">@EmbeddedId</span>
    <span class="kd">private</span> <span class="nc">GrandChildId</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@MapsId</span><span class="o">(</span><span class="s">"childId"</span><span class="o">)</span>
    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumns</span><span class="o">({</span>
        <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">),</span>
        <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="kd">private</span> <span class="nc">Child</span> <span class="n">child</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// 손자 ID</span>
<span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GrandChildId</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="nc">ChildId</span> <span class="n">childId</span><span class="o">;</span> <span class="c1">// @MapsId("childId")로 매핑</span>
    
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"GRANDCHILD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br /></p>

<h3 id="734-비식별-관계로-구현">7.3.4 비식별 관계로 구현</h3>
<center><img src="/assets/images/posts/books/2/7_3_비식별관계구현.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 부모</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 자식</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Parent</span> <span class="n">parent</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 손자</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">GrandChild</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"GRANDCHILD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Child</span> <span class="n">child</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>식별 관계의 복합 키를 사용한 코드와 비교하면 매핑도 쉽고 코드도 단순하다.<br />
<br />
<br /></p>

<h3 id="735-일대일-식별-관계">7.3.5 일대일 식별 관계</h3>
<center><img src="/assets/images/posts/books/2/7_3_식별관계일대일.png" width="100%" height="100%" /></center>

<p>일대일 식별 관계는 자식 테이블의 기본 키 값으로 부모 테이블의 기본 키 값만 사용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 부모</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@OneToOne</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"board"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">BoardDetail</span> <span class="n">boardDetail</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoardDetail</span> <span class="o">{</span>

    <span class="nd">@Id</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">boardId</span><span class="o">;</span>

    <span class="c1">// 식별자가 단순히 컬럼 하나면 @MapsId를 사용하고 속성 값은 비워두면 된다.</span>
    <span class="nd">@MapsId</span> <span class="c1">// BoardDetail.boardId 매핑</span>
    <span class="nd">@OneToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Board</span> <span class="n">board</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>사용방법</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Board</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Board</span><span class="o">();</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>

<span class="nc">BoardDetail</span> <span class="n">boardDetail</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BoardDetail</span><span class="o">();</span>
<span class="n">boardDetail</span><span class="o">.</span><span class="na">setBoard</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">boardDetail</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="736-식별-비식별-관계의-장단점">7.3.6 식별, 비식별 관계의 장단점</h3>

<p><strong>식별 관계 장점</strong></p>
<ul>
  <li>특정 상황에서 조인 없이 하위 테이블만으로 검색할 수 있다.</li>
</ul>

<p><strong>식별 관계 단점</strong></p>
<ul>
  <li>식별 관계는 부모 테이블의 기본 키를 자식 테이블로 전파하면서 자식 테이블의 기본 키 컬럼이 점점 늘어난다.
    <ul>
      <li><strong>SQL복잡, 기본 키 인덱스가 커짐</strong></li>
    </ul>
  </li>
  <li>식별 관계는 복합 기본 키를 만들어야 하는 경우가 많다.</li>
  <li>식별 관계를 사용할 때 기본 키로 <strong>비즈니스 의미가 있는 자연 키 컬럼을 조합 하는 경우가 많다</strong>.
    <ul>
      <li><strong>비즈니스 요구사항은 언제나 변할 수 있다</strong>.</li>
    </ul>
  </li>
  <li>식별 관계는 <strong>테이블 구조가 유연하지 못하다</strong>.</li>
  <li>식별 관계는 일대일 관계를 제외하고 별도의 복합 키 클래스를 사용한다.
    <ul>
      <li><strong>기본 키 매핑에 많은 노력이 필요하다.</strong><br />
<br /></li>
    </ul>
  </li>
</ul>

<p><strong>비식별 관계 장점</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@GenerateValue</code>처럼 편리한 대리 키 생성 방법 사용 가능</li>
  <li>식별자 컬럼이 하나여서 매핑이 쉽다.</li>
</ul>

<p><strong>비식별 관계 단점</strong></p>
<ul>
  <li>JPQL 조회시 길어질 수 있다.<br />
<br /></li>
</ul>

<div class="notice--info">
<p><strong>결론</strong><br />
비식별 관계를 사용하고 기본 키는 <code class="language-plaintext highlighter-rouge">Long</code> 타입의 대리 키를 사용한다.</p>
</div>
<p><br />
<br />
<br /></p>

<h2 id="74-조인-테이블">7.4 조인 테이블</h2>
<p>데이터베이스 테이블의 연관관계를 설계하는 방법은 크게 2가지다.</p>

<p><strong>조인 컬럼</strong></p>
<center><img src="/assets/images/posts/books/2/7_4_조인컬럼사용.png" width="100%" height="100%" /></center>
<p><br />
<br /></p>

<p><strong>조인 테이블</strong></p>
<center><img src="/assets/images/posts/books/2/7_4_조인테이블사용.png" width="100%" height="100%" /></center>

<div class="notice--info">
<p><strong>추천 방법</strong><br />
기본은 조인 컬럼을 사용하고 필요하다고 판단되면 조인 테이블을 사용하자.</p>
</div>
<p><br />
<br />
<br /></p>

<h3 id="741-일대일-조인-테이블">7.4.1 일대일 조인 테이블</h3>
<center><img src="/assets/images/posts/books/2/7_4_조인테이블일대일.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 부모</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>


    <span class="nd">@OneToOne</span>
    <span class="nd">@JoinTable</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_CHILD"</span><span class="o">,</span>
        <span class="n">joinColumn</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">),</span>
        <span class="n">inverseJoinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Child</span> <span class="n">child</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 자식</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="c1">// 양방향으로 매핑하려면 다음 코드를 추가한다.</span>
    <span class="c1">// @OneToOne(mappedBy = "child")</span>
    <span class="c1">// private Parent parent;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="742-일대다-조인-테이블">7.4.2 일대다 조인 테이블</h3>
<center><img src="/assets/images/posts/books/2/7_4_조인테이블일대다.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 부모</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@OneToMany</span>
    <span class="nd">@JoinTable</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_CHILD"</span><span class="o">,</span>
        <span class="n">joinColumn</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">),</span>
        <span class="n">inverseJoinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;</span> <span class="n">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 자식</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="742-다대일-조인-테이블">7.4.2 다대일 조인 테이블</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 부모</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"parent"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;</span> <span class="n">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 자식</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinTable</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_CHILD"</span><span class="o">,</span>
        <span class="n">joinColumn</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">),</span>
        <span class="n">inverseJoinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
    <span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Parent</span> <span class="n">parent</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="744-다대다-조인-테이블">7.4.4 다대다 조인 테이블</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 부모</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToMany</span>
    <span class="nd">@JoinTable</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_CHILD"</span><span class="o">,</span>
        <span class="n">joinColumn</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"PARENT_ID"</span><span class="o">),</span>
        <span class="n">inverseJoinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;</span> <span class="n">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 자식</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Child</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"CHILD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="75-엔티티-하나에-여러-테이블-매핑">7.5 엔티티 하나에 여러 테이블 매핑</h2>
<p><code class="language-plaintext highlighter-rouge">@SecondaryTable</code>을 사용하면 한 엔티티에 여러 테이블을 매핑할 수 있다.</p>

<center><img src="/assets/images/posts/books/2/7_5_하나의엔티티에여러테이블매핑.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"BOARD"</span><span class="o">)</span>
<span class="nd">@SecondaryTable</span><span class="o">(</span> 
    <span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_DETAIL"</span><span class="o">,</span>
    <span class="n">pkJoinColumns</span> <span class="o">=</span> <span class="nd">@PrimaryKeyJoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_DETAIL_ID"</span><span class="o">)</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>
    
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_DETAIL"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">content</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@SecondaryTable.name</code>: 매핑할 다른 테이블 이름</li>
  <li><code class="language-plaintext highlighter-rouge">@SecondaryTable.pkJoinColumns</code>: 매핑할 다른 테이블의 기본 키 컬럼 속성</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 여러개 가능</span>
<span class="nd">@SecondaryTables</span><span class="o">({</span>
    <span class="nd">@SecondaryTable</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"BOARD_DETAIL"</span><span class="o">),</span>
    <span class="nd">@SecondaryTable</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"BOARD_FILE"</span><span class="o">)</span>
<span class="o">})</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">@SecondaryTable</code>을 사용하는 것보단 <strong>테이블당 엔티티를 각각 만들어서 사용하는 것을 권장한다.</strong></p>

<p><br />
<br />
<br />
<br />
<br /></p>

<h1 id="8-프록시와-연관관계-관리">8. 프록시와 연관관계 관리</h1>
<ul>
  <li>프록시와 즉시로딩, 지연로딩</li>
  <li>영속성 전이와 고아 객체</li>
</ul>

<h2 id="81-프록시">8.1 프록시</h2>
<ul>
  <li>엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다.</li>
  <li>사용하지 않는 엔티티를 함께 조회해 두는 것은 효율적이지 않다.</li>
  <li>JPA는 이런 문제를 해결하려고 지연 로딩을 제공한다.</li>
  <li>지연 로딩이란 실제 사용하는 시점에 데이터베이스를 조회하는 것이다.</li>
  <li>지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 가짜 객체가 필요한데 이것을 프록시 객체라 한다.<br />
<br /></li>
</ul>

<h3 id="811-프록시-기초">8.1.1 프록시 기초</h3>
<p><strong>프록시의 특징</strong></p>
<center><img src="/assets/images/posts/books/2/8_1_프록시구조.png" width="100%" height="100%" /></center>

<ul>
  <li>프록시 클래스는 실제 클래스를 상속 받아서 만들어진다.</li>
  <li>따라서 사용하는 입장에서는 이것이 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.</li>
  <li>프록시 객체는 실제 객체에 대한 참조를 보관한다.</li>
  <li>프록시 객체의 메소드를 호출하면, 프록시 객체는 실제 객체의 메소드를 호출한다.</li>
  <li>프록시 객체는 처음 사용할 때 한 번만 초기화 한다.<br />
<br /></li>
</ul>

<p><strong>프록시 객체의 초기화</strong></p>
<center><img src="/assets/images/posts/books/2/8_1_프록시초기화.png" width="100%" height="100%" /></center>

<ul>
  <li>프록시 객체는 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.</li>
  <li>이를 프록시 객체의 초기화라 한다.<br />
<br /></li>
</ul>

<p><strong>준영속 상태와 초기화</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// em.getReference()를 호출하면 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미룬다.</span>
<span class="c1">// MemberProxy 반환</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"id1"</span><span class="o">);</span>

<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span> <span class="c1">// 영속성 컨텍스트 종료</span>
<span class="n">member</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span> <span class="c1">// 준영속 상태에서 초기화 시도</span>
                  <span class="c1">// org.hibernate.LazyInitializationException 발생</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="812-프록시와-식별자">8.1.2 프록시와 식별자</h3>
<p>엔티티를 프록시로 조회할 때 식별자(PK) 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Team</span> <span class="n">team</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Team</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"team1"</span><span class="o">);</span> <span class="c1">// 식별자 보관</span>
<span class="n">team</span><span class="o">.</span><span class="na">getId</span><span class="o">();</span> <span class="c1">// 초기화되지 않음</span>
</code></pre></div></div>
<p>단 <code class="language-plaintext highlighter-rouge">@Access(AccessType.PROPERTY)</code>일 때만 위처럼 동작하고, <code class="language-plaintext highlighter-rouge">@Access(AccessType.FIELD)</code>로 설정하면 프록시 객체를 초기화 한다.<br />
<br />
<br /></p>

<h3 id="813-프록시-확인">8.1.3 프록시 확인</h3>
<p>JPA가 제공하는 <code class="language-plaintext highlighter-rouge">PersistenceUnitUtil.isLoaded(Object entity)</code> 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">boolean</span> <span class="n">isLoad</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getEntityManagerFactory</span><span class="o">()</span>
                <span class="o">.</span><span class="na">getPersistenceUnitUtil</span><span class="o">().</span><span class="na">isLoaded</span><span class="o">(</span><span class="n">entity</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="82-즉시-로딩과-지연-로딩">8.2 즉시 로딩과 지연 로딩</h2>
<p>JPA는 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 다음 두 가지 방법을 제공한다.</p>
<ul>
  <li>즉시 로딩: 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.
    <ul>
      <li>설정 방법: <code class="language-plaintext highlighter-rouge">@ManyToOne(fetch = FetchType.EAGER)</code></li>
    </ul>
  </li>
  <li>지연 로딩: 연관된 엔티티를 실제 사용할 때 조회한다.
    <ul>
      <li>설정 방법: <code class="language-plaintext highlighter-rouge">@ManyToOne(fetch = FetchType.LAZY)</code><br />
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h3 id="821-즉시-로딩">8.2.1 즉시 로딩</h3>
<p>즉시 로딩을 사용하려면 <code class="language-plaintext highlighter-rouge">@ManyToOne(fetch = FetchType.EAGER)</code>로 지정한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="822-지연-로딩">8.2.2 지연 로딩</h3>
<p>지연 로딩을 사용하려면 <code class="language-plaintext highlighter-rouge">@ManyToOne(fetch = FetchType.LAZY)</code>로 지정한다. 지연 로딩은 프록시 객체를 이용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TEAM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p class="notice--info"><strong>참고</strong><br />
조회 대상이 영속성 컨텍스트에 이미 있으면 프록시 객체를 사용할 이유가 없다. 따라서 실제 객체를 사용한다.</p>
<p><br /></p>

<h3 id="823-즉시-로딩-지연-로딩-정리">8.2.3 즉시 로딩, 지연 로딩 정리</h3>
<ul>
  <li>지연 로딩: 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.</li>
  <li>즉시 로딩: 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다.<br />
<br />
<br />
<br /></li>
</ul>

<h2 id="83-지연-로딩-활용">8.3 지연 로딩 활용</h2>
<p>연관된 엔티티가 자주 함께 사용되는지 아닌지에 따라 즉시 로딩, 지연 로딩을 결정한다.</p>

<h3 id="831-프록시와-컬렉션-래퍼">8.3.1 프록시와 컬렉션 래퍼</h3>
<p>컬렉션의 지연 로딩</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">member</span><span class="o">.</span><span class="na">getOrders</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">orders</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span> 

<span class="c1">// 출력</span>
<span class="c1">// org.hibernate.collection.internal.PersistenBag</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="832-jpa-기본-페치-전략">8.3.2 JPA 기본 페치 전략</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@ManyToOne</code>, <code class="language-plaintext highlighter-rouge">@OneToOne</code>: 즉시 로딩(FetchType.EAGER)</li>
  <li><code class="language-plaintext highlighter-rouge">@OneToMany</code>, <code class="language-plaintext highlighter-rouge">@ManyToMany</code>: 지연 로딩(FetchType.LAZY)</li>
</ul>

<p class="notice--info"><strong>추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것이다.</strong> 그리고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 한다.</p>
<p><br />
<br /></p>

<h3 id="833-컬렉션에-fetchtypeeager-사용-시-주의점">8.3.3 컬렉션에 FetchType.EAGER 사용 시 주의점</h3>
<p>컬렉션에 <code class="language-plaintext highlighter-rouge">FetchType.EAGER</code>를 사용할 경우 주의할 점은 다음과 같다.</p>
<ul>
  <li><strong>컬렉션을 즉시 로딩하는 것은 권장하지 않는다</strong>.
    <ul>
      <li>너무 많은 데이터를 반환할 수 있고, 결과적으로 <strong>성능이 저하될 수 있다</strong>.</li>
    </ul>
  </li>
  <li>컬렉션 즉시 로딩은 항상 <code class="language-plaintext highlighter-rouge">OUTER JOIN</code>을 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">@ManyToOne</code>, <code class="language-plaintext highlighter-rouge">@OneToOne</code>
    <ul>
      <li>(optional = false): 내부 조인</li>
      <li>(optional = true): 외부 조인</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">@OneToMany</code>, <code class="language-plaintext highlighter-rouge">@ManyToMany</code>
    <ul>
      <li>(optional = false): 외부 조인</li>
      <li>(optional = true): 내부 조인<br />
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h2 id="84-영속성-전이-cascade">8.4 영속성 전이: CASCADE</h2>
<p>특정 엔티티를 연속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이 기능을 사용한다. <strong>JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.</strong></p>

<h3 id="841-영속성-전이-저장">8.4.1 영속성 전이: 저장</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"parent"</span><span class="o">,</span> <span class="n">cascade</span> <span class="o">=</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">PERSIST</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;();</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Parent</span><span class="o">();</span>
<span class="nc">Child</span> <span class="n">child</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Child</span><span class="o">();</span>

<span class="n">child</span><span class="o">.</span><span class="na">setParent</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
<span class="n">parent</span><span class="o">.</span><span class="na">getChildren</span><span class="o">().</span><span class="na">add</span><span class="o">(</span><span class="n">child</span><span class="o">);</span>

<span class="c1">// Parent만 저장했지만, 영속성 전이에 의해 Child도 저장됨</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
</code></pre></div></div>
<p>영속성 전이는 연관관계를 매핑하는 것과는 아무 관련이 없다. 단지 <strong>엔티티를 영속화할 때 연관된 엔티티도 같이 영속화하는 편리함을 제공할 뿐이다.</strong><br />
<br /></p>

<h3 id="842-영속성-전이-삭제">8.4.2 영속성 전이: 삭제</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"parent"</span><span class="o">,</span> <span class="n">cascade</span> <span class="o">=</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">REMOVE</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;();</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Parent</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>

<span class="c1">// Parent만 삭제했지만, 영속성 전이에 의해 Child도 삭제됨</span>
<span class="n">em</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">parent</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="843-cascade의-종류">8.4.3 CASCADE의 종류</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">CascadeType</span> <span class="o">{</span>
    <span class="no">ALL</span><span class="o">,</span>        <span class="c1">// 모두 적용</span>
    <span class="no">PERSIST</span><span class="o">,</span>    <span class="c1">// 영속</span>
    <span class="no">MERGE</span><span class="o">,</span>      <span class="c1">// 병합</span>
    <span class="no">REMOVE</span><span class="o">,</span>     <span class="c1">// 삭제</span>
    <span class="no">REFRESH</span><span class="o">,</span>
    <span class="no">DETACH</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="85-고아-객체">8.5 고아 객체</h2>
<p>JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체(<code class="language-plaintext highlighter-rouge">ORPHAN</code>) 제거라 한다. <strong>부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제된다.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Parent</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mapeedBy</span> <span class="o">=</span> <span class="s">"parent"</span><span class="o">,</span> <span class="n">orphanRemoval</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Child</span><span class="o">&gt;();</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Parent</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Parent</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
<span class="n">parent</span><span class="o">.</span><span class="na">getChildren</span><span class="o">().</span><span class="na">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// 자식 엔티티를 컬렉션에서 삭제</span>

<span class="c1">// SQL</span>
<span class="no">DELETE</span> <span class="no">FROM</span> <span class="no">CHILD</span> <span class="no">WHERE</span> <span class="no">ID</span><span class="o">=?</span>
</code></pre></div></div>
<p>고아 객체 제거는 <strong>참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능</strong>이다. 또, 부모를 제거하면 자식도 같이 제거된다.<br />
<br />
<br /></p>

<h2 id="86-영속성-전이--고아-객체-생명-주기">8.6 영속성 전이 + 고아 객체, 생명 주기</h2>
<p><code class="language-plaintext highlighter-rouge">CascadeType.All + orphanRemoval = true</code>를 동시에 사용하면 어떻게 될까? 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리 할 수 있다.</p>
<ul>
  <li>자식을 저장하려면 부모에 등록하면 된다 (CASCADE)</li>
  <li>자식을 삭제하려면 부모에서 제거하면 된다 (orphanRemoval)<br />
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="9-값-타입">9. 값 타입</h1>
<p>JPA의 데이터 타입</p>
<ul>
  <li>엔티티 타입
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@Entity</code></li>
    </ul>
  </li>
  <li>값 타입
    <ul>
      <li>기본값 타입
        <ul>
          <li>자바 기본 타입(예: int, double)</li>
          <li>래퍼 클래스(예: Integer)</li>
          <li>String</li>
        </ul>
      </li>
      <li>임베디드 타입
        <ul>
          <li>embedded type</li>
        </ul>
      </li>
      <li>컬렉션 값 타입
        <ul>
          <li>collection value type</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>

<h2 id="91-기본값-타입">9.1 기본값 타입</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>
<span class="o">...</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="92-임베디드-타입복합-값-타입">9.2 임베디드 타입(복합 값 타입)</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Embedded</span> <span class="nc">Address</span> <span class="n">homeAddress</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"city"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@Embeddable</code>: 값 타입을 정의하는 곳에 표시</li>
  <li><code class="language-plaintext highlighter-rouge">@Embedded</code>: 값 타입을 사용하는 곳에 표시<br />
<br />
<br /></li>
</ul>

<h3 id="921-임베디드-타입과-테이블-매핑">9.2.1 임베디드 타입과 테이블 매핑</h3>
<center><img src="/assets/images/posts/books/2/9_2_값타입테이블매핑.png" width="100%" height="100%" /></center>
<center><img src="/assets/images/posts/books/2/9_2_값타입테이블매핑2.png" width="100%" height="100%" /></center>
<p>UML에서 임베디드 값 타입은 단순하게 표현하는 것이 편리하다.<br />
<br />
<br /></p>

<h3 id="922-임베디드-타입과-연관관계">9.2.2 임베디드 타입과 연관관계</h3>
<center><img src="/assets/images/posts/books/2/9_2_임베디드타입과연관관계.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Embedded</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span>
    <span class="nd">@Embedded</span> <span class="nc">PhoneNumber</span> <span class="n">phoneNumber</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">state</span><span class="o">;</span>
    <span class="nd">@Embedded</span> <span class="nc">Zipcode</span> <span class="n">zipcode</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Zipcode</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">zip</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">plusFour</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PhoneNumber</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">areaCode</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">localNumber</span><span class="o">;</span>
    <span class="nd">@ManyToOne</span> <span class="nc">PhoneServiceProvider</span> <span class="n">provider</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PhoneServiceProvider</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="923-attributeoverride-속성-재정의">9.2.3 @AttributeOverride: 속성 재정의</h3>
<p>임베디드 타입에 정의한 매핑정보를 재정의 하려면 엔티티에 <code class="language-plaintext highlighter-rouge">@AttributeOverride</code>를 사용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span>

    <span class="nd">@Embedded</span>
    <span class="nd">@AttributeOverrides</span><span class="o">({</span>
        <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">ame</span><span class="o">=</span><span class="s">"city"</span><span class="o">,</span> <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"COMPANY_CITY"</span><span class="o">)),</span>
        <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"street"</span><span class="o">,</span> <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"COMPANY_STREET"</span><span class="o">)),</span>
        <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"zipcode"</span><span class="o">,</span> <span class="n">column</span><span class="o">=</span><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"COMPANY_ZIPCODE"</span><span class="o">))</span>
    <span class="o">})</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">companyAddress</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="924-임베디드-타입과-null">9.2.4 임베디드 타입과 null</h3>
<p>임베디드 타입이 null이면 매핑한 컬럼 값은 모두 null이 된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
<span class="c1">// 회원 테이블의 주소와 관련된 CITY,STREET,ZIPCODE 컬럼 값은 모두 null이 된다.</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="93-값-타입과-불변-객체">9.3 값 타입과 불변 객체</h2>
<p>값 타입은 복잡한 객체를 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.</p>

<h3 id="931-값-타입-공유-참조">9.3.1 값 타입 공유 참조</h3>
<p>임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위함하다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member1</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"OldCity"</span><span class="o">));</span>
<span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="n">member1</span><span class="o">.</span><span class="na">getAddress</span><span class="o">();</span>

<span class="n">address</span><span class="o">.</span><span class="na">setCity</span><span class="o">(</span><span class="s">"NewCity"</span><span class="o">);</span>
<span class="n">member2</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">address</span><span class="o">);</span>

<span class="c1">// 회원2의 주소만 NewCity로 변경되기를 기대하지만 회원1의 주소도 NewCity로 변경되어 버린다.</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="932-값-타입-복사">9.3.2 값 타입 복사</h3>
<p>값 타입의 실제 인스턴스인 값을 공유하는 것은 위험하다. 대신에 값(인스턴스)을 복사해서 사용해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">member1</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">Address</span><span class="o">(</span><span class="s">"OldCity"</span><span class="o">));</span>
<span class="nc">Address</span> <span class="n">address</span> <span class="o">=</span> <span class="n">member1</span><span class="o">.</span><span class="na">getAddress</span><span class="o">();</span>

<span class="c1">// 복사</span>
<span class="nc">Address</span> <span class="n">newAddress</span> <span class="o">=</span> <span class="n">address</span><span class="o">.</span><span class="na">clone</span><span class="o">();</span>
<span class="n">newAddress</span><span class="o">.</span><span class="na">setCity</span><span class="o">(</span><span class="s">"NewCity"</span><span class="o">);</span>
<span class="n">member2</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">newAddress</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="933-불변-객체">9.3.3 불변 객체</h3>
<p>값 타입은 부작용 걱정 없이 사용할 수 있어야 한다. <strong>객체를 불변하게 만들면 값을 수정할 수 없으므로 부작용을 원천 차단할 수 있다.</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 주소 불변 객체</span>
<span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
    
    <span class="kd">protected</span> <span class="nf">Address</span> <span class="o">()</span> <span class="o">{}</span>

    <span class="kd">public</span> <span class="nf">Address</span><span class="o">(</span><span class="nc">String</span> <span class="n">city</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">city</span> <span class="o">=</span> <span class="n">city</span><span class="o">;</span>
    <span class="o">}</span>
    

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getCity</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">city</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Setter는 만들지 않는다.</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="94-값-타입의-비교">9.4 값 타입의 비교</h2>
<ul>
  <li>동일성 비교: 인스턴스의 참조 값을 비교, <code class="language-plaintext highlighter-rouge">==</code> 사용</li>
  <li>동등성 비교: 인스턴스의 값을 비교, <code class="language-plaintext highlighter-rouge">equals()</code> 사용</li>
  <li>값 타입을 비교할 때는 <code class="language-plaintext highlighter-rouge">equals()</code>를 사용해서 동등성 비교를 해야 한다.</li>
  <li>값 타입의 <code class="language-plaintext highlighter-rouge">equals()</code>, <code class="language-plaintext highlighter-rouge">hashCode()</code> 메소드를 재정의해야 한다.<br />
<br />
<br /></li>
</ul>

<h2 id="95-값-타입-컬렉션">9.5 값 타입 컬렉션</h2>
<p>값 타입을 하나 이상  컬렉션에 보관하고 <code class="language-plaintext highlighter-rouge">@ElementCollection</code>, <code class="language-plaintext highlighter-rouge">@CollectionTable</code> 어노테이션을 사용하면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ElementCollection</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"FAVORITE_FOODS"</span><span class="o">,</span>
        <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="o">)</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"FOOD_NAME"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">favoriteFoods</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>

    <span class="nd">@ElementCollection</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"ADDRESS"</span><span class="o">,</span>
        <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>

    <span class="nd">@Column</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<center><img src="/assets/images/posts/books/2/9_5_값타입컬렉션.png" width="100%" height="100%" /></center>
<p><br /></p>

<h3 id="951-값-타입-컬렉션-사용">9.5.1 값 타입 컬렉션 사용</h3>
<p>값 타입 컬렉션은 영속성 전이(Cascade) + 고아 객체 제거(Orphan remove) 기능이 포함되어 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 값 타입 컬렉션도 조회할 때 페치 전략을 선택할 수 있다.</span>
<span class="nd">@ElementCollection</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span> <span class="c1">// 기본값 LAZY</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="952-값-타입-컬렉션의-제약사항">9.5.2 값 타입 컬렉션의 제약사항</h3>

<p><strong>제약사항</strong></p>
<ul>
  <li>값 타입 컬렉션에 보관된 값 타입들은 별도의 테이블에 보관한다.</li>
  <li>따라서 여기에 보관된 값 타입의 값이 변경되면 데이터베이스에서 데이터를 찾기 어렵다.</li>
  <li>이런 문제로 JPA 구현체들은 값 타입 변경 사항이 발생하면 값 타입 컬렉션이 매핑된 테이블의 연관된 모든 데이터를 삭제, 현재 값으로 저장한다.</li>
  <li>성능 문제 발생</li>
  <li>값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성 해야한다.</li>
  <li>따라서 데이터베이스 기본 키 제약 조건으로 인해 컬럼에 null을 입력할 수 없고, 값은 값을 중복해서 저장할 수 없는 제약도 있다.</li>
</ul>

<p><strong>해결방법</strong></p>
<ul>
  <li>따라서 실무에서는 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 <strong>값 타입 컬렉션 대신에 일대다 관계를 고려</strong>해야 한다.</li>
  <li>그리고 영속성 전이 + 고아 객체 제거 기능을 적용하면 값 타입 컬렉션 처럼 사용할 수 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 값 타입 컬렉션 대신에 일대다 관계 사용</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddressEntity</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span>
<span class="o">}</span>

<span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span> <span class="o">{</span>

    <span class="nd">@Column</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">city</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">street</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 설정 코드</span>
<span class="nd">@OneToMany</span><span class="o">(</span><span class="n">cascade</span> <span class="o">=</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">ALL</span><span class="o">,</span> <span class="n">orphanRemoval</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">AddressEntity</span><span class="o">&gt;</span> <span class="n">addressHistory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">AddressEntity</span><span class="o">&gt;();</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="96-정리">9.6 정리</h2>
<p><strong>엔티티 타입의 특징</strong></p>
<ul>
  <li>식별자(<code class="language-plaintext highlighter-rouge">@Id</code>)가 있다.</li>
  <li>생명 주기가 있다.
    <ul>
      <li>생성, 영속, 소멸</li>
    </ul>
  </li>
  <li>공유할 수 있다.
    <ul>
      <li>참조 값을 공유할 수 있다.</li>
      <li>예를 들어 회원 엔티티가 있다면 다른 엔티티에서 회원 엔티티를 참조할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><strong>값 타입의 특징</strong></p>
<ul>
  <li>식별자가 없다</li>
  <li>생명 주기를 엔티티에 의존한다.
    <ul>
      <li>의존하는 엔티티를 제거하면 같이 제거된다.</li>
    </ul>
  </li>
  <li>공유하지 않는 것이 안전하다.
    <ul>
      <li>대신에 값을 복사해서 사용한다.</li>
      <li>오직 하나의 주인만이 관리해야 한다.</li>
      <li>불변 객체로 만드는 것이 안전하다.<br />
<br />
<br />
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h1 id="10-객체지향-쿼리-언어">10. 객체지향 쿼리 언어</h1>

<h2 id="101-객체지향-쿼리-소개">10.1 객체지향 쿼리 소개</h2>
<p><strong>JPQL 이란?</strong></p>
<ul>
  <li>테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리다</li>
  <li>SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.</li>
  <li>SQL이 데이터베이스 테이블을 대상으로 하는 데이터 중심의 쿼리라면 JPQL은 엔티티 객체를 대상으로 하는 <strong>객체지향 쿼리다.</strong><br />
<br /></li>
</ul>

<p>JPA는 JPQL뿐만 아니라 다양한 검색 방법을 제공한다.</p>

<p><strong>공식 지원 기능</strong></p>
<ul>
  <li>JPQL(Java Persistence Query Language)</li>
  <li>Criteria 쿼리: JPA을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음</li>
  <li>네이티브 SQL: JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다.</li>
</ul>

<p><strong>비 공식 기능</strong></p>
<ul>
  <li><strong>QueryDSL</strong>: Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음, 비표준 오픈소스 프레임워크다.</li>
  <li>JDBC 직접 사용</li>
  <li>MyBatis 같은 SQL 매퍼 프레임워크 사용<br />
<br />
<br /></li>
</ul>

<h3 id="1011-jpql-소개">10.1.1 JPQL 소개</h3>
<ul>
  <li>JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.</li>
  <li>JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.
    <ul>
      <li>방언만 변경하면 된다.</li>
    </ul>
  </li>
  <li>JPQL은 SQL보다 간결하다.
    <ul>
      <li>엔티티 직접 조회</li>
      <li>묵시적 조인</li>
      <li>다형성 지원</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Member"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"name"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JPQL 사용</span>
<span class="nc">String</span> <span class="n">jpql</span> <span class="o">=</span> <span class="s">"select m from Member as m where m.username = 'kim'"</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">jpql</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 실제 실행된 SQL, 별칭은 너무 복잡해 임의 수정</span>
<span class="k">select</span>
    <span class="n">member</span><span class="p">.</span><span class="n">id</span> <span class="k">as</span> <span class="n">id</span><span class="p">,</span>
    <span class="n">member</span><span class="p">.</span><span class="n">age</span> <span class="k">as</span> <span class="n">age</span><span class="p">,</span>
    <span class="n">member</span><span class="p">.</span><span class="n">team_id</span> <span class="k">as</span> <span class="n">team</span><span class="p">,</span>
    <span class="n">member</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">name</span>
<span class="k">from</span>
    <span class="n">Member</span> <span class="n">member</span>
<span class="k">where</span>
    <span class="n">member</span><span class="p">.</span><span class="n">name</span><span class="o">=</span><span class="s1">'kim'</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1012-criteria-소개">10.1.2 Criteria 소개</h3>
<p>Criteria는 JPQL을 생성하는 빌더 클래스다. <strong>Criteria의 장점은 문자가 아닌 <code class="language-plaintext highlighter-rouge">query.select(m).where(...)</code>처럼 프로그래밍 코드로 JPQL을 작성할 수 있다는 점이다.</strong></p>

<p><strong>장점</strong></p>
<ul>
  <li>컴파일 시점에 오류를 발견할 수 있다.</li>
  <li>IDE를 사용하면 코드 자동완성을 지원한다.</li>
  <li>동적 쿼리를 작성하기 편하다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Criteria 사용 준비</span>
<span class="nc">CriteriaBuilder</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getCriteriaBuilder</span><span class="o">();</span>
<span class="nc">CriteriaQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">cb</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// 루트 클래스(조회를 시작할 클래스)</span>
<span class="nc">Root</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="c1">// 쿼리 생성</span>
<span class="nc">CriteriaQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">cq</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">m</span><span class="o">).</span><span class="na">where</span><span class="o">(</span><span class="n">cb</span><span class="o">.</span><span class="na">equal</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"username"</span><span class="o">),</span> <span class="s">"kim"</span><span class="o">));</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">cq</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<p><strong>Criteria가 가진 장점이 많지만 모든 장점을 상쇄할 정도로 복잡하고 장황하다.</strong><br />
<br />
<br /></p>

<h3 id="1013-querydsl-소개">10.1.3 QueryDSL 소개</h3>
<ul>
  <li>QueryDSL도 Criteria처럼 JPQL 빌더 역할을 한다.</li>
  <li>코드 기반이다</li>
  <li>단순하고 사용하기 쉽다</li>
  <li>작성한 코드도 JPQL과 비슷해서 한눈에 들어온다</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 준비</span>
<span class="nc">JPAQuery</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JPAQuery</span><span class="o">(</span><span class="n">em</span><span class="o">);</span>
<span class="nc">QMember</span> <span class="n">member</span> <span class="o">=</span> <span class="nc">QMember</span><span class="o">.</span><span class="na">member</span><span class="o">;</span>

<span class="c1">// 쿼리, 결과조회</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">member</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">username</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"kim"</span><span class="o">))</span>
                    <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1014-네이티브-sql-소개">10.1.4 네이티브 SQL 소개</h3>
<p>JPA는 SQL을 직접 사용할 수 있는 기능을 지원하는데 이것을 네이티브 SQL이라 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'"</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<p>네이티브 SQL의 단점은 특정 데이터베이스에 의존하는 SQL을 작성해야 한다는 것이다. 따라서 데이터베이스를 변경하면 네이티브 SQL도 수정해야 한다.<br />
<br />
<br /></p>

<h3 id="1015-jdbc-직접-사용-마이바티스-같은-sql-매퍼-프레임워크-사용">10.1.5 JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크 사용</h3>
<p>다음은 하이버네이트에서 직접 JDBC Connection을 획득하는 방법이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">unwrap</span><span class="o">(</span><span class="nc">Session</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">session</span><span class="o">.</span><span class="na">doWork</span><span class="o">(</span><span class="k">new</span> <span class="nc">Work</span><span class="o">()</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">Connection</span> <span class="n">connection</span><span class="o">)</span> <span class="k">throw</span> <span class="nc">SQLException</span> <span class="o">{...}</span>
<span class="o">});</span>
</code></pre></div></div>
<ul>
  <li><strong>JDBC나 마이바티스를 JPA와 함께 사용하면 영속성 컨텍스트를 적절한 시점에 강제로 플러시해야 한다.</strong></li>
  <li><strong>데이터베이스와 영속성 컨텍스트를 동기화 하기 위함이다.</strong><br />
<br />
<br />
<br /></li>
</ul>

<h2 id="102-jpql">10.2 JPQL</h2>
<p><strong>JPQL 특징</strong></p>
<ul>
  <li>JPQL은 객체지향 쿼리 언어다. 따라서 테이블이 아닌 엔티티 객체를 대상으로 쿼리한다.</li>
  <li>JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.</li>
  <li>JPQL은 결국 SQL로 변환된다.</li>
</ul>

<h3 id="1021-기본-문법과-쿼리-api">10.2.1 기본 문법과 쿼리 API</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>JPQL 문법

select_문 :: =
    select_절
    from_절
    [where_절]
    [groupby_절]
    [having_절]
    [orderby_절]

update_문 :: update_절 [where_절]
delete_문 :: delete_절 [where_절]
</code></pre></div></div>
<p><br /></p>

<p><strong>SELECT 문</strong></p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">m</span> <span class="k">FROM</span> <span class="n">Member</span> <span class="k">AS</span> <span class="n">m</span> <span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="s1">'Hello'</span>
</code></pre></div></div>

<ul>
  <li>대소문자 구분
    <ul>
      <li>엔티티와 속성은 대소문자를 구분한다.</li>
      <li>JPQL 키워드(SELECT, FROM, AS..)는 대소문자를 구분하지 않는다.</li>
    </ul>
  </li>
  <li>엔티티 이름
    <ul>
      <li>테이블 명이 아니라 엔티티 명을 사용한다.</li>
      <li>@Entity(name=”xxx”)로 지정할 수 있다.</li>
      <li>엔티티 명을 지정하지 않으면 클래스명을 기본값으로 사용한다.</li>
    </ul>
  </li>
  <li>별칭은 필수
    <ul>
      <li>JPQL은 별칭을 필수로 사용해야 한다. (JPA 명세로 치면 정확히는 식별 변수)</li>
      <li>AS는 생략할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>TypeQuery, Query</strong><br />
작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다.</p>
<ul>
  <li>TypeQuery 객체: 반환 타입을 명확하게 지정할 수 있으면 사용</li>
  <li>Query 객체: 반환 타입을 명확하게 지정할 수 없으면 사요</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// TypeQuery 사용</span>

<span class="nc">TypeQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m FROM Member m"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Member</span> <span class="n">member</span> <span class="o">:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Query 사용</span>

<span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m FROM Member m"</span><span class="o">);</span>

<span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">o</span> <span class="o">:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Object</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Object</span><span class="o">[])</span> <span class="n">o</span><span class="o">;</span> <span class="c1">// 결과가 둘 이상이면 Object[] 반환</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"username = "</span> <span class="o">+</span> <span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"age = "</span> <span class="o">+</span> <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>결과 조회</strong><br />
다음 메소드들을 호출하면 실제 쿼리를 실행해서 데이터베이스를 조회한다.</p>
<ul>
  <li>query.getResultList(): 결과를 반환. 만약 결과가 없으면 빈 컬렉션 반환</li>
  <li>query.getSingleResult(): 결과가 정확히 하나일 때 사용한다.
    <ul>
      <li>결과가 없으면 javax.persistence.NoResultException 발생</li>
      <li>결과가 1개보다 많으면 javax.persistence.NonUniqueResultException 발생</li>
    </ul>
  </li>
</ul>

<p><br />
<br /></p>

<h3 id="1022-파라미터-바인딩">10.2.2 파라미터 바인딩</h3>
<p>JDBC는 위치 기준 파라미터 바인딩만 지원하지만 JPQL은 이름 기준 파라미터 바인딩도 지원한다.</p>

<p><strong>이름 기준 파라미터</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">usernameParam</span> <span class="o">=</span> <span class="s">"user1"</span><span class="o">;</span>

<span class="c1">// 파라미터 앞에 :을 붙인다.</span>
<span class="nc">TypeQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m FROM Member m where m.username = :username"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">query</span><span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="n">usernameParam</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>위치 기준 파라미터</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">usernameParam</span> <span class="o">=</span> <span class="s">"user1"</span><span class="o">;</span>

<span class="c1">// 파라미터는 ? 다음에 위치 값을 주면 된다.</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m FROM Member m where m.username = ?1"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="n">query</span><span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">usernameParam</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>

<div class="notice--warning">
<p><strong>경고</strong><br />
파라미터 바인딩 방식을 사용하지 않고 직접 JPQL을 만들면 SQL 인젝션 공격을 당할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"SELECT m FROM Member m where m.username = '"</span> <span class="o">+</span> <span class="n">usernameParam</span> <span class="o">+</span> <span class="s">"'"</span>
</code></pre></div></div>
</div>
<p><br /></p>

<h3 id="1023-프로젝션">10.2.3 프로젝션</h3>
<p><strong>SELECT 절에 조회할 대상을 지정하는 것을 프로젝션이라고 한다</strong>. [SELECT {프로젝션 대상} FROM]으로 대상을 선택한다. <strong>프로젝션 대상은 엔티티, 임베디드 타입, 스칼라 타입이 있다.</strong> 스칼라 타입은 숫자, 문자 등 기본 데이터 타입을 뜻한다.</p>

<p><strong>엔티티 프로젝션</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">SELECT</span> <span class="n">m</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span>      <span class="c1">// 회원</span>
<span class="no">SELECT</span> <span class="n">m</span><span class="o">.</span><span class="na">team</span> <span class="no">FROM</span> <span class="nc">Member</span> <span class="n">m</span> <span class="c1">// 팀</span>
</code></pre></div></div>
<p>조회한 엔티티는 영속성 컨텍스트에서 관리한다.<br />
<br /></p>

<p><strong>임베디드 타입 프로젝션</strong><br />
임베디드 타입은 조회의 시작점이 될 수 없다는 제약이 있다. 아래에 Address는 임베디드 타입이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 잘못된 쿼리</span>
<span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"SELECT a From Address a"</span><span class="o">;</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 올바른 쿼리</span>
<span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"SELECT o.address From Order o"</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Address</span><span class="o">&gt;</span> <span class="n">addresses</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">Address</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<p>실행된 쿼리는 다음과 같다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span>
    <span class="k">order</span><span class="p">.</span><span class="n">city</span><span class="p">,</span>
    <span class="k">order</span><span class="p">.</span><span class="n">street</span><span class="p">,</span>
    <span class="k">order</span><span class="p">.</span><span class="n">zipcode</span>
<span class="k">from</span>
    <span class="n">Orders</span> <span class="k">order</span>
</code></pre></div></div>
<p>임베디드 타입은 엔티티 타입이 아니다. 따라서 이렇게 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다.<br />
<br /></p>

<p><strong>스칼라 타입 프로젝션</strong><br />
숫자, 문자, 날짜와 같은 기본 데이터 타입들은 스칼라 타입이라 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"SELECT username FROM Member m"</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">usernames</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>


<span class="c1">// 중복 데이터를 제거하려면 DISTINCT를 사용한다.</span>
<span class="no">SELECT</span> <span class="no">DISTINCT</span> <span class="n">username</span> <span class="nc">From</span> <span class="nc">Member</span> <span class="n">m</span>

<span class="c1">// 통계</span>
<span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"SELECT AVG(o.orderAmount) FROM Order o"</span>
<span class="nc">Double</span> <span class="n">orderAmountAvg</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">Double</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">getSingleResult</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>여러 값 조회</strong><br />
꼭 필요한 데이터들만 선택해서 조회해야 할 때도 있다. 이 때는 TypeQuery를 사용할 수 없고 대신에 Query를 사용해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m.username, m.age FROM Member m"</span><span class="o">);</span>
<span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>

<span class="nc">Iterator</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">resultList</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
<span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">Object</span><span class="o">[]</span> <span class="n">row</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Object</span><span class="o">[])</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="nc">Integer</span> <span class="n">age</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m.username, m.age FROM Member m"</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">[]&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>

<span class="k">for</span> <span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
    <span class="nc">Integer</span> <span class="n">age</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
<span class="o">}</span>
</code></pre></div></div>
<p>스칼라 타입뿐만 아니라 엔티티 타입도 여러 값을 함께 조회할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Query</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT o.member, o.product, o.orderAmount FROM Order o"</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">[]&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>

<span class="k">for</span> <span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">row</span> <span class="o">:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Member</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>    <span class="c1">// 엔티티</span>
    <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Product</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// 엔티티</span>
    <span class="kt">int</span> <span class="n">orderAmount</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">)</span> <span class="n">row</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span> <span class="c1">// 스칼라</span>
<span class="o">}</span>
</code></pre></div></div>
<p>물론 이때도 조회한 엔티티는 영속성 컨텍스트에서 관리된다.<br />
<br /></p>

<p><strong>NEW 명령어</strong><br />
프로젝션을 UserDTO처럼 의미 있는 객체로 변환해서 사용할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDTO</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">UserDTO</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">,</span> <span class="kt">int</span> <span class="n">age</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">username</span> <span class="o">=</span> <span class="n">username</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">age</span> <span class="o">=</span> <span class="n">age</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TypeQuery</span><span class="o">&lt;</span><span class="nc">UserDTO</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m"</span><span class="o">,</span> <span class="nc">UserDTO</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">UserDTO</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<p>NEW 명령어 사용시 주의 사항은 다음과 같다.</p>
<ul>
  <li>패키지 명을 포함한 전체 클래스 명을 입력해야 한다.</li>
  <li>순서와 타입이 일치하는 생성자가 필요한다.<br />
<br />
<br /></li>
</ul>

<h3 id="1024-페이징-api">10.2.4 페이징 API</h3>
<p>JPA 페이징</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TypeQuery</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"SELECT m FROM Member m ORDER BY m.username DESC"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="n">query</span><span class="o">.</span><span class="na">setFirstResult</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span> <span class="c1">// 조회 시작 위치(0부터 시작)</span>
<span class="n">query</span><span class="o">.</span><span class="na">setMaxResult</span><span class="o">(</span><span class="mi">20</span><span class="o">);</span>   <span class="c1">// 조회할 데이터 수</span>
<span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>HSQLDB 페이징</strong></p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">M</span><span class="p">.</span><span class="n">ID</span> <span class="k">AS</span> <span class="n">ID</span><span class="p">,</span>
    <span class="n">M</span><span class="p">.</span><span class="n">AGE</span> <span class="k">AS</span> <span class="n">AGE</span><span class="p">,</span>
    <span class="n">M</span><span class="p">.</span><span class="n">TEAM_ID</span> <span class="k">AS</span> <span class="n">TEAM_ID</span><span class="p">,</span>
    <span class="n">M</span><span class="p">.</span><span class="n">NAME</span> <span class="k">AS</span> <span class="n">NAME</span>
<span class="k">FROM</span>
    <span class="n">MEMBER</span> <span class="n">M</span>
<span class="k">ORDER</span> <span class="k">BY</span>
    <span class="n">M</span><span class="p">.</span><span class="n">NAME</span> <span class="k">DESC</span> <span class="k">OFFSET</span> <span class="o">?</span> <span class="k">LIMIT</span> <span class="o">?</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>MySQL 페이징</strong></p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">M</span><span class="p">.</span><span class="n">ID</span> <span class="k">AS</span> <span class="n">ID</span><span class="p">,</span>
    <span class="n">M</span><span class="p">.</span><span class="n">AGE</span> <span class="k">AS</span> <span class="n">AGE</span><span class="p">,</span>
    <span class="n">M</span><span class="p">.</span><span class="n">TEAM_ID</span> <span class="k">AS</span> <span class="n">TEAM_ID</span><span class="p">,</span>
    <span class="n">M</span><span class="p">.</span><span class="n">NAME</span> <span class="k">AS</span> <span class="n">NAME</span>
<span class="k">FROM</span>
    <span class="n">MEMBER</span> <span class="n">M</span>
<span class="k">ORDER</span> <span class="k">BY</span>
    <span class="n">M</span><span class="p">.</span><span class="n">NAME</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="o">?</span><span class="p">,</span> <span class="o">?</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>PostgreSQL 페이징</strong></p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="n">M</span><span class="p">.</span><span class="n">ID</span> <span class="k">AS</span> <span class="n">ID</span><span class="p">,</span>
    <span class="n">M</span><span class="p">.</span><span class="n">AGE</span> <span class="k">AS</span> <span class="n">AGE</span><span class="p">,</span>
    <span class="n">M</span><span class="p">.</span><span class="n">TEAM_ID</span> <span class="k">AS</span> <span class="n">TEAM_ID</span><span class="p">,</span>
    <span class="n">M</span><span class="p">.</span><span class="n">NAME</span> <span class="k">AS</span> <span class="n">NAME</span>
<span class="k">FROM</span>
    <span class="n">MEMBER</span> <span class="n">M</span>
<span class="k">ORDER</span> <span class="k">BY</span>
    <span class="n">M</span><span class="p">.</span><span class="n">NAME</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="o">?</span> <span class="k">OFFSET</span> <span class="o">?</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>오라클 페이징</strong></p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span>
    <span class="p">(</span>
        <span class="k">SELECT</span> <span class="n">ROW_</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">ROWNUM</span> <span class="n">ROWNUM_</span>
            <span class="k">FROM</span>
                <span class="p">(</span>
                    <span class="k">SELECT</span>
                        <span class="n">M</span><span class="p">.</span><span class="n">ID</span> <span class="k">AS</span> <span class="n">ID</span><span class="p">,</span>
                        <span class="n">M</span><span class="p">.</span><span class="n">AGE</span> <span class="k">AS</span> <span class="n">AGE</span><span class="p">,</span>
                        <span class="n">M</span><span class="p">.</span><span class="n">TEAM_ID</span> <span class="k">AS</span> <span class="n">TEAM_ID</span><span class="p">,</span>
                        <span class="n">M</span><span class="p">.</span><span class="n">NAME</span> <span class="k">AS</span> <span class="n">NAME</span>
                    <span class="k">FROM</span>
                        <span class="n">MEMBER</span> <span class="n">M</span>
                    <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">M</span><span class="p">.</span><span class="n">NAME</span>
                <span class="p">)</span> <span class="n">ROW_</span>
            <span class="k">WHERE</span> <span class="n">ROWNUM</span> <span class="o">&lt;=</span> <span class="o">?</span>
    <span class="p">)</span>
<span class="k">WHERE</span> <span class="n">ROWNUM_</span> <span class="o">&gt;</span> <span class="o">?</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>SQLServer 페이징</strong></p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WITH</span> <span class="n">query</span> <span class="k">AS</span> <span class="p">(</span>
    <span class="k">SELECT</span>
    <span class="n">inner_query</span><span class="p">.</span><span class="o">*</span><span class="p">,</span>
    <span class="n">ROW_NUMBER</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="k">ORDER</span> <span class="k">BY</span> <span class="k">CURRENT_TIMESTAMP</span><span class="p">)</span> <span class="k">as</span>
        <span class="n">__hibernate_row_nr__</span>
    <span class="k">FROM</span>
        <span class="p">(</span>
            <span class="k">select</span>
                <span class="n">TOP</span><span class="p">(</span><span class="o">?</span><span class="p">)</span> <span class="n">m</span><span class="p">.</span><span class="n">id</span> <span class="k">as</span> <span class="n">id</span><span class="p">,</span>
                <span class="n">m</span><span class="p">.</span><span class="n">age</span> <span class="k">as</span> <span class="n">age</span><span class="p">,</span>
                <span class="n">m</span><span class="p">.</span><span class="n">team_id</span> <span class="k">as</span> <span class="n">team_id</span><span class="p">,</span>
                <span class="n">m</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">name</span>
            <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
            <span class="k">order</span> <span class="k">by</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span> <span class="k">DESC</span>
        <span class="p">)</span> <span class="n">inner_query</span>
<span class="p">)</span>
<span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">team_id</span><span class="p">,</span> <span class="n">name</span>
<span class="k">FROM</span> <span class="n">query</span>
<span class="k">WHERE</span> <span class="n">__hibernate_row_nr__</span> <span class="o">&gt;=</span> <span class="o">?</span> <span class="k">AND</span> <span class="n">__hibernate_row_nr__</span> <span class="o">&lt;</span> <span class="o">?</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1025-집합과-정렬">10.2.5 집합과 정렬</h3>
<p>집합은 집합함수와 함께 통계 정보를 구할 때 사용한다.</p>

<p><strong>집합 함수</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>함수</strong></th>
      <th><strong>설명</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>COUNT</td>
      <td>결과 수를 구한다. 반환 타입: Long</td>
    </tr>
    <tr>
      <td>MAX, MIN</td>
      <td>최대, 최소 값을 구한다. 문자, 숫자, 날짜 등에 사용한다.</td>
    </tr>
    <tr>
      <td>AVG</td>
      <td>평균값을 구한다. 숫자타입만 사용할 수 있다. 반환 타입: Double</td>
    </tr>
    <tr>
      <td>SUM</td>
      <td>합을 구한다. 숫자타입만 사용할 수 있다. 반환 타입: 정수합 Long, 소수합: Double, BigInteger합: BigInteger, BigDecimal합: BigDecimal</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>집합 함수 사용 시 참고사항</strong></p>
<ul>
  <li>NULL 값은 무시하므로 통계에 잡히지 않는다. (DISTINCT가 정의되어 있어도 무시된다.)</li>
  <li>만약 값이 없는데 SUM, AVG, MAX, MIN 합수를 사용하면 NULL 값이 된다. 단 COUNT는 0이 된다.</li>
  <li>DISTINCT를 집합 함수 안에 사용해서 중복된 값을 제거하고 나서 집합을 구할 수 있다. 예: <code class="language-plaintext highlighter-rouge">select COUNT( DISTINCT m.age ) from Member m</code></li>
  <li>DISTINCT를 COUNT에서 사용할 때 임베디드 타입은 지원하지 않는다.</li>
</ul>

<p><br /></p>

<p><strong>GROUP BY, HAVING</strong><br />
GROUP BY는 통계 데이터를 구할 때 특정 그룹끼리 묶어준다. HAVING은 GROUP BY와 함께 사용되는데 GROUP BY로 그룹화한 통계 데이터를 기준으로 필터링 한다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span>
    <span class="n">t</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
    <span class="k">COUNT</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">age</span><span class="p">),</span>
    <span class="k">SUM</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">age</span><span class="p">),</span>
    <span class="k">AVG</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">age</span><span class="p">),</span>
    <span class="k">MAX</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">age</span><span class="p">),</span>
    <span class="k">MIN</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">age</span><span class="p">)</span>
<span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">m</span><span class="p">.</span><span class="n">team</span> <span class="n">t</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">t</span><span class="p">.</span><span class="n">name</span>
<span class="k">HAVING</span> <span class="k">AVG</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">age</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span>
</code></pre></div></div>
<p>문법은 다음과 같다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>groupby_절 ::= GORUP BY {단일값 경로 | 별칭} +
having_절 ::= HAVING 조건식
</code></pre></div></div>
<p><br /></p>

<p><strong>정렬(ORDER BY)</strong><br />
결과를 정렬할 때 사용한다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">order</span> <span class="k">by</span> <span class="n">m</span><span class="p">.</span><span class="n">age</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">username</span> <span class="k">ASC</span>
</code></pre></div></div>
<p>문법은 다음과 같다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>orderby_절 ::= ORDER BY {상태필드 경로 | 결과 변수 [ASC | DESC]}+
</code></pre></div></div>
<ul>
  <li>ASC: 오름차순(기본값)</li>
  <li>DESC: 내림차순</li>
</ul>

<p><br /></p>

<h3 id="1026-jpql-조인">10.2.6 JPQL 조인</h3>
<p>JPQL도 조인을 지원하는데 SQL 조인과 기능은 같고 문법만 약간 다르다.</p>

<p><strong>내부 조인</strong><br />
내부조인은 INNER JOIN을 사용한다. 참고로 INNER는 생략할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">teamName</span> <span class="o">=</span> <span class="s">"팀A"</span><span class="o">;</span>
<span class="nc">String</span> <span class="n">query</span> <span class="o">=</span> <span class="s">"SELECT m FROM Member m INNER JOIN m.team t WHERE t.name = :teamName"</span><span class="o">;</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"teamName"</span><span class="o">,</span> <span class="n">teamName</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>

<div class="notice--warning">
<p><strong>주의사항</strong><br />
<strong>JPQL 조인은 연관 필드를 사용</strong>한다는 것이다. SQL 조인처럼 사용하면 문법 오류가 발생한다. 다음은 잘못된 예이다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 잘못된 JPQL 조인</span>
<span class="k">FROM</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">JOIN</span> <span class="n">Team</span> <span class="n">t</span> 
</code></pre></div></div>
</div>
<p><br /></p>

<p><strong>외부 조인</strong><br />
JPQL의 외부 조인은 다음과 같이 사용한다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">m</span>
<span class="k">FROM</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">LEFT</span> <span class="p">[</span><span class="k">OUTER</span><span class="p">]</span> <span class="k">JOIN</span> <span class="n">m</span><span class="p">.</span><span class="n">team</span> <span class="n">t</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>컬렉션 조인</strong><br />
일대다 관계나 다대다 관계처럼 컬렉션을 사용하는 곳에서 조인하는 것을 컬렉션 조인이라 한다.</p>
<ul>
  <li>[회원 -&gt; 팀]으로의 조인은 다대일 조인, 단일 값 연관필드(m.team) 사용</li>
  <li>[팀 -&gt; 회원]으로의 조인은 일대다 조인, 컬렉션 값 연관필드(m.members) 사용</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 팀과 회원목록을 컬렉션 값 연관 필드로 외부조인 했다.</span>
<span class="k">SELECT</span> <span class="n">t</span><span class="p">,</span> <span class="n">m</span> <span class="k">FROM</span> <span class="n">Team</span> <span class="n">t</span> <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">t</span><span class="p">.</span><span class="n">members</span> <span class="n">m</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>세타 조인</strong><br />
WHERE 절을 사용해서 세타 조인을 할 수 있다. <strong>세타 조인은 내부 조인만 지원한다.</strong> 세타 조인을 사용하면 전혀 관계없는 엔티티도 조인할 수 있다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- JPQL</span>
<span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span><span class="p">,</span> <span class="n">Team</span> <span class="n">t</span>
<span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">team</span>

<span class="c1">-- sql</span>
<span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
<span class="k">from</span>
    <span class="n">member</span> <span class="n">m</span> <span class="k">cross</span> <span class="k">join</span> <span class="n">team</span> <span class="n">t</span>
<span class="k">where</span>
    <span class="n">m</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">name</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>JOIN ON 절(JPA 2.1)</strong><br />
JPA 2.1부터 조인할 때 ON 절을 지원한다. 참고로 내부 조인이 ON 절은 WHERE 절을 사용할 때와 결과가 같으므로 보통 ON 절은 외부 조인에서만 사용한다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- JPQL</span>
<span class="k">select</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span>
<span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
    <span class="k">left</span> <span class="k">join</span> <span class="n">m</span><span class="p">.</span><span class="n">team</span> <span class="n">t</span> <span class="k">on</span> <span class="n">t</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'A'</span>

<span class="c1">-- SQL</span>
<span class="k">select</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">t</span><span class="p">.</span><span class="o">*</span>
<span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
    <span class="k">left</span> <span class="k">join</span> <span class="n">Team</span> <span class="n">t</span> <span class="k">on</span> <span class="n">m</span><span class="p">.</span><span class="n">team_id</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">id</span> 
    <span class="k">and</span> <span class="n">t</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'A'</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1027-페치-조인">10.2.7 페치 조인</h3>
<ul>
  <li>페치(fetch) 조인은 JPQL에서 성능 최적화를 위해 제공하는 기능이다.</li>
  <li>연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능이다.</li>
  <li>join fetch 명령어로 사용할 수 있다.</li>
</ul>

<p><strong>문법</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로
</code></pre></div></div>
<p><br /></p>

<p><strong>엔티티 페치 조인</strong><br />
다음은 페치 조인을 사용해서 회원 엔티티를 조회하면서 연관된 팀 엔티티도 함께 조회 하는 JPQL</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 페치 조인 JPQL</span>
<span class="k">select</span> <span class="n">m</span>
<span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">join</span> <span class="k">fetch</span> <span class="n">m</span><span class="p">.</span><span class="n">team</span>


<span class="c1">-- 실행된 SQL</span>
<span class="k">SELECT</span>
    <span class="n">M</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">T</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span> <span class="n">MEMBER</span> <span class="n">T</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">TEAM</span> <span class="n">T</span> <span class="k">ON</span> <span class="n">M</span><span class="p">.</span><span class="n">TEAM_ID</span> <span class="o">=</span> <span class="n">T</span><span class="p">.</span><span class="n">ID</span>

</code></pre></div></div>
<p>JPQL조인과는 다르게 m.team 다음에 별칭이 없는데 페치 조인은 별칭을 사용할 수 없다. (하지만 하이버네이트는 페치 조인에도 별칭을 허용한다.)<br />
<br /></p>

<p><strong>컬렉션 페치 조인</strong><br />
일대다 관계인 컬렉션을 페치 조인</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 컬렉션 페치 조인 JPQL</span>
<span class="k">select</span> <span class="n">t</span>
<span class="k">from</span> <span class="n">Team</span> <span class="n">t</span> <span class="k">join</span> <span class="k">fetch</span> <span class="n">t</span><span class="p">.</span><span class="n">members</span>
<span class="k">where</span> <span class="n">t</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'팀A'</span>


<span class="c1">-- 실행된 SQL</span>
<span class="k">SELECT</span>
    <span class="n">T</span><span class="p">.</span><span class="o">*</span><span class="p">,</span> <span class="n">M</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span> <span class="n">TEAM</span> <span class="n">T</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">MEMBER</span> <span class="n">M</span> <span class="k">ON</span> <span class="n">T</span><span class="p">.</span><span class="n">ID</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">TEAM_ID</span>
<span class="k">WHERE</span> <span class="n">T</span><span class="p">.</span><span class="n">NAME</span> <span class="o">=</span> <span class="s1">'팀A'</span>
</code></pre></div></div>
<p>문제는 TEAM 테이블에서 팀A는 하나지만 MEMBER테이블과 조인하면서 결과가 증가한다. 테이블의 데이터가 팀A, 회원1, 회원2 있다고 하면 결과는 아래와 같다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>teamname = 팀A, team = Team@0x100
    username = 회원1, member = Member@0x200
    username = 회원2, member = Member@0x300
teamname = 팀A, team = Team@0x100
    username = 회원1, member = Member@0x200
    username = 회원2, member = Member@0x300
</code></pre></div></div>

<p><br /></p>

<p><strong>페치 조인과 DISTINCT</strong><br />
위의 컬렉션 페치 조인은 팀A가 중복으로 조회된다. 이를 해결하기 위해 DISTINCT를 사용한다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">distinct</span> <span class="n">t</span>
<span class="k">from</span> <span class="n">Team</span> <span class="n">t</span> <span class="k">join</span> <span class="k">fetch</span> <span class="n">t</span><span class="p">.</span><span class="n">members</span>
<span class="k">where</span> <span class="n">t</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'팀A'</span>
</code></pre></div></div>
<p>위 상황의 데이터는 SQL에서 DISTINCT를 해도 효과가 없다.</p>

<table>
  <thead>
    <tr>
      <th><strong>로우 번호</strong></th>
      <th><strong>팀</strong></th>
      <th><strong>회원</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>팀A</td>
      <td>회원1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>팀A</td>
      <td>회원2</td>
    </tr>
  </tbody>
</table>

<p>하지만 <strong>JPQL의 select distinct t의 의미는 엔티티의 중복을 제거하라는 것이다. 따라서 팀A는 하나만 조회된다.</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>teamname = 팀A, team = Team@0x100
    username = 회원1, member = Member@0x200
    username = 회원2, member = Member@0x300
</code></pre></div></div>
<p><br /></p>

<p><strong>페치 조인과 일반 조인의 차이</strong></p>
<ul>
  <li>일반 조인: JPQL의 결과를 반환할 때 연관관계까지 고려하지 않는다. 단지 SELECT 절에 지정한 엔티티만 조회할 뿐이다.</li>
  <li>페치 조인: SELECT 절에 지정한 엔티티뿐만 아니라 지정하지 않았어도 연관된 엔티티도 함께 조회한다.</li>
</ul>

<p><br /></p>

<p><strong>페치 조인의 특징과 한계</strong></p>
<ul>
  <li>SQL 한번으로 연관된 엔티티들을 조회하여 SQL 호출 횟수를 줄여 성능을 최적화할 수 있다.</li>
  <li>JPQL에서 페치 조인을 사용하면 글로벌 전략보다 우선 적용된다.
    <ul>
      <li>글로벌 전략 예: @OneToMany(fetch = FetchType.LAZY)</li>
    </ul>
  </li>
  <li>페치 조인을 하면 쿼리 시점에 조회하므로 준영속 상태에서도 객체 그래프를 탐색할 수 있다.</li>
  <li>페치 조인 대상에는 별칭을 줄 수 없다.
    <ul>
      <li>따라서 SELECT, WHERE, 서비 쿼리에 페치 조인 대상을 사용할 수 없다.</li>
      <li>하이버네이트에서는 페치 조인에 별칭을 지원한다. 하지만 잘못 사용하면 연관된 데이터 수가 달라져 무결성이 깨질 수 있다.</li>
    </ul>
  </li>
  <li>둘 이상의 컬렉션을 페치할 수 없다.</li>
  <li>컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.
    <ul>
      <li>컬렉션(일대다)이 아닌 단일 값 연관 필드(일대일, 다대일)은 페치 조인 가능</li>
      <li>하이버네이트는 컬렉션을 페치 조인하고 페이징 API를 사용하면 경고 로그를 남기고 메모리에서 페이징 처리한다. 하지만 성능 이슈가 발생할 수 있다.</li>
    </ul>
  </li>
</ul>

<p class="notice--info"><strong>추천은 글로벌 전략은 지연 로딩을 사용하고 최적화가 필요하면 그 때 페치 조인을 적용한다.</strong></p>

<p><br />
<br /></p>

<h3 id="1028-경로-표현식">10.2.8 경로 표현식</h3>
<p>경로 표현식이란 m.username, m.team 처럼 .(점)을 찍어 객체 그래프를 탐색하는 것이다.</p>

<p><strong>경로 표현식의 용어 정리</strong></p>
<ul>
  <li>상태 필드: 단순히 값을 저장하기 위한 필드</li>
  <li>연관 필드: 연관관계를 위한 필드, 임베디드 타입 포함
    <ul>
      <li>단일 값 연관필드: @ManyToOne, @OneToOne, 대상이 엔티티</li>
      <li>컬렉션 값 연관 필드: @OneToMany, @ManyToMany, 대상이 컬렉션</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"name"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>    <span class="c1">// 상태 필드</span>

    <span class="nd">@ManyToOne</span><span class="o">(...)</span>
    <span class="kd">private</span> <span class="nc">Team</span> <span class="n">team</span><span class="o">;</span>          <span class="c1">// 연관 필드 (단일 값)</span>

    <span class="nd">@OneToMany</span><span class="o">(...)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span><span class="o">;</span> <span class="c1">// 연관 필드 (컬렉션 값)</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>경로 표현식 특징</strong><br />
JPQL에서 경로 표현식의 특징</p>
<ul>
  <li>
    <p>상태 필드 경로: 경로 탐색의 끝이다. 더는 탐색할 수 없다.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">-- JPQL</span>
  <span class="k">select</span> <span class="n">m</span><span class="p">.</span><span class="n">username</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">age</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>

  <span class="c1">-- SQL 변환</span>
  <span class="k">select</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">age</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li>
    <p>단일 값 연관 경로: 묵시적으로 내부 조인이 일어난다. 단일 값 연관 경로는 계속 탐색할 수 있다.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">-- JPQL</span>
  <span class="k">select</span> <span class="n">o</span><span class="p">.</span><span class="n">member</span> <span class="k">from</span> <span class="k">Order</span> <span class="n">o</span>  <span class="c1">-- 묵시적 조인</span>
  <span class="c1">-- where o.product.name = 'productA' 이렇게 계속 탐색 가능</span>

  <span class="c1">-- SQL 변환</span>
  <span class="k">select</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span>
  <span class="k">from</span> <span class="k">Order</span> <span class="n">o</span>
      <span class="k">inner</span> <span class="k">join</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">on</span> <span class="n">o</span><span class="p">.</span><span class="n">member_id</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">id</span> <span class="c1">-- 묵시적으로 내부 조인이 일어났다</span>
</code></pre></div>    </div>
    <p><br /></p>
  </li>
  <li>
    <p>컬렉션 값 연관 경로: 묵시적으로 내부 조인이 일어난다. 더는 탐색할 수 없다. 단 FROM 절에서 조인을 통해 별칭을 얻으면 별칭으로 탐색할 수 있다.</p>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">-- JPQL</span>
  <span class="c1">-- 성공</span>
  <span class="k">select</span> <span class="n">t</span><span class="p">.</span><span class="n">members</span> <span class="k">from</span> <span class="n">Team</span> <span class="n">t</span> 

  <span class="c1">-- 실패, 컬렉션 값은 탐색이 불가 </span>
  <span class="k">select</span> <span class="n">t</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="n">username</span> <span class="k">from</span> <span class="n">Team</span> <span class="n">t</span> 
  <span class="c1">-- 다음처럼 별칭을 얻어서 경로탐색을 해야 한다.</span>
  <span class="k">select</span> <span class="n">m</span><span class="p">.</span><span class="n">username</span> <span class="k">from</span> <span class="n">Team</span> <span class="n">t</span> <span class="k">join</span> <span class="n">t</span><span class="p">.</span><span class="n">members</span> <span class="n">m</span>

  <span class="c1">-- 컬렉션의 크기를 구할 수 있는 size기능 제공, 이를 사용하면 count함수를 사용하는 SQL로 변환된다.</span>
  <span class="k">select</span> <span class="n">t</span><span class="p">.</span><span class="n">members</span><span class="p">.</span><span class="k">size</span> <span class="k">from</span> <span class="n">Team</span> <span class="n">t</span> 
</code></pre></div>    </div>
    <p><br />
<br /></p>
  </li>
</ul>

<p><strong>경로 탐색을 사용한 묵시적 조인 시 주의사항</strong></p>
<ul>
  <li>항상 내부 조인이다.</li>
  <li>컬렉션은 경로 탐색의 끝이다. 컬렉션에서 경로 탐색을 하려면 명시적으로 조인해서 별칭을 얻어야 한다.</li>
  <li>경로 탐색은 주로 SELECT, WHERE 절(다른 곳에서도 사용됨)에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM절에 영향을 준다.</li>
</ul>

<p class="notice--info"><strong>단순하고 성능에 이슈가 없으면 문제가 안 되지만, 성능이 중요하면 분석하기 쉽도록 묵시적 조인보다는 명시적 조인을 사용하자.</strong></p>
<p><br />
<br /></p>

<h3 id="1029-서브-쿼리">10.2.9 서브 쿼리</h3>
<p>JPQL도 SQL처럼 서브 쿼리를 지원한다.</p>
<ul>
  <li>사용가능: WHERE, HAVING 절</li>
  <li>사용불가: SELECT, FROM 절
    <ul>
      <li>하이버네이트의 HQL은 SELECT 절의 서브 쿼리도 허용한다. 하지만 FROM 절의 서브 쿼리는 지원하지 않는다.<br />
<br /></li>
    </ul>
  </li>
</ul>

<p><strong>서브쿼리 예</strong></p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 나이가 평균보다 많은 회원</span>
<span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
<span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">age</span> <span class="o">&gt;</span> <span class="p">(</span><span class="k">select</span> <span class="k">avg</span><span class="p">(</span><span class="n">m2</span><span class="p">.</span><span class="n">age</span><span class="p">)</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m2</span><span class="p">)</span>

<span class="c1">-- 한 건이라도 주문한 고객</span>
<span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
<span class="k">where</span> <span class="p">(</span><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">from</span> <span class="k">Order</span> <span class="n">o</span> <span class="k">where</span> <span class="n">m</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">member</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

<span class="c1">-- 한 건이라도 주문한 고객</span>
<span class="c1">-- size 이용, 위와 결과가 같다.(실행 SQL도 같다)</span>
<span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
<span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">orders</span><span class="p">.</span><span class="k">size</span> <span class="o">&gt;</span> <span class="mi">0</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>서브 쿼리 함수</strong><br />
서브 쿼리는 다음 함수들과 같이 사용할 수 있다.</p>

<ul>
  <li>EXISTS
    <ul>
      <li>문법: [NOT] EXISTS (subquery)</li>
      <li>설명: 서브쿼리에 결과가 존재하면 참이다.
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
<span class="k">where</span> <span class="k">exists</span> <span class="p">(</span><span class="k">select</span> <span class="n">t</span> <span class="k">from</span> <span class="n">m</span><span class="p">.</span><span class="n">team</span> <span class="n">t</span> <span class="k">where</span> <span class="n">t</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">'팀A'</span><span class="p">)</span>
</code></pre></div>        </div>
        <p><br /></p>
      </li>
    </ul>
  </li>
  <li>{ALL | ANY | SOME}
    <ul>
      <li>문법: {ALL | ANY | SOME} (subquery)</li>
      <li>설명: 비교 연산자와 같이 사용한다. {= | &gt; | &gt;= | &lt; | &lt;= | &lt;&gt;}
        <ul>
          <li>ALL: 조건을 모두 만족하면 참이다.</li>
          <li>ANY 혹은 SOME: 둘은 같은 의미다. 조건을 하나라도 만족하면 참이다.</li>
        </ul>

        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">o</span> <span class="k">from</span> <span class="k">Order</span> <span class="n">o</span>
<span class="k">where</span> <span class="n">o</span><span class="p">.</span><span class="n">orderAmount</span> <span class="o">&gt;</span> <span class="k">ALL</span> <span class="p">(</span><span class="k">select</span> <span class="n">p</span><span class="p">.</span><span class="n">stockAmount</span> <span class="k">from</span> <span class="n">Product</span> <span class="n">p</span><span class="p">)</span>

<span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
<span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">team</span> <span class="o">=</span> <span class="k">ANY</span> <span class="p">(</span><span class="k">select</span> <span class="n">t</span> <span class="k">from</span> <span class="n">Team</span> <span class="n">t</span><span class="p">)</span>
</code></pre></div>        </div>
        <p><br /></p>
      </li>
    </ul>
  </li>
  <li>IN
    <ul>
      <li>문법: [NOT] IN (subquery)</li>
      <li>설명: 서브쿼리의 결과 중 하나라도 같은 것이 있으면 참이다. 참고로 IN은 서브쿼리가 아닌곳에서도 사용한다.
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">t</span> <span class="k">from</span> <span class="n">Team</span> <span class="n">t</span>
<span class="k">where</span> <span class="n">t</span> <span class="k">IN</span> <span class="p">(</span><span class="k">select</span> <span class="n">t2</span> <span class="k">From</span> <span class="n">Team</span> <span class="n">t2</span> <span class="k">JOIN</span> <span class="n">t2</span><span class="p">.</span><span class="n">members</span> <span class="n">m2</span> <span class="k">where</span> <span class="n">m2</span><span class="p">.</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">)</span>
</code></pre></div>        </div>
        <p><br />
<br /></p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="10210-조건식">10.2.10 조건식</h3>

<p><strong>타입 표현</strong><br />
JPQL에서 사용하는 타입은 다음과 같이 표시한다. 대소문자는 구분하지 않는다.</p>

<table>
    <thead>
        <tr>
            <th>종류</th>
            <th>설명</th>
            <th>예제</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>문자</td>
            <td style="word-break:break-all">
            작은 따옴표 사이에 표현<br />
            작은 따옴표를 표현하고 싶으면 작은 따옴표 연속 두개('') 사용
            </td>
            <td style="word-break:break-all">
            'HELLO'<br />
            'She''s'
            </td>
        </tr>
        <tr>
            <td>숫자</td>
            <td style="word-break:break-all">
                L(Long 타입 지정)<br />
                D(Doublc 타입 지정)<br />
                F(Float 타입 지정)
            </td>
            <td style="word-break:break-all">
                10L<br />
                10D<br />
                10F
            </td>
        </tr>
        <tr>
            <td>날짜</td>
            <td style="word-break:break-all">
                DATE {d 'yyyy-mm-dd'}<br />
                TIME {t 'hh-mm-ss'}<br />
                DATETIME {ts 'yyyy-mm-dd hh-mm:ss.f'}<br />
            </td>
            <td style="word-break:break-all">
                {d '2012-03-24'}<br />
                {t '10-11-28'}<br />
                {ts '2012-03-24 10-11-28.123'}<br />
                m.createDate = {d '2012-03-24'}
            </td>
        </tr>
        <tr>
            <td>Boolen</td>
            <td style="word-break:break-all">
                TRUE, FALSE
            </td>
            <td style="word-break:break-all"></td>
        </tr>
        <tr>
            <td>Enum</td>
            <td style="word-break:break-all">
                패키징명을 포함한 전체 이름을 사용해야 한다.
            </td>
            <td style="word-break:break-all">
                jpabook.MemberType.Admin
            </td>
        </tr>
        <tr>
            <td>엔티티 타입</td>
            <td style="word-break:break-all">
                엔티티의 타입을 표현한다. 주로 상속과 관련해서 사용한다.
            </td>
            <td style="word-break:break-all">
                TYPE(m) = Member
            </td>
        </tr>
    </tbody>
</table>
<p><br /></p>

<p><strong>연산자 우선 순위</strong></p>
<ol>
  <li>경로 탐색 연산 (.)</li>
  <li>수학 연산: +, -(단항 연산자), *, /, +, -</li>
  <li>비교연산: =, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;</li>
  <li>논리 연산: NOT, AND, OR</li>
</ol>

<p><br /></p>

<p><strong>논리 연산과 비교식</strong></p>
<ul>
  <li>논리 연산
    <ul>
      <li>AND</li>
      <li>OR</li>
      <li>NOT</li>
    </ul>
  </li>
  <li>비교식
    <ul>
      <li>=, &gt;, &gt;=, &lt;, &lt;=, &lt;&gt;</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>Between, IN, Like, NULL 비교</strong></p>
<ul>
  <li>Between 식
    <ul>
      <li>문법: x [NOT] BETWEEN A AND B</li>
      <li>설명: x는 A ~ B 사이의 값이면 참이다.(A, B값 포함)</li>
    </ul>
  </li>
  <li>IN 식
    <ul>
      <li>문법: x [NOT] IN</li>
      <li>설명: X와 같은 값이 하나라도 있으면 참이다.</li>
    </ul>
  </li>
  <li>Like 식
    <ul>
      <li>문법: 문자표현식 [NOT] LIKE 패턴값 [ESCAPE 이스케이프문자]</li>
      <li>설명: 문자표현식과 패텀값을 비교한다.
        <ul>
          <li>%(퍼센트): 아무 값들이 입력되어도 된다. 값이 없어도 된다.</li>
          <li>_(언더라인): 한 글자는 아무 값이 입력되어도 되지만 값이 있어야 된다.</li>
        </ul>
      </li>
    </ul>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 회원A, 회원1..</span>
<span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">username</span> <span class="k">like</span> <span class="s1">'회원_'</span>

<span class="c1">-- 회원3</span>
<span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">username</span> <span class="k">like</span> <span class="s1">'__3'</span>

<span class="c1">-- 회원%</span>
<span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">username</span> <span class="k">like</span> <span class="s1">'회원</span><span class="se">\%</span><span class="s1">'</span> <span class="k">ESCAPE</span> <span class="s1">'</span><span class="se">\'</span><span class="s1">
</span></code></pre></div>    </div>
  </li>
  <li>NULL 비교식
    <ul>
      <li>문법: {단일값 경로 | 입력 파라미터} IS [NOT] NULL</li>
      <li>설명: NULL인지 비교한다. NULL은 = 으로 비교하면 안 되고 꼭 IS NULL을 사용 해야 한다.</li>
    </ul>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">username</span> <span class="k">is</span> <span class="k">null</span>
 <span class="k">where</span> <span class="k">null</span> <span class="o">=</span> <span class="k">null</span> <span class="c1">-- 거짓</span>
 <span class="k">where</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">-- 참</span>
</code></pre></div>    </div>
    <p><br />
<br /></p>
  </li>
</ul>

<p><strong>컬렉션 식</strong><br />
컬렉션에만 사용하는 특별한 기능이다. <strong>컬렉션은 컬렉션 식 이외에 다른 식은 사용할 수 없다.</strong></p>

<ul>
  <li>빈 컬렉션 비교 식
    <ul>
      <li>문법: {컬렉션 값 연관 경로} IS [NOT] EMPTY</li>
      <li>설명: 컬렉션에 값이 비었으면 참</li>
    </ul>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- JPQL</span>
<span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
<span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">orders</span> <span class="k">is</span> <span class="k">not</span> <span class="n">empty</span>

<span class="c1">-- SQL 변환</span>
<span class="k">select</span> <span class="n">m</span><span class="p">.</span><span class="o">*</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
<span class="k">where</span> <span class="k">exists</span> <span class="p">(</span>
  <span class="k">select</span> <span class="n">o</span><span class="p">.</span><span class="n">id</span>
  <span class="k">from</span> <span class="n">Orders</span> <span class="n">o</span>
  <span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">member_id</span>
<span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>컬렉션의 멤버 식
    <ul>
      <li>문법: {엔티티나 값} [NOT] MEMBER [OF] {컬렉션 값 연관 경로}</li>
      <li>설명: 엔티티마 값이 컬렉션에 포함되어 있으면 참</li>
    </ul>

    <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">t</span> <span class="k">from</span> <span class="n">Team</span> <span class="n">t</span>
<span class="k">where</span> <span class="p">:</span><span class="n">memberParam</span> <span class="n">member</span> <span class="k">of</span> <span class="n">t</span><span class="p">.</span><span class="n">members</span>
</code></pre></div>    </div>
    <p><br />
<br /></p>
  </li>
</ul>

<p><strong>스칼라 식</strong><br />
스칼라는 숫자, 문자, 날짜, case, 엔티티 타입같은 가장 기본적인 타입들을 말한다.</p>

<ul>
  <li>수학 식
    <ul>
      <li>+, -: 단항 연산자 (양수, 음수)</li>
      <li>*, /, +, -: 사칙 연산<br />
<br /></li>
    </ul>
  </li>
  <li>문자 함수</li>
</ul>

<table>
    <thead>
        <tr>
            <th>함수</th>
            <th>설명</th>
            <th>예제</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>CONCAT(문자1, 문자2, ...)</td>
            <td style="word-break:break-all">
                문자를 합한다.
            </td>
            <td style="word-break:break-all">
                CONCAT('A', 'B') = AB
            </td>
        </tr>
        <tr>
            <td>SUBSTRING(문자, 위치, [길이])</td>
            <td style="word-break:break-all">
                위치부터 시작해 길이만큼 문자를 구한다.
                길이 값이 없으면 나머지 전체 길이를 뜻한다.
            </td>
            <td style="word-break:break-all">
                SUBSTRING('ABCDEF', 2, 3) = BCD
            </td>
        </tr>
        <tr>
            <td>TRIM([[LEADING | TRAILING | BOTH] [트림문자] FROM] 문자)</td>
            <td style="word-break:break-all">
                LEADING: 왼쪽만 트림<br />
                TRAILING: 오른쪽만 트림<br />
                BOTH: 양쪽 다 트림<br />
                기본값은 BOTH<br />
                트림 문자의 기본값은 공백(space)이다.
            </td>
            <td style="word-break:break-all">
                TRIM('ABC') = 'ABC'
            </td>
        </tr>
        <tr>
            <td>LOWER(문자)</td>
            <td style="word-break:break-all">
                소문자로 변경
            </td>
            <td style="word-break:break-all">
                LOWER('ABC') = 'abc'
            </td>
        </tr>
        <tr>
            <td>UPPER(문자)</td>
            <td style="word-break:break-all">
                대문자로 변경
            </td>
            <td style="word-break:break-all">
                UPPER('abc') = 'ABC'
            </td>
        </tr>
        <tr>
            <td>LENGTH(문자)</td>
            <td style="word-break:break-all">
                문자 길이
            </td>
            <td style="word-break:break-all">
                LENGTH('ABC') = 3
            </td>
        </tr>
        <tr>
            <td>LOCATE(찾을 문자, 원본 문자, [검색 시작 위치])</td>
            <td style="word-break:break-all">
                검색위치부터 문자를 검색한다. 1부터 시작, 못 찾으면 0 반환
            </td>
            <td style="word-break:break-all">
                LOCATE('DE', 'ABCDEFG') = 4
            </td>
        </tr>
    </tbody>
</table>
<p><br /></p>

<ul>
  <li>수학 함수</li>
</ul>

<table>
    <thead>
        <tr>
            <th>함수</th>
            <th>설명</th>
            <th>예제</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>ABS(수학식)</td>
            <td style="word-break:break-all">
                절대값을 구한다
            </td>
            <td style="word-break:break-all">
                ABS(-10) = 10
            </td>
        </tr>
        <tr>
            <td>SQRT(수학식)</td>
            <td style="word-break:break-all">
                제곱근을 구한다.
            </td>
            <td style="word-break:break-all">
                SQRT(4) = 2.0
            </td>
        </tr>
        <tr>
            <td>MOD(수학식, 나눌 수)</td>
            <td style="word-break:break-all">
                나머지를 구한다.
            </td>
            <td style="word-break:break-all">
                MOD(4, 3) = 1
            </td>
        </tr>
        <tr>
            <td>SIZE(컬렉션 값 연관 경로식)</td>
            <td style="word-break:break-all">
                컬렉션의 크기를 구한다
            </td>
            <td style="word-break:break-all">
                SIZE(t.members)
            </td>
        </tr>
        <tr>
            <td>INDEX(별칭)</td>
            <td style="word-break:break-all">
                LIST 타입 컬렉션의 위치값을 구함, 단 컬렉션이 @OrderColumn을 사용하는 LIST 타입일 때만 사용할 수 있다.
            </td>
            <td style="word-break:break-all">
                t.members m where INDEX(m) &gt; 0
            </td>
        </tr>
    </tbody>
</table>
<p><br /></p>

<ul>
  <li>날짜 함수<br />
날짜 함수는 데이터베이스의 현재 시간을 조회한다.
    <ul>
      <li>CURRENT_DATE: 현재 날짜</li>
      <li>CURRENT_TIME: 현재 시간</li>
      <li>CURRENT_TIMESTAMP: 현재 날짜 시간</li>
    </ul>
  </li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">CURRENT_DATE</span><span class="p">,</span> <span class="k">CURRENT_TIME</span><span class="p">,</span> <span class="k">CURRENT_TIMESTAMP</span> <span class="k">from</span> <span class="n">Team</span> <span class="n">t</span>

<span class="k">select</span> <span class="n">e</span> <span class="k">from</span> <span class="n">Event</span> <span class="n">e</span> <span class="k">where</span> <span class="n">e</span><span class="p">.</span><span class="n">endDate</span> <span class="o">&lt;</span> <span class="k">CURRENT_DATE</span>
</code></pre></div></div>
<p>하이버네이트는 날짜 타입에서 년, 월, 일, 시간, 분, 초 값을 구하는 기능을 지원한다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- YEAR, MONTH, DAY, HOUR, MINUTE, SECOND</span>
<span class="k">select</span> <span class="nb">year</span><span class="p">(</span><span class="k">CURRENT_TIMESTAMP</span><span class="p">),</span> <span class="k">month</span><span class="p">(</span><span class="k">CURRENT_TIMESTAMP</span><span class="p">)</span> <span class="k">from</span> <span class="n">Member</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>CASE 식</strong><br />
특정 조건에 따라 분기할 때 CASE 식을 사용한다.</p>
<ul>
  <li>기본 CASE
    <ul>
      <li>문법:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CASE
    {WHEN &lt;조건식&gt; THEN &lt;스칼라식&gt;}+
    ELSE &lt;스칼라식&gt;
END
</code></pre></div>        </div>
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span>
    <span class="k">case</span> <span class="k">when</span> <span class="n">m</span><span class="p">.</span><span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="k">then</span> <span class="s1">'학생요금'</span>
         <span class="k">when</span> <span class="n">m</span><span class="p">.</span><span class="n">age</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="k">then</span> <span class="s1">'경로요금'</span>
         <span class="k">else</span> <span class="s1">'일반요금'</span>
    <span class="k">end</span>
<span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
</code></pre></div>        </div>
        <p><br /></p>
      </li>
    </ul>
  </li>
  <li>심플 CASE
    <ul>
      <li>문법:
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    CASE
        {WHEN &lt;스칼라식1&gt; THEN &lt;스칼라식2&gt;}+
        ELSE &lt;스칼라식&gt;
    END
</code></pre></div>        </div>
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span>
    <span class="k">case</span> <span class="n">t</span><span class="p">.</span><span class="n">name</span>
        <span class="k">when</span> <span class="s1">'팀A'</span> <span class="k">then</span> <span class="s1">'인센티브110%'</span>
        <span class="k">when</span> <span class="s1">'팀B'</span> <span class="k">then</span> <span class="s1">'인센티브120%'</span>
        <span class="k">else</span> <span class="s1">'인센티브105%'</span>
    <span class="k">end</span>
<span class="k">from</span> <span class="n">Team</span> <span class="n">t</span>
</code></pre></div>        </div>
        <p><br /></p>
      </li>
    </ul>
  </li>
  <li>COALESCE
    <ul>
      <li>문법: COALESCE(<스칼라식> {, <스칼라식>}+)</스칼라식></스칼라식></li>
      <li>설명: 스칼라식을 차례대로 조회해서 null이 아니면 반환한다.
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- m.username이 null이 아니면 '이름 없는 회원'을 반환한다.</span>
<span class="k">select</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">username</span><span class="p">,</span> <span class="s1">'이름 없는 회원'</span><span class="p">)</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
</code></pre></div>        </div>
        <p><br /></p>
      </li>
    </ul>
  </li>
  <li>NULLIF
    <ul>
      <li>문법: NULLIF(<스칼라식>, <스칼라식>)</스칼라식></스칼라식></li>
      <li>설명: 두 값이 같으면 null을 반환하고 다르면 첫 번째 값을 반환한다.
        <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 관리자면 null을 반환하고 나머지는 본인 이름을 반환</span>
<span class="k">select</span> <span class="k">nullif</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">username</span><span class="p">,</span> <span class="s1">'관리자'</span><span class="p">)</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
</code></pre></div>        </div>
        <p><br />
<br />
<br /></p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="10211-다형성-쿼리">10.2.11 다형성 쿼리</h3>
<p>JPQL로 부모 엔티티를 조회하면 그 자식 엔티티도 함께 조회된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Inheritance</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">InheritanceType</span><span class="o">.</span><span class="na">SINGLE_TABLE</span><span class="o">)</span>
<span class="nd">@DiscriminatorColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"DTYPE"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="o">{...}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"B"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>다음을 조회하면 Item의 자식도 함께 조회된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select t from Item i"</span><span class="o">).</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 단일 테이블 전략(InheritanceType.SINGLE_TABLE) SQL</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">ITEM</span>

<span class="c1">-- 조인 전략(InheritanceType.JOINED) SQL</span>
<span class="k">SELECT</span> 
    <span class="n">i</span><span class="p">.</span><span class="n">ITEM_ID</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">DTYPE</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">price</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">stockQuantity</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">author</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">isbn</span><span class="p">,</span>
    <span class="n">b</span><span class="p">.</span><span class="n">artist</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">ect</span><span class="p">,</span>
    <span class="n">m</span><span class="p">.</span><span class="n">actor</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">director</span>
<span class="k">FROM</span>
    <span class="n">ITEM</span> <span class="n">i</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span>
    <span class="n">BOOK</span> <span class="n">b</span> <span class="k">on</span> <span class="n">i</span><span class="p">.</span><span class="n">ITEM_ID</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">ITEM_ID</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span>
    <span class="n">ALBUM</span> <span class="n">a</span> <span class="k">on</span> <span class="n">i</span><span class="p">.</span><span class="n">ITEM_ID</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">ITEM_ID</span>
<span class="k">LEFT</span> <span class="k">OUTER</span> <span class="k">JOIN</span>
    <span class="n">MOVIE</span> <span class="n">M</span> <span class="k">on</span> <span class="n">i</span><span class="p">.</span><span class="n">ITEM_ID</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">ITEM_ID</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>TYPE</strong><br />
TYPE은 엔티티의 상속 구조에서 조회 대상을 특정 자식 타입으로 한정할 때 주로 사용한다.</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- Item 중에 Book, Movie를 조회하라.</span>
<span class="c1">-- JPQL </span>
<span class="k">select</span> <span class="n">i</span> <span class="k">from</span> <span class="n">Item</span> <span class="n">i</span>
<span class="k">where</span> <span class="k">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">IN</span> <span class="p">(</span><span class="n">Book</span><span class="p">,</span> <span class="n">Movie</span><span class="p">)</span>

<span class="c1">-- SQL</span>
<span class="k">SELECT</span> <span class="n">i</span> <span class="k">FROM</span> <span class="n">Item</span> <span class="n">i</span>
<span class="k">WHERE</span> <span class="n">i</span><span class="p">.</span><span class="n">DTYPE</span> <span class="k">in</span> <span class="p">(</span><span class="s1">'B'</span><span class="p">,</span><span class="s1">'M'</span><span class="p">)</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>TREAT (JPA 2.1)</strong><br />
자바의 타입 캐스팅과 비슷한다. 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용한다.<br />
JPA 표준은 FROM, WHERE 절에서 사용할 수 있지만, 하이버네이트는 SELECT 절에서도 사용할 수 있다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- JPQL</span>
<span class="c1">-- treat를 사용해서 부모 타입인 Item을 자식 타입인 Book으로 다룬다.</span>
<span class="c1">-- 따라서 Book의 author 필드에 접근 할 수 있다.</span>
<span class="k">select</span> <span class="n">i</span> <span class="k">from</span> <span class="n">Item</span> <span class="n">i</span> <span class="k">where</span> <span class="k">treat</span><span class="p">(</span><span class="n">i</span> <span class="k">as</span> <span class="n">Book</span><span class="p">).</span><span class="n">author</span> <span class="o">=</span> <span class="s1">'kim'</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h3 id="10212-사용자-정의-함수-호출-jpa-21">10.2.12 사용자 정의 함수 호출 (JPA 2.1)</h3>
<p>JPA 2.1부터 사용자 저의 함수를 지원한다.</p>

<p>문법</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function_invocation::= FUNCTION(function_name {, function_arg}*)
</code></pre></div></div>
<p>예</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">function</span><span class="p">(</span><span class="s1">'group_concat'</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="k">from</span> <span class="n">Item</span> <span class="n">i</span>

<span class="c1">-- 하이버네이트 구현체는 축약 가능</span>
<span class="k">select</span> <span class="n">group_concat</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="k">from</span> <span class="n">Item</span> <span class="n">i</span>
</code></pre></div></div>
<p>하이버네이트 구현체를 사용한다면 방언 클래스를 상속해서 구현하고, 사용할 데이터베이스 함수를 미리 등록해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 방언 클래스 상속</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyH2Dialect</span> <span class="kd">extends</span> <span class="nc">H2Dialect</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">MyH2Dialect</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">registerFunction</span><span class="o">(</span>
            <span class="s">"group_concat"</span><span class="o">,</span>
            <span class="k">new</span> <span class="nf">StandardSQLFunction</span><span class="o">(</span><span class="s">"group_concat"</span><span class="o">,</span> <span class="nc">StandardBasicTypes</span><span class="o">.</span><span class="na">STRING</span><span class="o">)</span>
        <span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 상속한 방언 클래스 등록 --&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.dialect"</span> <span class="na">value=</span><span class="s">"hello.MyH2Dialect"</span><span class="nt">&gt;</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="10213-기타-정리">10.2.13 기타 정리</h3>
<ul>
  <li>enum은 = 비교 연산만 지원한다.</li>
  <li>임베디드 타입은 비교를 지원하지 않는다.</li>
</ul>

<p><strong>EMPTY STRING</strong></p>
<ul>
  <li>JPA 표준은 ‘‘을 길이 0인 Empty String으로 정했지만 데이터베이스에 따라 ‘‘를 NULL로 사용하는 데이터베이스도 있으므로 확인하고 사용해야 한다.<br />
<br /></li>
</ul>

<p><strong>NULL 정의</strong></p>
<ul>
  <li>조건을 만족하는 데이터가 하나도 없으면 NULL이다.</li>
  <li>NULL은 알 수 없는 값(unknown value)이다. NULL과의 모든 수학적 계산 결과는 NULL이 된다.</li>
  <li>NULL == NULL은 알 수 없는 값이다.</li>
  <li>NULL is NULL은 참이다.<br />
<br /></li>
</ul>

<p><strong>JPA 표준 명세 NULL(U), TRUE(T), FALSE(F)의 논리 계산 표</strong></p>
<ul>
  <li>AND</li>
</ul>

<table>
  <thead>
    <tr>
      <th><strong>AND</strong></th>
      <th><strong>T</strong></th>
      <th><strong>F</strong></th>
      <th><strong>U</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>T</td>
      <td>T</td>
      <td>F</td>
      <td>U</td>
    </tr>
    <tr>
      <td>F</td>
      <td>F</td>
      <td>F</td>
      <td>F</td>
    </tr>
    <tr>
      <td>U</td>
      <td>U</td>
      <td>F</td>
      <td>U</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>OR</li>
</ul>

<table>
  <thead>
    <tr>
      <th><strong>OR</strong></th>
      <th><strong>T</strong></th>
      <th><strong>F</strong></th>
      <th><strong>U</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>T</td>
      <td>T</td>
      <td>T</td>
      <td>T</td>
    </tr>
    <tr>
      <td>F</td>
      <td>T</td>
      <td>F</td>
      <td>U</td>
    </tr>
    <tr>
      <td>U</td>
      <td>T</td>
      <td>U</td>
      <td>U</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>NOT</li>
</ul>

<table>
  <thead>
    <tr>
      <th><strong>NOT</strong></th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>T</td>
      <td>F</td>
    </tr>
    <tr>
      <td>F</td>
      <td>T</td>
    </tr>
    <tr>
      <td>U</td>
      <td>U</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h3 id="10214-엔티티-직접-사용">10.2.14 엔티티 직접 사용</h3>

<p><strong>기본 키 값</strong><br />
JPQL에서 엔티티 객체를 직접 사용하면 SQL에서는 해당 엔티티의 기본 키 값을 사용한다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- JPQL</span>
<span class="c1">-- 엔티티의 아이디를 사용</span>
<span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>

<span class="c1">-- 엔티티를 직접 사용</span>
<span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 엔티티를 파라미터로 직접 사용하는 방법</span>
<span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"select m from Member m where m = :member"</span><span class="o">;</span>
<span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">)</span>
            <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"member"</span><span class="o">,</span> <span class="n">member</span><span class="o">)</span>
            <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>


<span class="c1">// 식별자 값을 직접 사용하는 방법</span>
<span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"select m from Member m where m.id = :memberId"</span><span class="o">;</span>
<span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">)</span>
            <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"memberId"</span><span class="o">,</span> <span class="mi">1L</span><span class="o">)</span>
            <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>외래 키 값</strong><br />
외래 키 값도 엔티티 객체를 직접 사용할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 엔티티를 파라미터로 직접 사용하는 방법</span>
<span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"select m from Member m where m.team = :team"</span><span class="o">;</span>
<span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">)</span>
            <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"team"</span><span class="o">,</span> <span class="n">team</span><span class="o">)</span>
            <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>


<span class="c1">// 식별자 값을 직접 사용하는 방법</span>
<span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"select m from Member m where m.team.id = :teamId"</span><span class="o">;</span>
<span class="nc">List</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">)</span>
            <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"teamId"</span><span class="o">,</span> <span class="mi">1L</span><span class="o">)</span>
            <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="10215-named-쿼리-정적-쿼리">10.2.15 Named 쿼리: 정적 쿼리</h3>
<p>Named 쿼리는 애플리케이션 로딩 시점에 JPQL 문법을 체크하고 미리 파싱해둔다. 따라서 에러 유무를 빨리 확인할 수 있고, 재사용하므로 성능상 이점도 있다.</p>

<p><strong>Named 쿼리를 어노테이션에 정의</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @NamedQuery로 Named 쿼리 정의</span>
<span class="nd">@Entity</span>
<span class="nd">@NamedQuery</span><span class="o">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"Member.findByUsername"</span><span class="o">,</span>
    <span class="n">query</span> <span class="o">=</span> <span class="s">"select m from Member m where m.username = :username"</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @NamedQueries를 사용해 여러개의 @NamedQuery 지정</span>
<span class="nd">@Entity</span>
<span class="nd">@NamedQueries</span><span class="o">(</span>
    <span class="nd">@NamedQuery</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"Member.findByUsername"</span><span class="o">,</span>
        <span class="n">query</span> <span class="o">=</span> <span class="s">"select m from Member m where m.username = :username"</span>
    <span class="o">),</span>
    <span class="nd">@NamedQuery</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"Member.count"</span><span class="o">,</span>
        <span class="n">query</span> <span class="o">=</span> <span class="s">"select count(m) from Member m"</span>
    <span class="o">)</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 사용</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createNamedQuery</span><span class="o">(</span><span class="s">"Member.findByUsername"</span><span class="o">,</span> <span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">setPrameter</span><span class="o">(</span><span class="s">"username"</span><span class="o">,</span> <span class="s">"회원1"</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<p class="notice--info">Named 쿼리에 Member.findByUsername 처럼 Member를 붙인 것은 기능적으로 특별한 의미가 있는 것이 아니다. 충동방지, 관리의 용이함을 위해 붙인 것이다.</p>

<p><br />
<br />
<br />
<br />
<br /></p>

<h2 id="103-criteria">10.3 Criteria</h2>
<p>Criteria 쿼리는 JPQL을 자바 코드로 작성하도록 도와주는 빌더 클래스 API다. 문자가 아닌 코드로 JPQL을 작성하므로 문법 오류를 컴파일 단계에서 잡을 수 있다. 동적 쿼리를 안전하게 생성할 수 있다. 다만 코드가 복잡하고 장황해서 직관적으로 이해가 힘들다는 단점이 있다.</p>

<p><strong>내용 생략 😅</strong></p>

<p><br />
<br />
<br /></p>

<h2 id="104-querydsl">10.4 QueryDSL</h2>
<p>QueryDSL은 Criteria 처럼 JPQL 빌더 역할을 하는데 쉽고 간결하며, 그 모양도 쿼리와 비슷하게 개발할 수 있다.</p>

<p>QueryDSL은 오픈소스 프로젝트이다. 아래 사이트 참고</p>

<ul>
  <li><a href="http://querydsl.com" target="_blank">QueryDSL</a></li>
  <li><a href="http://querydsl.com/static/querydsl/4.0.1/reference/ko-KR/html_single/" target="_blank">QueryDSL 레퍼런스 번역 문서</a></li>
</ul>

<p><br /></p>

<h3 id="1041-querydsl-설정">10.4.1 QueryDSL 설정</h3>
<p><strong>필요 라이브러리</strong></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- QueryDSL JPA 라이브러리 --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>com.querydsl<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>querydsl-jpa<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>${querydsl.version}<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>

<span class="c">&lt;!-- 쿼리 타입(Q)을 생성할 때 필요한 라이브러리 --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>com.querydsl<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>querydsl-apt<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>${querydsl.version}<span class="nt">&lt;/version&gt;</span>
  <span class="nt">&lt;scope&gt;</span>provided<span class="nt">&lt;/scope&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>환경설정</strong><br />
QueryDSL을 사용하려면 <strong>엔티티를 기반으로 쿼리 타입 이라는 쿼리용 클래스를 생성해야 한다.</strong> 다음처럼 플러그인을 추가해야 한다.</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;project&gt;</span>
  <span class="nt">&lt;build&gt;</span>
    <span class="nt">&lt;plugins&gt;</span>
        ...
        <span class="nt">&lt;plugin&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>com.mysema.maven<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>apt-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span>1.1.3<span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;executions&gt;</span>
            <span class="nt">&lt;execution&gt;</span>
            <span class="nt">&lt;goals&gt;</span>
                <span class="nt">&lt;goal&gt;</span>process<span class="nt">&lt;/goal&gt;</span>
            <span class="nt">&lt;/goals&gt;</span>
            <span class="nt">&lt;configuration&gt;</span>
                <span class="nt">&lt;outputDirectory&gt;</span>target/generated-sources/java<span class="nt">&lt;/outputDirectory&gt;</span>
                <span class="nt">&lt;processor&gt;</span>com.querydsl.apt.jpa.JPAAnnotationProcessor<span class="nt">&lt;/processor&gt;</span>
            <span class="nt">&lt;/configuration&gt;</span>
            <span class="nt">&lt;/execution&gt;</span>
        <span class="nt">&lt;/executions&gt;</span>
        <span class="nt">&lt;/plugin&gt;</span>
        ...
    <span class="nt">&lt;/plugins&gt;</span>
  <span class="nt">&lt;/build&gt;</span>
<span class="nt">&lt;/project&gt;</span>
</code></pre></div></div>
<p>이제 콘솔에서 mvc compile을 입력하면 outputDirectory에 지정한 target/generated-sources 위치에 QMember.java 처럼 Q로 시작하는 쿼리 타입들이 생성된다.
<br />
<br /></p>

<h3 id="1042-시작">10.4.2 시작</h3>

<p>간단 예제</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">queryDSL</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">JPAQuery</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JPAQuery</span><span class="o">(</span><span class="n">entityManager</span><span class="o">);</span>
    <span class="nc">QMember</span> <span class="n">qMember</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QMember</span><span class="o">(</span><span class="s">"m"</span><span class="o">);</span> <span class="c1">// 생성되는 JPQL의 별칭이 m</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">qMember</span><span class="o">)</span>
                                <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">qMember</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"회원1"</span><span class="o">))</span>
                                <span class="o">.</span><span class="na">orderBy</span><span class="o">(</span><span class="n">qMember</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">desc</span><span class="o">)</span>
                                <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">qMember</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>기본 Q 생성</strong><br />
쿼리 타입(Q)는 사용하기 편리하도록 다음과 같이 기본 인스턴스를 보관하고 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">QMember</span> <span class="kd">extends</span> <span class="nc">EntityPathBase</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">QMember</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QMember</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>같은 엔티티를 조인하거나, 같은 엔티티를 서브쿼리에 사용하면 같은 별칭이 사용되므로 이때는 별징을 직접 지정해서 사용해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">QMember</span> <span class="n">qMember</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QMember</span><span class="o">(</span><span class="s">"m"</span><span class="o">);</span>  <span class="c1">// 직접 지정</span>
<span class="nc">QMember</span> <span class="n">qMember</span> <span class="o">=</span> <span class="nc">QMember</span><span class="o">.</span><span class="na">member</span><span class="o">;</span>    <span class="c1">// 기본 인스턴스 사용</span>
</code></pre></div></div>
<p>다음과 같이 import static을 활용하면 코드를 간결하게 작성 가능하다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">jpabook</span><span class="o">.</span><span class="na">jpashop</span><span class="o">.</span><span class="na">domain</span><span class="o">.</span><span class="na">QMember</span><span class="o">.</span><span class="na">member</span><span class="o">;</span> <span class="c1">// 기본 인스턴스</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">basic</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">JPAQuery</span> <span class="n">query</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JPAQuery</span><span class="o">(</span><span class="n">entityManager</span><span class="o">);</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">member</span><span class="o">)</span>  <span class="c1">// member 바로 사용</span>
                        <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"회원1"</span><span class="o">))</span>
                        <span class="o">.</span><span class="na">orderBy</span><span class="o">(</span><span class="n">member</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">desc</span><span class="o">)</span>
                        <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1043-검색-조건-쿼리">10.4.3 검색 조건 쿼리</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// where and</span>
<span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">customer</span><span class="o">)</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">customer</span><span class="o">.</span><span class="na">firstName</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">).</span><span class="na">and</span><span class="o">(</span><span class="n">customer</span><span class="o">.</span><span class="na">lastName</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"Wilson"</span><span class="o">)));</span>

<span class="c1">// where or</span>
<span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">customer</span><span class="o">)</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">customer</span><span class="o">.</span><span class="na">firstName</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">).</span><span class="na">or</span><span class="o">(</span><span class="n">customer</span><span class="o">.</span><span class="na">lastName</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"Wilson"</span><span class="o">)));</span>

<span class="c1">// between</span>
<span class="c1">// 1800 ~ 2000 년도</span>
<span class="n">doc</span><span class="o">.</span><span class="na">year</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="s">"1800"</span><span class="o">,</span> <span class="s">"2000"</span><span class="o">);</span>

<span class="c1">// contains</span>
<span class="c1">// sql의 like '%상품1%'</span>
<span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"상품1"</span><span class="o">);</span>

<span class="c1">// startsWith</span>
<span class="c1">// sql의 like '오%'</span>
<span class="n">person</span><span class="o">.</span><span class="na">firstName</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"오"</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1044-결과-조회">10.4.4 결과 조회</h3>
<p>쿼리 작성이 끝나고 결과 조회 메소드를 호출하면 실제 데이터베이스를 조회한다. 결과 조회 API는 com.mysema.query.Projectable에 정의되어 있다.</p>

<ul>
  <li>uniqueResult(): 조회 결과가 한 건일 때 사용. 조회 결과가 없으면 null을 반환하고 하나 이상이면 예외 발생</li>
  <li>singleResult(): uniqueResult()와 같지만 결과가 하나 이상이면 처음 데이터를 반환</li>
  <li>list(): 결과가 하나 이상일 때 사용. 결과가 없으면 빈 컬렉션 반환</li>
</ul>

<p><br />
<br /></p>

<h3 id="1045-페이징과-정렬">10.4.5 페이징과 정렬</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="mi">20000</span><span class="o">))</span>
    <span class="o">.</span><span class="na">orderBy</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">desc</span><span class="o">(),</span> <span class="n">item</span><span class="o">.</span><span class="na">stockQuantity</span><span class="o">.</span><span class="na">asc</span><span class="o">())</span>
    <span class="o">.</span><span class="na">offset</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
    <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
</code></pre></div></div>
<p>실제 페이징 처리를 하려면 검색된 전체 데이터 수를 알아야 한다. 이때는 list() 대신에 listResults()를 사용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SearchResults</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
                <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="mi">20000</span><span class="o">))</span>
                <span class="o">.</span><span class="na">orderBy</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">desc</span><span class="o">(),</span> <span class="n">item</span><span class="o">.</span><span class="na">stockQuantity</span><span class="o">.</span><span class="na">asc</span><span class="o">())</span>
                <span class="o">.</span><span class="na">offset</span><span class="o">(</span><span class="mi">10</span><span class="o">).</span><span class="na">limit</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
                <span class="o">.</span><span class="na">listResults</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>

<span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getTotal</span><span class="o">();</span> <span class="c1">// 검색된 전체 데이터 수</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getResults</span><span class="o">();</span> <span class="c1">// 조회된 데이터</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1046-그룹">10.4.6 그룹</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
    <span class="o">.</span><span class="na">groupBy</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">)</span>
    <span class="o">.</span><span class="na">having</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="mi">1000</span><span class="o">))</span>
    <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1047-조인">10.4.7 조인</h3>
<p>조인은 innerJoin, leftJoin, rightJoin, fullJoin을 사용할 수 있다. 추가로 JPQL의 fetch조인도 사용할 수 있다.</p>

<p>조인의 기본 문법은 첫 번째 파라미터에 조인 대상을 지정하고, 두 번째 파라미터에 별칭으로 사용할 쿼리 타입을 지정한다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>join(조인대상, 별칭으로 사용할 쿼리 타입)
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기본 사용 방법</span>
<span class="nc">QCat</span> <span class="n">cat</span> <span class="o">=</span> <span class="nc">QCat</span><span class="o">.</span><span class="na">cat</span><span class="o">;</span>
<span class="nc">QCat</span> <span class="n">mate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QCat</span><span class="o">(</span><span class="s">"mate"</span><span class="o">);</span>
<span class="nc">QCate</span> <span class="n">kitten</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QCat</span><span class="o">(</span><span class="s">"kitten"</span><span class="o">);</span>
<span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">cat</span><span class="o">)</span>
    <span class="o">.</span><span class="na">innerJoin</span><span class="o">(</span><span class="n">cat</span><span class="o">.</span><span class="na">mate</span><span class="o">,</span> <span class="n">mate</span><span class="o">)</span>
    <span class="o">.</span><span class="na">leftJoin</span><span class="o">(</span><span class="n">cat</span><span class="o">.</span><span class="na">kittens</span><span class="o">,</span> <span class="n">kitten</span><span class="o">)</span>
    <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">cat</span><span class="o">);</span>


<span class="c1">// 조인 on 사용</span>
<span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">cat</span><span class="o">)</span>
    <span class="o">.</span><span class="na">leftJoin</span><span class="o">(</span><span class="n">cat</span><span class="o">.</span><span class="na">kittens</span><span class="o">,</span> <span class="n">kitten</span><span class="o">)</span>
    <span class="o">.</span><span class="na">on</span><span class="o">(</span><span class="n">kitten</span><span class="o">.</span><span class="na">bodyWeight</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="mf">10.0</span><span class="o">))</span>
    <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">cat</span><span class="o">);</span>


<span class="c1">// 페치 조인 사용</span>
<span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">cat</span><span class="o">)</span>
    <span class="o">.</span><span class="na">innerJoin</span><span class="o">(</span><span class="n">cat</span><span class="o">.</span><span class="na">mate</span><span class="o">,</span> <span class="n">mate</span><span class="o">).</span><span class="na">fetch</span><span class="o">()</span>
    <span class="o">.</span><span class="na">leftJoin</span><span class="o">(</span><span class="n">cat</span><span class="o">.</span><span class="na">kittens</span><span class="o">,</span> <span class="n">kitten</span><span class="o">).</span><span class="na">fetch</span><span class="o">()</span>
    <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">cat</span><span class="o">);</span>

<span class="c1">// 세타 조인 사용</span>
<span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">cat</span><span class="o">,</span> <span class="n">mate</span><span class="o">)</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">cat</span><span class="o">.</span><span class="na">mate</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">mate</span><span class="o">))</span>
    <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">cat</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1048-서브-쿼리">10.4.8 서브 쿼리</h3>
<ul>
  <li>서브 쿼리를 만들려면 com.mysema.query.jpa.JPASubQuery를 사용하면 된다.</li>
  <li>서브 쿼리 결과가 하나면 unique(), 여러 건이면 list()를 사용한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 서브 쿼리 한 건</span>
<span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">QItem</span> <span class="n">itemSub</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QItem</span><span class="o">(</span><span class="s">"itemSub"</span><span class="o">);</span>

<span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span>
        <span class="k">new</span> <span class="nf">JPASubQuery</span><span class="o">().</span><span class="na">from</span><span class="o">(</span><span class="n">itemSub</span><span class="o">).</span><span class="na">unique</span><span class="o">(</span><span class="n">itemSub</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">max</span><span class="o">())</span>
    <span class="o">))</span>
    <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>



<span class="c1">// 서브 쿼리 여러 건</span>
<span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">QItem</span> <span class="n">itemSub</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">QItem</span><span class="o">(</span><span class="s">"itemSub"</span><span class="o">);</span>

<span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
    <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">in</span><span class="o">(</span>
        <span class="k">new</span> <span class="nf">JPASubQuery</span><span class="o">().</span><span class="na">from</span><span class="o">(</span><span class="n">itemSub</span><span class="o">)</span>
            <span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="n">itemSub</span><span class="o">.</span><span class="na">name</span><span class="o">))</span>
            <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">itemSub</span><span class="o">)</span>
    <span class="o">))</span>
    <span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1049-프로젝션과-결과-반환">10.4.9 프로젝션과 결과 반환</h3>
<p>select 절에 조회 대상을 지정하는 것을 프로젝션이라 한다.</p>

<p><strong>프로젝션 대상이 하나</strong><br />
프로젝션 대상이 하나면 해당 타입으로 반환한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">).</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>여러 컬럼 반환고 튜플</strong><br />
프로젝션 대상이 여러 필드를 선택하면 QueryDSL은 기본적으로 com.mysema.query.Tuple이라는 내부 타입을 사용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Tuple</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">).</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">);</span>

<span class="k">for</span> <span class="o">(</span><span class="nc">Tuple</span> <span class="n">tuple</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">tuple</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>   <span class="c1">// name</span>
    <span class="n">tuple</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">);</span>  <span class="c1">// price</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>빈 생성</strong><br />
쿼리 결과를 엔티티가 아닌 특정 객체로 받고 싶으면 빈 생성 기능을 사용한다. QueryDSL은 다음을 사용해 객체를 생성한다.</p>
<ul>
  <li>프로퍼티 접근</li>
  <li>필드 직접 접근</li>
  <li>생성자 사용</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ItemDTO</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">price</span><span class="o">;</span>

    <span class="c1">// 생성자 ...</span>
    <span class="c1">// Getter, Setter ...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p>프로퍼티 접근</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">ItemDTO</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
<span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="nc">Projections</span><span class="o">.</span><span class="na">bean</span><span class="o">(</span><span class="nc">ItemDTO</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">"username"</span><span class="o">),</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">));</span>
</code></pre></div></div>
<p>Projections.bean()메소드는 Setter를 사용해서 값을 채운다.
<br /></p>

<p>필드 직접 접근</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">ItemDTO</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
<span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="nc">Projections</span><span class="o">.</span><span class="na">fields</span><span class="o">(</span><span class="nc">ItemDTO</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="s">"username"</span><span class="o">),</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">));</span>
</code></pre></div></div>
<p>Projections.fields()메소드는 필드에 직접 접근해서 값을 채운다.
<br /></p>

<p>생성자 사용</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">ItemDTO</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
<span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="nc">Projections</span><span class="o">.</span><span class="na">constructor</span><span class="o">(</span><span class="nc">ItemDTO</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">));</span>
</code></pre></div></div>
<p>생성자를 사용하려면 지정한 프로젝션과 파라미터 순서가 같은 생성자가 필요하다.
<br /></p>

<p>DISTINCT
distinct는 다음과 같이 사용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">query</span><span class="o">.</span><span class="na">distinct</span><span class="o">().</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">)...</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="10410-수정-삭제-배치-쿼리">10.4.10 수정, 삭제 배치 쿼리</h3>
<p>QuertDSL도 수정, 삭제 같은 배치 쿼리를 지원한다. JPQL 배치 쿼리와 같이 영속성 컨텍스트를 무시하고 데이터베이스를 직접 쿼리한다는 점에 유의하자.</p>

<p><strong>수정 배치 쿼리</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">JPAUpdateClause</span> <span class="n">updateClause</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JPAUpdateClause</span><span class="o">(</span><span class="n">em</span><span class="o">,</span> <span class="n">item</span><span class="o">);</span>
<span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">updateClause</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"시골개발자의 JPA책"</span><span class="o">))</span>
                    <span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">100</span><span class="o">))</span>
                    <span class="o">.</span><span class="na">execute</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>삭제 배치 쿼리</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">JPADeleteClause</span> <span class="n">deleteClause</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JPADeleteClause</span><span class="o">(</span><span class="n">em</span><span class="o">,</span> <span class="n">item</span><span class="o">);</span>
<span class="kt">long</span> <span class="n">count</span> <span class="o">=</span> <span class="n">deleteClause</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">eq</span><span class="o">(</span><span class="s">"시골개발자의 JPA책"</span><span class="o">)).</span><span class="na">execute</span><span class="o">();</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="10411-동적-쿼리">10.4.11 동적 쿼리</h3>
<p>com.mysema.query.BooleanBuilder를 사용하면 특정 조건에 따른 동적 쿼리를 편리하게 생성할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SearchParam</span> <span class="n">param</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SearchParam</span><span class="o">();</span>
<span class="n">param</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"시골개발자"</span><span class="o">);</span>
<span class="n">param</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span>

<span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>

<span class="nc">BooleanBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BooleanBuilder</span><span class="o">();</span>
<span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasText</span><span class="o">(</span><span class="n">param</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
    <span class="n">builder</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">param</span><span class="o">.</span><span class="na">getName</span><span class="o">()));</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">(</span><span class="n">param</span><span class="o">.</span><span class="na">getPrice</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">builder</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="n">param</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()));</span>
<span class="o">}</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">).</span><span class="na">where</span><span class="o">(</span><span class="n">builder</span><span class="o">).</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="10412-메소드-위임">10.4.12 메소드 위임</h3>
<p>메소드 위임 기능을 사용하면 쿼리 타입에 검색 조건을 직접 정의할 수 있다.</p>

<p><strong>검색 조건 정의</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ItemExpression</span> <span class="o">{</span>

    <span class="nd">@QueryDelegate</span><span class="o">(</span><span class="nc">Item</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">BooleanExpression</span> <span class="nf">isExpensive</span><span class="o">(</span><span class="nc">QItem</span> <span class="n">item</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">gt</span><span class="o">(</span><span class="n">price</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>메소드 위임 기능을 사용하려면 정적(static) 메소드를 만들고 @QueryDelegate 어노테이션에 속성으로 이 기능을 적용할 엔티티를 지정한다.</li>
  <li>정적 메소드의 첫 번째 파라미터에는 대상 엔티티의 쿼리 타입(Q)을 지정하고 나머지는 필요한 파라미터를 정의한다.</li>
</ul>

<p><strong>쿼리 타입(Q)에 생성된 결과</strong><br />
QItem에 생성된 결과는 다음과 같다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">QItem</span> <span class="kd">extends</span> <span class="nc">EntityPathBase</span><span class="o">&lt;</span><span class="nc">ITem</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="kd">public</span> <span class="n">com</span><span class="o">.</span><span class="na">mysema</span><span class="o">.</span><span class="na">query</span><span class="o">.</span><span class="na">types</span><span class="o">.</span><span class="na">expr</span><span class="o">.</span><span class="na">BooleanExpression</span> <span class="nf">isExpensive</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">ItemExpression</span><span class="o">.</span><span class="na">isExpensive</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">price</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>사용</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">query</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="n">item</span><span class="o">).</span><span class="na">where</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">isExpensive</span><span class="o">(</span><span class="mi">30000</span><span class="o">)).</span><span class="na">list</span><span class="o">(</span><span class="n">item</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<p>필요하다면 String, Date 같은 자바 기본 내장 타입에도 메소드 위임 기능을 사용할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@QueryDelegate</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">BooleanExpression</span> <span class="nf">isHelloStart</span><span class="o">(</span><span class="nc">StringPath</span> <span class="n">stringPath</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">stringPath</span><span class="o">.</span><span class="na">startsWith</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br />
<br /></p>

<h2 id="105-네이티브-sql">10.5 네이티브 SQL</h2>
<p>JPQL은 표준 SQL이 지원하는 대부분의 문법과 SQL 함수들을 지원하지만 특정 데이터베이스에 종속적인 기능은 지원하지 않는다. 예를 들면 다음과 같은 것들이다.</p>

<ul>
  <li>특정 데이터베이스만 지원하는 함수, 문법, SQL쿼리 힌트</li>
  <li>인라인뷰(From 절에서 사용하는 서브쿼리), UNION, INTERSECT</li>
  <li>스토어드 프로시저<br />
<br /></li>
</ul>

<p>때로는 특정 데이터베이스에 종속적인 기능이 필요하다. JPA 구현체들은 JPA 표준보다 더 다양한 방법을 지원한다.</p>
<ul>
  <li>특정 데이터베이스만 사용하는 함수
    <ul>
      <li>JPQL에서 네이티브 SQL 함수를 호출할 수 있다.(JPA 2.1)</li>
      <li>하이버네이트는 데이터베이스 방언에 각 데이터베이스에 종속적인 함수들을 정의해두었다. 또한 직접 호출할 함수를 정의할 수도 있다.</li>
    </ul>
  </li>
  <li>특정 데이터베이스만 지원하는 SQL 쿼리 힌트
    <ul>
      <li>하이버네이트를 포함한 몇몇 JPA 구현체들이 지원한다.</li>
    </ul>
  </li>
  <li>인라인 뷰(From 절에서 사용하는 서브쿼리), UNION, INTERSECT
    <ul>
      <li>하이버네이트는 지원하지 않지만 몇몇 JPA 구현체들이 지원한다.</li>
    </ul>
  </li>
  <li>스토어 프로시저
    <ul>
      <li>JPQL에서 스토어드 프로시저를 호출할 수 있다.(JPA 2.1)</li>
    </ul>
  </li>
  <li>특정 데이터베이스만 지원하는 문법
    <ul>
      <li>이때는 네이티브 SQL을 사용해야 한다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p>다양한 이유로 JPQL을 사용할 수 없을 때 JPA는 SQL을 직접 사용할 수 있는 기능을 제공하는데 이를 네이티브 SQL이라 한다.</p>

<p>그렇다면 <strong>네이티브 SQL과 JDBC API를 직접 사용하는 것과의 차이점</strong>은 무엇일까?
<strong>네이티브 SQL을 사용하면 엔티티를 조회할 수 있고, JPA가 지원하는 영속성 컨텍스트의 기능을 그대로 사용할 수 있다.</strong></p>

<h3 id="1051-네이티브-sql-사용">10.5.1 네이티브 SQL 사용</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 결과 타입 정의</span>
<span class="kd">public</span> <span class="nc">Query</span> <span class="nf">createNativeQuery</span><span class="o">(</span><span class="nc">String</span> <span class="n">sqlString</span><span class="o">,</span> <span class="nc">Calss</span> <span class="n">resultClass</span><span class="o">);</span>

<span class="c1">// 결과 타입을 정의할 수 없을 때</span>
<span class="kd">public</span> <span class="nc">Query</span> <span class="nf">createNativeQuery</span><span class="o">(</span><span class="nc">String</span> <span class="n">sqlString</span><span class="o">);</span>

<span class="c1">// 결과 매핑 사용</span>
<span class="kd">public</span> <span class="nc">Query</span> <span class="nf">createNativeQuery</span><span class="o">(</span><span class="nc">String</span> <span class="n">sqlString</span><span class="o">,</span> <span class="nc">String</span> <span class="n">resultSetMapping</span><span class="o">);</span>
</code></pre></div></div>
<p><strong>내용 생략 😅</strong>
<br />
<br /></p>

<h2 id="106-객체지향-쿼리-심화">10.6 객체지향 쿼리 심화</h2>
<h3 id="1061-벌크-연산">10.6.1 벌크 연산</h3>
<p>한 번에 수정하거나 삭제하는 벌크 연산을 사용할 수 있다.</p>

<p><strong>UPDATE 벌크 연산</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sqlString</span><span class="o">;</span>
    <span class="s">"update Product p "</span> <span class="o">+</span>
    <span class="s">"set p.price = p.price * 1.1 "</span> <span class="o">+</span>
    <span class="s">"where p.stockAmount &lt; :stockAmount"</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">sqlString</span><span class="o">)</span>
            <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"stockAmount"</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
            <span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>DELETE 벌크 연산</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sqlString</span><span class="o">;</span>
    <span class="s">"delete from Product p "</span> <span class="o">+</span>
    <span class="s">"where p.price &lt; :price"</span><span class="o">;</span>

<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">sqlString</span><span class="o">)</span>
            <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"price"</span><span class="o">,</span> <span class="mi">100</span><span class="o">)</span>
            <span class="o">.</span><span class="na">executeUpdate</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>벌크 연산의 주의점</strong><br />
벌크 연산을 사용할 때는 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다는 점에 주의해야 한다.</p>

<p><strong>해결 방법</strong></p>
<ul>
  <li>em.refresh() 사용</li>
  <li>벌크 연산 먼저 실행</li>
  <li>벌크 연산 수행 후 영속성 컨텍스트 초기화</li>
</ul>

<p><br />
<br /></p>

<h3 id="1062-영속성-컨텍스트와-jpql">10.6.2 영속성 컨텍스트와 JPQL</h3>
<p><strong>쿼리 후 영속 상태인 것과 아닌 것</strong></p>
<ul>
  <li>영속 상태
    <ul>
      <li>엔티티</li>
    </ul>
  </li>
  <li>영속 상태 아닌 것
    <ul>
      <li>임베디드 타입</li>
      <li>단순 필드 조회</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>em.find() 동작 순서</strong></p>
<ul>
  <li>엔티티를 영속성 컨텍스트에서 먼저 찾고</li>
  <li>없으면 데이터베이스에서 찾는다.</li>
</ul>

<p><br /></p>

<p><strong>JPQL 동작 순서</strong></p>
<ul>
  <li>최초 조회
    <ul>
      <li>데이터베이스에서 조회</li>
      <li>엔티티를 영속성 컨텍스트에 등록</li>
    </ul>
  </li>
  <li>두 번째 조회
    <ul>
      <li>데이터베이스에서 조회</li>
      <li>영속성 컨텍스트에 같은 엔티티 발견</li>
      <li>새로 검색한 엔티티는 버리고 영속성 컨텍스트에 있는 기존 엔티티 반환</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>JPQL 특징 정리</strong></p>
<ul>
  <li>JPQL은 항상 데이터베이스를 조회한다.</li>
  <li>JPQL로 조회한 엔티티는 영속 상태다.</li>
  <li>영속성 컨텍스트에 이미 존재하는 엔티티가 있으면 기존 엔티티를 반환한다.</li>
</ul>

<p><br />
<br /></p>

<h3 id="1063-jpql과-플러시-모드">10.6.3 JPQL과 플러시 모드</h3>

<p><strong>플러시 모드</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">setFlushMode</span><span class="o">(</span><span class="nc">FlushModeType</span><span class="o">.</span><span class="na">AUTO</span><span class="o">);</span>    <span class="c1">// 커밋, 쿼리 실행 시 플러시 (기본값)</span>
<span class="n">em</span><span class="o">.</span><span class="na">setFlushMode</span><span class="o">(</span><span class="nc">FlushModeType</span><span class="o">.</span><span class="na">COMMIT</span><span class="o">);</span>  <span class="c1">// 커밋시에만 플러시</span>
</code></pre></div></div>
<ul>
  <li>JPQL은 영속성 컨텍스트에 있는 데이터를 고려하지 않고 데이터베이스에서 데이터를 조회한다.</li>
  <li>따라서 JPQL을 실행하기 전에 플러시를 통해 영속성 컨텍스트의 내용을 데이터베이스에 반영해야 한다.</li>
</ul>

<p><br /></p>

<h2 id="107-정리">10.7 정리</h2>
<ul>
  <li>JPQL은 SQL을 추상화해서 특정 데이터베이스 기술에 의존하지 않는다.</li>
  <li>Criteria나 QueryDSL은 JPQL을 만들어주는 빌더 역할을 할 뿐이므로 핵심은 JPQL을 잘 알아야 한다.</li>
  <li>Criteria나 QueryDSL을 사용하면 동적으로 변하는 쿼리를 편리하게 작성할 수 있다.</li>
  <li>Criteria는 JPA가 공식 지원하는 기능이지만 불편하다. QueryDSL은 JPA가 공식 지원하는 기능은 아니지만 편리하다.</li>
  <li>JPA도 네이티브 SQL을 제공하므로 직접 SQL을 사용할 수 있다. 하지만 특정 데이터베이스에 종속적이 되므로 최대한 사용을 자제하자.</li>
  <li>JPQL은 대량의 데이터를 수정하거나 삭제하는 벌크 연산을 지원한다.</li>
</ul>

<p><br />
<br />
<br /></p>

<h1 id="11-웹-애플리케이션-제작">11. 웹 애플리케이션 제작</h1>
<p><strong>내용 생략 😅</strong><br />
<br />
<br />
<br /></p>

<h1 id="12-스프링-데이터-jpa">12. 스프링 데이터 JPA</h1>
<h2 id="121-스프링-데이터-jpa-소개">12.1 스프링 데이터 JPA 소개</h2>
<p><a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/" target="blank_">스프링 데이터 JPA 레퍼런스 문서</a></p>

<ul>
  <li>스프링 데이터 JPA는 스프링 프레임워크에서 JPA를 편리하게 사용할 수 있도록 지원하는 프로젝트다.</li>
  <li>CURD를 처리하기 위한 공통 인터페이스를 제공한다.</li>
  <li>인터페이스만 작성하면 실행 시점에 구현 객체를 동적으로 생성해서 주입해준다.</li>
  <li>따라서 데이터 접근 계층을 개발할 때 구현 클래스 없이 인터페이스만 작성해도 개발을 완료할 수 있다.</li>
</ul>

<p><br /></p>

<h2 id="122-스프링-데이터-jpa-설정">12.2 스프링 데이터 JPA 설정</h2>
<p><strong>필요 라이브러리</strong></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 스프링 데이터 JPA --&gt;</span>
<span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.springframework.data<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>spring-data-jpa<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>${spring-data-jpa.version}<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>환경 설정</strong></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- xml --&gt;</span>
<span class="c">&lt;!-- 리포지토리 인터페이스를 해당 패키지와 그 하위 패키지에서 검색한다. --&gt;</span>
<span class="nt">&lt;jpa:repositories</span> <span class="na">base-package=</span><span class="s">"jpabook.jpashop.repository"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// java config class</span>
<span class="nd">@Configuration</span>
<span class="nd">@EnableJpaRepositories</span><span class="o">(</span><span class="n">basePackage</span> <span class="o">=</span> <span class="s">"jpabook.jpashop.repository"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="123-공통-인터페이스-기능">12.3 공통 인터페이스 기능</h2>
<p>스프링 데이터 JPA는 간단한 CRUD 기능을 공통으로 처리하는 <code class="language-plaintext highlighter-rouge">JpaRepository</code> 인터페이스를 제공한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JpaRepository 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">ID</span> <span class="kd">extends</span> <span class="nc">Serializable</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">PagingAndSortingRepository</span><span class="o">&lt;</span><span class="no">T</span><span class="o">,</span> <span class="no">ID</span><span class="o">&gt;</span> <span class="o">{...}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JpaRepository 인터페이스 사용</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{}</span>
</code></pre></div></div>
<center><img src="/assets/images/posts/books/2/12_3_공통인터페이스구성.png" width="100%" height="100%" /></center>
<p><br />
<br /></p>

<h2 id="124-쿼리-메소드-기능">12.4 쿼리 메소드 기능</h2>
<p>스프링 데이터 JPA가 제공하는 쿼리 메소드 기능</p>
<ul>
  <li>메소드 이름으로 쿼리 생성</li>
  <li>메소드 이름으로 <code class="language-plaintext highlighter-rouge">JPA NamedQuery</code> 호출</li>
  <li><code class="language-plaintext highlighter-rouge">@Query</code> 어노테이션을 사용해서 리포지터리 인터페이스에 쿼리 직접 정의</li>
</ul>

<p><br /></p>

<h3 id="1241-메소드-이름으로-쿼리-생성">12.4.1 메소드 이름으로 쿼리 생성</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이메일과 이름으로 회원을 조회 메소드를 정의</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByEmailAndName</span><span class="o">(</span><span class="nc">String</span> <span class="n">email</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 스프링 데이터 JPA가 메소드를 분석해서 JPQL을 생성하고 실행한다.</span>
<span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">email</span> <span class="o">=?</span><span class="mi">1</span> <span class="k">and</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="o">?</span><span class="mi">2</span>
</code></pre></div></div>

<p><strong>규칙</strong><br />
<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation" target="_blank">스프링 데이터 JPA 쿼리 생성 기능</a></p>

<table>
    <thead>
        <tr>
        <th>키워드</th>
        <th>예</th>
        <th>JPQL 예</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><p><code>Distinct</code></p></td>
            <td><p><code>findDistinctByLastnameAndFirstname</code></p></td>
            <td><p><code>select distinct …​ where x.lastname = ?1 and x.firstname = ?2</code></p></td>
        </tr>
        <tr>
            <td><p><code>And</code></p></td>
            <td><p><code>findByLastnameAndFirstname</code></p></td>
            <td><p><code>… where x.lastname = ?1 and x.firstname = ?2</code></p></td>
        </tr>
        <tr>
            <td><p><code>Or</code></p></td>
            <td><p><code>findByLastnameOrFirstname</code></p></td>
            <td><p><code>… where x.lastname = ?1 or x.firstname = ?2</code></p></td>
        </tr>
        <tr>
            <td><p><code>Is</code>, <code>Equals</code></p></td>
            <td><p><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></p></td>
            <td><p><code>… where x.firstname = ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>Between</code></p></td>
        <td><p><code>findByStartDateBetween</code></p></td>
        <td><p><code>… where x.startDate between ?1 and ?2</code></p></td>
        </tr>
        <tr>
        <td><p><code>LessThan</code></p></td>
        <td><p><code>findByAgeLessThan</code></p></td>
        <td><p><code>… where x.age &lt; ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>LessThanEqual</code></p></td>
        <td><p><code>findByAgeLessThanEqual</code></p></td>
        <td><p><code>… where x.age &lt;= ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>GreaterThan</code></p></td>
        <td><p><code>findByAgeGreaterThan</code></p></td>
        <td><p><code>… where x.age &gt; ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>GreaterThanEqual</code></p></td>
        <td><p><code>findByAgeGreaterThanEqual</code></p></td>
        <td><p><code>… where x.age &gt;= ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>After</code></p></td>
        <td><p><code>findByStartDateAfter</code></p></td>
        <td><p><code>… where x.startDate &gt; ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>Before</code></p></td>
        <td><p><code>findByStartDateBefore</code></p></td>
        <td><p><code>… where x.startDate &lt; ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>IsNull</code>, <code>Null</code></p></td>
        <td><p><code>findByAge(Is)Null</code></p></td>
        <td><p><code>… where x.age is null</code></p></td>
        </tr>
        <tr>
        <td><p><code>IsNotNull</code>, <code>NotNull</code></p></td>
        <td><p><code>findByAge(Is)NotNull</code></p></td>
        <td><p><code>… where x.age not null</code></p></td>
        </tr>
        <tr>
        <td><p><code>Like</code></p></td>
        <td><p><code>findByFirstnameLike</code></p></td>
        <td><p><code>… where x.firstname like ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>NotLike</code></p></td>
        <td><p><code>findByFirstnameNotLike</code></p></td>
        <td><p><code>… where x.firstname not like ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>StartingWith</code></p></td>
        <td><p><code>findByFirstnameStartingWith</code></p></td>
        <td><p><code>… where x.firstname like ?1</code> (parameter bound with appended <code>%</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>EndingWith</code></p></td>
        <td><p><code>findByFirstnameEndingWith</code></p></td>
        <td><p><code>… where x.firstname like ?1</code> (parameter bound with prepended <code>%</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>Containing</code></p></td>
        <td><p><code>findByFirstnameContaining</code></p></td>
        <td><p><code>… where x.firstname like ?1</code> (parameter bound wrapped in <code>%</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>OrderBy</code></p></td>
        <td><p><code>findByAgeOrderByLastnameDesc</code></p></td>
        <td><p><code>… where x.age = ?1 order by x.lastname desc</code></p></td>
        </tr>
        <tr>
        <td><p><code>Not</code></p></td>
        <td><p><code>findByLastnameNot</code></p></td>
        <td><p><code>… where x.lastname &lt;&gt; ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>In</code></p></td>
        <td><p><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></p></td>
        <td><p><code>… where x.age in ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>NotIn</code></p></td>
        <td><p><code>findByAgeNotIn(Collection&lt;Age&gt; ages)</code></p></td>
        <td><p><code>… where x.age not in ?1</code></p></td>
        </tr>
        <tr>
        <td><p><code>True</code></p></td>
        <td><p><code>findByActiveTrue()</code></p></td>
        <td><p><code>… where x.active = true</code></p></td>
        </tr>
        <tr>
        <td><p><code>False</code></p></td>
        <td><p><code>findByActiveFalse()</code></p></td>
        <td><p><code>… where x.active = false</code></p></td>
        </tr>
        <tr>
        <td><p><code>IgnoreCase</code></p></td>
        <td><p><code>findByFirstnameIgnoreCase</code></p></td>
        <td><p><code>… where UPPER(x.firstname) = UPPER(?1)</code></p></td>
        </tr>
    </tbody>
</table>
<p><br /></p>

<h3 id="1242-jpa-namedquery">12.4.2 JPA NamedQuery</h3>
<p>스프링 데이터 JPA는 메소드 이름으로 JPA Named 쿼리를 호출하는 기능을 제공한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @NamedQuery로 Named 쿼리 정의</span>
<span class="nd">@Entity</span>
<span class="nd">@NamedQuery</span><span class="o">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"Member.findByUsername"</span><span class="o">,</span>
    <span class="n">query</span> <span class="o">=</span> <span class="s">"select m from Member m where m.username = :username"</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 도메인 클래스 + .(점) + 메소드 이름 으로 Named 쿼리를 찾아 실행한다.</span>
<span class="c1">// Named 쿼리가 없으면 메소드 이름으로 쿼리 생성 전략을 사용한다.</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByUsername</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="1243-query-리포지토리-메소드에-쿼리-정의">12.4.3 @Query, 리포지토리 메소드에 쿼리 정의</h3>
<p>리포지토리 메소드에 직접 쿼리를 정의하려면 <code class="language-plaintext highlighter-rouge">@Query</code> 어노테이션을 사용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 메소드에 JPQL 쿼리 작성</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Query</span><span class="o">(</span><span class="s">"select m from Member m where m.username = ?1"</span><span class="o">)</span>
    <span class="nc">Member</span> <span class="nf">findByUsername</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JPA 네이티브 SQL 지원</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Query</span><span class="o">(</span><span class="s">"SELECT * FROM MEMBER FROM WHERE USERNAME = ?0"</span><span class="o">,</span> <span class="n">nativeQuery</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
    <span class="nc">Member</span> <span class="nf">findByUsername</span><span class="o">(</span><span class="nc">String</span> <span class="n">username</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1244-파라미터-바인딩">12.4.4 파라미터 바인딩</h3>
<p>스프링 데이터 JPA는 위치 기반 파라미터 바인딩과 이름 기반 파라미터 바인딩을 지원한다. 기본값은 위치 기반이다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 위치 기반, 기본값</span>
<span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="o">?</span><span class="mi">1</span>

<span class="c1">-- 이름 기반</span>
<span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="p">:</span><span class="n">name</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Query</span><span class="o">(</span><span class="s">"select m from Member m where m.username = :name"</span><span class="o">)</span>
    <span class="nc">Member</span> <span class="nf">findByUsername</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"name"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">username</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1245-벌크성-수정-쿼리">12.4.5 벌크성 수정 쿼리</h3>
<p>스프링 데이터 JPA를 사용한 벌크성 수정, 삭제 쿼리는 <code class="language-plaintext highlighter-rouge">@Modifying</code> 어노테이션을 사용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Modifying</span>
<span class="nd">@Query</span><span class="o">(</span><span class="s">"update Product p set p.price = price * 1.1 where p.stockAmount &lt; :stockAmount"</span><span class="o">)</span>
<span class="kt">int</span> <span class="nf">bulkPriceUp</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"stockAmount"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">stockAmount</span><span class="o">);</span>
</code></pre></div></div>
<p>벌크성 쿼리를 실행하고 나서 영속성 컨텍스트를 초기화하고 싶으면 <code class="language-plaintext highlighter-rouge">@Modifying(clearAutomatically = true)</code> 옵션을 준다.
<br />
<br /></p>

<h3 id="1246-반환-타입">12.4.6 반환 타입</h3>
<p>스프링 데이터 JPA는 유연한 반환 타입을 지원한다. 한 건 이상이면 컬렉션을 사용하고, 단건이면 반환 타입을 지정한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span> <span class="c1">// 컬렉션</span>
<span class="nc">Member</span> <span class="nf">findByEmail</span><span class="o">(</span><span class="nc">String</span> <span class="n">email</span><span class="o">);</span>     <span class="c1">// 단건</span>
</code></pre></div></div>

<p><strong>조회 결과가 없을 시</strong></p>
<ul>
  <li>컬렉션: 빈 컬렉션 반환</li>
  <li>단건: <code class="language-plaintext highlighter-rouge">null</code> 반환</li>
</ul>

<p><strong>조회 결과 1건</strong></p>
<ul>
  <li>컬렉션: 1건의 데이터를 가진 컬렉션 반환</li>
  <li>단건: 데이터 반환</li>
</ul>

<p><strong>조회 결과 2건 이상</strong></p>
<ul>
  <li>컬렉션: 2건 이상 데이터를 가진 컬렉션 반환</li>
  <li>단건: 예외 발생</li>
</ul>

<p><br /></p>

<h3 id="1247-페이징과-정렬">12.4.7 페이징과 정렬</h3>
<p>스프링 데이터 JPA는 쿼리 메소드에 페이징과 정렬 기능을 사용할 수 있도록 2가지 파라미터를 제공한다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">org.springframework.data.domain.Sort</code>: 정렬기능</li>
  <li><code class="language-plaintext highlighter-rouge">org.springframework.data.domain.Pageable</code>: 페이징 기능(내부에 Sort 포함)</li>
</ul>

<p><strong>페이징과 정렬 사용 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// count 쿼리 사용</span>
<span class="nc">Page</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">);</span>

<span class="c1">// count 쿼리 사용 안 함</span>
<span class="c1">// total을 제외한 Page에서 제공하는 인터페이스 사용 가능</span>
<span class="nc">Slice</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">);</span>

<span class="c1">// count 쿼리 사용 안 함</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">);</span>

<span class="c1">// 정렬</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Sort</span> <span class="n">sort</span><span class="o">);</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 사용 방법</span>
<span class="nc">PageRequest</span> <span class="n">pageRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PageRequest</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Sort</span><span class="o">(</span><span class="nc">Direction</span><span class="o">.</span><span class="na">DESC</span><span class="o">,</span> <span class="s">"name"</span><span class="o">));</span>
<span class="nc">Page</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findByName</span><span class="o">(</span><span class="s">"김"</span><span class="o">,</span> <span class="n">pageRequest</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>Slice 인터페이스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Slice</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Streamable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">getNumber</span><span class="o">();</span> <span class="c1">// 현재 페이지</span>
    <span class="kt">int</span> <span class="nf">getSize</span><span class="o">();</span> <span class="c1">//페이지 크기</span>
    <span class="kt">int</span> <span class="nf">getNumberOfElements</span><span class="o">();</span> <span class="c1">// 현재 페이지에 조회한 데이터 개수</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">getContent</span><span class="o">();</span> <span class="c1">// 현재 페이지에 조회한 데이터 </span>
    <span class="kt">boolean</span> <span class="nf">hasContent</span><span class="o">();</span> <span class="c1">// 현재 페이지에 데이터가 있는지 여부 </span>
    <span class="nc">Sort</span> <span class="nf">getSort</span><span class="o">();</span> <span class="c1">// 정렬 여부 </span>
    <span class="kt">boolean</span> <span class="nf">isFirst</span><span class="o">();</span> <span class="c1">// 첫 번째 페이지인지 여부</span>
    <span class="kt">boolean</span> <span class="nf">isLast</span><span class="o">();</span> <span class="c1">// 마지막 페이지인지 여부</span>
    <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span> <span class="c1">// 다음 페이지가 있는지 여부</span>
    <span class="kt">boolean</span> <span class="nf">hasPrevious</span><span class="o">();</span>  <span class="c1">// 이전 페이지가 있는지 여부 </span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>Page 인터페이스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Page</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Slice</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Page</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">empty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">empty</span><span class="o">(</span><span class="nc">Pageable</span><span class="o">.</span><span class="na">unpaged</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Page</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">empty</span><span class="o">(</span><span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">PageImpl</span><span class="o">&lt;&gt;(</span><span class="nc">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">(),</span> <span class="n">pageable</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kt">int</span> <span class="nf">getTotalPages</span><span class="o">();</span>     <span class="c1">// 전체 페이지 개수</span>
    <span class="kt">long</span> <span class="nf">getTotalElements</span><span class="o">();</span> <span class="c1">// 전체 데이터 개수</span>
    <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">Page</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">map</span><span class="o">(</span><span class="nc">Function</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="no">T</span><span class="o">,</span> <span class="o">?</span> <span class="kd">extends</span> <span class="no">U</span><span class="o">&gt;</span> <span class="n">converter</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1248-힌트">12.4.8 힌트</h3>
<p><code class="language-plaintext highlighter-rouge">JPA</code> 쿼리 힌트를 사용하려면 <code class="language-plaintext highlighter-rouge">@QueryHint</code>어노에티션을 사용한다. 이것은 <code class="language-plaintext highlighter-rouge">SQL</code> 힌트가 아니라 <code class="language-plaintext highlighter-rouge">JPA</code>구현체에게 제공하는 힌트다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@QueryHints</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="o">{</span>
    <span class="nd">@QueryHint</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"org.hibernate.readOnly"</span><span class="o">,</span> <span class="n">value</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="o">})</span>
<span class="nc">Page</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="125-명세">12.5 명세</h2>
<p>스프링 데이터 JPA는 <code class="language-plaintext highlighter-rouge">JPA Criteria</code>로 명세(<code class="language-plaintext highlighter-rouge">SPECIFICATION</code>)을 사용할 수 있도록 지원한다.
<a href="/etc/books/도메인주도개발시작하기/#5-스프링-데이터-jpa를-이용한-조회-기능" target="_blank">스프링 데이터 JPA를 이용한 조회 기능</a> 참고
<br />
<br />
<br /></p>

<h2 id="126-사용자-정의-리포지토리-구현">12.6 사용자 정의 리포지토리 구현</h2>
<p>스프링 데이터 JPA로 리포지토리를 개발하면 인터페이스만 정의하고 구현체는 만들지 않는다. 하지만 메소드를 직접 구현해야 할 때도 있다.</p>

<p><strong>사용자 정의 인터페이스 생성</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 인터페이스 이름은 자유롭게 작성 가능</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberRepositoryCustom</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findMemberCustom</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>사용자 정의 구현 클래스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * 클래스 이름은 리포지토리 인터페이스 이름 + Impl로 지어야 한다. 
 * 그러면 스프링 데이터 JPA가 사용자 정의 구현 클래스로 인식한다.
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberRepositoryImpl</span> <span class="kd">implements</span> <span class="n">c</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findMemberCustom</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 사용자 정의 구현...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>사용자 정의 인터페이스 상속</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberRepository</span>
    <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;,</span> <span class="nc">MemberRepositoryCustom</span> <span class="o">{}</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>사용자 정의 구현 클래스 이름 규칙 변경</strong></p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;jpa:repositories</span> <span class="na">base-package=</span><span class="s">"jpabook.jpashop.repository"</span>
    <span class="na">repository-impl-postfix=</span><span class="s">"Impl"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableJpaRepositories</span><span class="o">(</span>
    <span class="n">basePackage</span> <span class="o">=</span> <span class="s">"jpabook.jpashop.repository"</span><span class="o">,</span>
    <span class="n">repositoryImplPostfix</span> <span class="o">=</span> <span class="s">"Impl"</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="127-web-확장">12.7 Web 확장</h2>
<p>스프링 데이터 프로젝트는 스프링 MVC에서 사용할 수 있는 편리한 기능을 제공한다.</p>

<h3 id="1271-설정">12.7.1 설정</h3>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">class=</span><span class="s">"org.springframework.data.web.config.SpringDataWebConfiguration"</span><span class="nt">&gt;</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableWebMvc</span>
<span class="nd">@EnableSpringDataWebSupport</span> <span class="c1">// 추가</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebAppConfig</span> <span class="o">{...}</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="1272-도메인-클래스-컨버터-기능">12.7.2 도메인 클래스 컨버터 기능</h3>
<p>도메인 클래스 컨버터는 HTTP 파라미터로 넘어온 엔티티의 아이디로 엔티티 객체를 찾아서 바인딩 해준다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// URL: /member/memberUpdateForm?id=1</span>

<span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberController</span> <span class="o">{</span>
    
    <span class="nd">@RequestMepping</span><span class="o">(</span><span class="s">"member/memberUpdateForm"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">memberUpdateForm</span><span class="o">(</span><span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">,</span> <span class="nc">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"member"</span><span class="o">,</span> <span class="n">member</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"member/memberSaveForm"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p class="notice--warning"><strong>⚠주의</strong><br />
도메인 클래스 컨버터를 통해 넘어온 엔티티를 컨트롤러에서 직접 수정해도 실제 데이터베이스에는 반영되지 않는다. 이것은 영속성 컨텍스트의 동작 방식과 관련이 있다. 웹 애플리케이션에서 영속성 컨텍스트의 동작 방식과 OSIV에 관한 내용을 알아야 한다.</p>
<p><br />
<br /></p>

<h3 id="1273-페이징과-정렬-기능">12.7.3 페이징과 정렬 기능</h3>
<p>스프링 데이터가 제공하는 페이징과 정렬 기능을 스프링 MVC에서 편리하게 사용할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberController</span> <span class="o">{</span>
    
    <span class="c1">// 파라미터로 Pageable를 받는다</span>
    <span class="nd">@RequestMepping</span><span class="o">(</span><span class="s">"members"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">list</span><span class="o">(</span><span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">,</span> <span class="nc">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Page</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">page</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">.</span><span class="na">findMembers</span><span class="o">(</span><span class="n">pageable</span><span class="o">);</span>
        <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"member"</span><span class="o">,</span> <span class="n">page</span><span class="o">.</span><span class="na">getContent</span><span class="o">());</span>
        <span class="k">return</span> <span class="s">"member/memberList"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 예) /members?page=0&amp;size=20&amp;sort=name,desc&amp;sort=address.city</span>
</code></pre></div></div>

<div class="notice--info">
<p><strong>요청 파라미터</strong></p>
<ul>
  <li>page: 현재 페이지, 0부터 시작</li>
  <li>size: 한 페이지에 노출할 데이터 건수</li>
  <li>sort: 정렬 조건을 정의</li>
</ul>
</div>

<div class="notice--info">
<p><strong>참고</strong><br />
페이지를 1부터 시작하고 싶으면 PageableHandlerMethodArgumentResolver를 스프링 빈으로 직접 등록하고 setOneIndexedParameters를 true로 설정하면 된다.</p>
</div>
<p><br /></p>

<p><strong>접두사</strong><br />
사용해야 할 페이징 정보가 둘 이상이면 접두사를 사용해서 구분할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">String</span> <span class="nf">list</span><span class="o">(</span>
    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"member"</span><span class="o">)</span> <span class="n">pageable</span> <span class="n">memberPageable</span><span class="o">,</span>
    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">"order"</span><span class="o">)</span> <span class="n">pageable</span> <span class="n">orderPageable</span><span class="o">.</span>
    <span class="o">...</span>
<span class="o">)</span>
<span class="c1">// 예) /members?member_page=0&amp;order_page=1</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>기본값</strong><br />
<code class="language-plaintext highlighter-rouge">Pageable</code>의 기본값은 <code class="language-plaintext highlighter-rouge">page=0</code>, <code class="language-plaintext highlighter-rouge">size=20</code>이다. 만약 기본값을 변경하고 싶으면 <code class="language-plaintext highlighter-rouge">@PageableDefault</code> 어노테이션을 사용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RequestMepping</span><span class="o">(</span><span class="s">"members_page"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">list</span><span class="o">(</span><span class="nd">@PageableDefault</span><span class="o">(</span><span class="n">size</span> <span class="o">=</span> <span class="mi">12</span><span class="o">,</span> <span class="n">sort</span> <span class="o">=</span> <span class="s">"name"</span><span class="o">,</span> 
    <span class="n">direction</span> <span class="o">=</span> <span class="nc">Sort</span><span class="o">.</span><span class="na">Direction</span><span class="o">.</span><span class="na">DESC</span><span class="o">)</span> <span class="nc">Pageable</span> <span class="n">pageable</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="128-스프링-데이터-jpa가-사용하는-구현체">12.8 스프링 데이터 JPA가 사용하는 구현체</h2>
<p><strong>내용 생략 😅</strong></p>

<h2 id="129-jpa-샵에-적용">12.9 JPA 샵에 적용</h2>
<p><strong>내용 생략 😅</strong></p>

<h2 id="1210-스프링-데이터-jpa와-querydsl-통합">12.10 스프링 데이터 JPA와 QueryDSL 통합</h2>
<p>스프링 데이터 JPA는 2가지 방법으로 QueryDSL을 지원한다.</p>

<h3 id="12101-querydslpredicateexecutor-사용">12.10.1 QueryDslPredicateExecutor 사용</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 레포지토리에서 QueryDslPredicateExecutor 상속</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ItemRepository</span>
    <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;,</span> <span class="nc">QueryDslPredicateExecutor</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="o">{...}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 사용</span>
<span class="nc">QItem</span> <span class="n">item</span> <span class="o">=</span> <span class="nc">QItem</span><span class="o">.</span><span class="na">item</span><span class="o">;</span>
<span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Item</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">itemRepository</span><span class="o">.</span><span class="na">findAll</span><span class="o">(</span>
    <span class="n">item</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="s">"장난감"</span><span class="o">).</span><span class="na">and</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">price</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="mi">10000</span><span class="o">,</span> <span class="mi">20000</span><span class="o">))</span>
<span class="o">);</span>
</code></pre></div></div>

<div class="notice--warning">
<p><strong>⚠️경고</strong><br />
QueryDslPredicateExecutor는 기능의 한계가 있다. 예를 들어 join, fetch를 사용할 수 없다.</p>
</div>
<p><br /></p>

<h3 id="12102-querydslrepositorysupport-사용">12.10.2 QueryDslRepositorySupport 사용</h3>
<p><code class="language-plaintext highlighter-rouge">QueryDSL</code>의 모든 기능을 사용하려면 <code class="language-plaintext highlighter-rouge">JPAQuery</code> 객체를 직접 생성해서 사용하면 된다. 스프링 데이터 JPA가 제공하는 <code class="language-plaintext highlighter-rouge">QueryDslRepositorySupport</code>를 상속 받아 사용하면 편리하게 <code class="language-plaintext highlighter-rouge">QueryDSL</code>을 사용할 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 사용자 정의 레포지토리</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">CustomOrderRepository</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="nf">search</span><span class="o">(</span><span class="nc">OrderSearch</span> <span class="n">orderSearch</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderRepositoryImpl</span> <span class="kd">extends</span> <span class="nc">QueryDslRepositorySupport</span>
        <span class="kd">implements</span> <span class="nc">CustomOrderRepository</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">OrderRepositoryImpl</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="nf">search</span><span class="o">(</span><span class="nc">OrderSearch</span> <span class="n">orderSearch</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">QOrder</span> <span class="n">order</span> <span class="o">=</span> <span class="nc">QOrder</span><span class="o">.</span><span class="na">order</span><span class="o">;</span>
        <span class="nc">QMember</span> <span class="n">member</span> <span class="o">=</span> <span class="nc">QMember</span><span class="o">.</span><span class="na">member</span><span class="o">;</span>

        <span class="nc">JPAQuery</span> <span class="n">query</span> <span class="o">=</span> <span class="n">from</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
        <span class="c1">// 검색 조건 쿼리...</span>
        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="na">list</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br />
<br />
<br /></p>

<h1 id="13-웹-애플리케이션과-영속성-관리">13. 웹 애플리케이션과 영속성 관리</h1>
<p>컨테이너 환경에서 JPA가 동작하는 방식을 이해하고, 컨테이너 환경에서 웹 애플리케이션을 개발할 때 발생할 수 있는 문제점과 해결방안을 알아본다.<br />
<br /></p>

<h2 id="131-트랜잭션-범위의-영속성-컨텍스트">13.1 트랜잭션 범위의 영속성 컨텍스트</h2>
<p>스프링이나 J2EE 컨테이너 환경에서 JPA를 사용하면 컨테이너가 제공하는 전략을 따라야 한다.<br />
<br /></p>

<h3 id="1311-스프링-컨테이너의-기본-전략">13.1.1 스프링 컨테이너의 기본 전략</h3>
<p>스프링 컨테이너는 <strong>트랜잭션 범위의 영속성 컨텍스트 전략</strong>을 기본으로 사용한다.</p>
<center><img src="/assets/images/posts/books/2/13_1_트랜잭션범위의영속성컨텍스트.png" /></center>
<p><br /></p>

<p>스프링 프레임워크를 사용하면 보통 비즈니스 로직을 시작하는 서비스 계층에 <code class="language-plaintext highlighter-rouge">@Transactional</code> 어노테이션을 선언해서 트랜잭션을 시작한다.</p>
<center><img src="/assets/images/posts/books/2/13_1_트랜잭션범위의영속성컨텍스트2.png" /></center>
<p><br /></p>

<p><strong>트렌잭션이 같으면 같은 영속성 컨텍스트를 사용한다.</strong></p>
<center><img src="/assets/images/posts/books/2/13_1_트랜잭션과영속성컨텍스트1.png" /></center>
<p><br /></p>

<p><strong>트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.</strong></p>
<center><img src="/assets/images/posts/books/2/13_1_트랜잭션과영속성컨텍스트2.png" /></center>
<p><br />
<br /></p>

<h2 id="132-준영속-상태와-지연-로딩">13.2 준영속 상태와 지연 로딩</h2>
<p>컨테이너 환경의 기본 전략인 트랜잭션 범위의 영속성 컨텍스트 전략을 사용하면 트랜잭션이 없는 <strong>프리젠테이션 계층에서 엔티티는 준영속 상태</strong>다. 따라서 <strong>변경 감지와 지연 로딩이 동작하지 않는다.</strong></p>

<p>준영속 상태에서 지연로딩을 시도하면 <code class="language-plaintext highlighter-rouge">org.hibernate.LazyInitializationException</code> 예외가 발생한다.</p>

<p><strong>준영속 상태의 지연 로딩 해결 방법</strong></p>
<ol>
  <li>뷰가 필요한 엔티티를 미리 로딩해두는 방법
    <ul>
      <li>글로벌 페치 전략 수정</li>
      <li>JPQL 페치 조인 (fetch join)</li>
      <li>강제로 초기화</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">OSIV(open session in view)</code>를 사용해서 엔티티를 영속 상태로 유지하는 방법
<br />
<br /></li>
</ol>

<h3 id="1321-글로벌-페치-전략-수정">13.2.1 글로벌 페치 전략 수정</h3>
<p><strong>즉시 로딩 설정</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>
</code></pre></div></div>
<p>하지만 사용하지 않는 엔티티를 로딩하는 단점이 있다. 또 JPQL에서 N+1 문제가 발생한다.(페치 조인으로 해결 가능)<br />
<br />
<br /></p>

<h3 id="1322-jpql-페치-조인">13.2.2 JPQL 페치 조인</h3>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- JPQL fetch</span>
<span class="k">select</span> <span class="n">o</span> <span class="k">from</span> <span class="k">Order</span> <span class="n">o</span> <span class="k">join</span> <span class="k">fetch</span> <span class="n">o</span><span class="p">.</span><span class="n">member</span>
</code></pre></div></div>
<p>무분별하게 사용하면 화면에 맞춘 리포지토리 메소드가 증가할 수 있다. 결국 <strong>프리젠테이션 계층이 알게 모르게 데이터 접근 계층을 침범하게 된다.</strong>
<br />
<br /></p>

<h3 id="1323-강제로-초기화">13.2.3 강제로 초기화</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="nc">Order</span> <span class="nf">findOrder</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findOrder</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="n">order</span><span class="o">.</span><span class="na">getMember</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span> <span class="c1">// 프록시 강제로 초기화</span>
    <span class="k">return</span> <span class="n">order</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>하지만 프록시를 초기화하는 역할을 서비스 계층이 담당하면 뷰가 필요한 엔티티에 따라 서비스 계층의 로직을 변경해야 한다. <strong>프리젠테이션 계층이 알게 모르게 서비스 계층을 침범하게 된다.</strong>
<br />
<br /></p>

<h3 id="1324-facade-계층-추가">13.2.4 FACADE 계층 추가</h3>
<center><img src="/assets/images/posts/books/2/13_1_facade.png" /></center>

<p><strong>FACADE 계층의 역할과 특징</strong></p>
<ul>
  <li>프레젠테이션 계층과 도메인 모델 계층 간의 논리적 의존성을 분리해준다.</li>
  <li>프리젠테이션 계층에서 필요한 프록시 객체를 초기화한다.</li>
  <li>서비스 계층을 호출해서 비즈니스 로직을 실행한다.</li>
  <li>리포지토리를 직접 호출해서 뷰가 요구하는 엔티티를 찾는다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OrderFacade</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="nc">OrderService</span> <span class="n">orderService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">Order</span> <span class="nf">findOrder</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderService</span><span class="o">.</span><span class="na">findOrder</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="n">order</span><span class="o">.</span><span class="na">getMember</span><span class="o">().</span><span class="na">getName</span><span class="o">();</span> <span class="c1">// 프록시 강제로 초기화</span>
        <span class="k">return</span> <span class="n">order</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">Order</span> <span class="nf">findOrder</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findOrder</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>하지만 중간에 계층이 하나 더 끼어들게 되고, <strong>결국 더 많은 코드를 작성</strong>해야 한다. 그리고 <code class="language-plaintext highlighter-rouge">FACADE</code>에는 단순히 서비스 계층을 호출만 하는 위임 코드가 상당히 많을 것이다.
<br />
<br /></p>

<h3 id="1325-준영속-상태와-지연-로딩의-문제점">13.2.5 준영속 상태와 지연 로딩의 문제점</h3>
<p>결국 모든 문제는 엔티티가 프리젠테이션 계층에서 준영속 상태이기 때문에 발생한다.
<br />
<br /></p>

<h2 id="133-osiv">13.3 OSIV</h2>
<p>OSIV(Open Session In View)는 영속성 컨텍스트를 뷰까지 열어둔다는 뜻이다.</p>

<div class="notice--info">
<p><strong>참고</strong><br />
OSIV는 하이버네이트에서 사용하는 용어다. JPA에서는 OEIV(Open EntityManager In View)라고 한다. 하지만 관례상 모두 OSIV로 부른다.</p>
</div>
<p><br />
<br /></p>

<h3 id="1331-과거-osiv-요청-당-트랜잭션">13.3.1 과거 OSIV: 요청 당 트랜잭션</h3>
<p>클라이언트의 요청이 들어오자마자 서블릿 필터나 스프링 인터셉터에서 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션도 끝내는 것을 요청 당 트랜잭션 방식의 OSIV라 한다.</p>

<center><img src="/assets/images/posts/books/2/13_3_OSIV요청당트랜잭션.png" width="100%" height="100%" /></center>
<p><br /></p>

<p><strong>요청 당 트랜잭션 방식의 OSIV 문제점</strong></p>
<ul>
  <li>프리젠테이션 계층이 엔티티를 변경할 수도 있다.</li>
  <li>엔티티를 변경하면 영속성 컨텍스트의 변경 감지 기능이 작동해 데이터베이스에 반영해 버린다.</li>
</ul>

<p><strong>프리젠테이션 계층에서 엔티티를 수정하지 못하게 막는 방법</strong></p>
<ul>
  <li>엔티티를 읽기 전용 인터페이스로 제공</li>
  <li>읽기 전용 메소드만 가지고 있도록 엔티티 래핑</li>
  <li>DTO만 반환</li>
</ul>

<p><strong>하지만 코드량이 상당히 증가하는 단점이 있다.</strong><br />
<br />
<br /></p>

<h3 id="1332-스프링-osiv-비즈니스-계층-트랜잭션">13.3.2 스프링 OSIV: 비즈니스 계층 트랜잭션</h3>
<p>스프링 프레임워크가 제공하는 OSIV는 <strong>비즈니스 계층에서 트랜잭션을 사용하는 OSIV다.</strong></p>

<center><img src="/assets/images/posts/books/2/13_3_OSIV비즈니스트랜잭션.png" width="100%" height="100%" /></center>
<p><br /></p>

<p><strong>비즈니스 계층 트랜잭션 OSIV 특징</strong></p>
<ul>
  <li>영속성 컨텍스트를 프리젠테이션 계층까지 유지한다.</li>
  <li>프리젠테이션 계층에는 트랜잭션이 없으므로 엔티티를 수정할 수 없다.</li>
  <li>프리젠테이션 계층에는 트랜잭션이 없지만 읽을 수는 있어서(트랜잭션 없이 읽기) 지연 로딩을 할 수 있다.<br />
<br /></li>
</ul>

<p><strong>스프링 OSIV 주의사항</strong><br />
프리젠테이션 계층에서 엔티티를 수정한 직후에 트랜잭션을 시작하는 서비스 계층을 호출하면 영속성 컨텍스트를 플러시한다. 이 때 <strong>프리젠테이션 계층에서의 엔티티 수정 사항을 데이터베이스에 반영하는 문제가 발생한다.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MemberController</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">viewMember</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">.</span><span class="na">getMember</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"변경"</span><span class="o">);</span> <span class="c1">// 변경</span>

        <span class="n">memberService</span><span class="o">.</span><span class="na">biz</span><span class="o">();</span> <span class="c1">// 비스니스 로직 호출</span>
        <span class="k">return</span> <span class="s">"view"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MemberService</span> <span class="o">{</span>
    
    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">biz</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// ...비즈니스 로직 실행</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<center><img src="/assets/images/posts/books/2/13_3_OSIV주의사항.png" width="100%" height="100%" /></center>
<p><br /></p>

<p><strong>해결방법</strong><br />
비즈니스 로직을 먼저 수행한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MemberController</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">viewMember</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">memberService</span><span class="o">.</span><span class="na">biz</span><span class="o">();</span> <span class="c1">// 비스니스 로직 먼저 호출</span>

        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberService</span><span class="o">.</span><span class="na">getMember</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="s">"변경"</span><span class="o">);</span> <span class="c1">// 변경을 나중에 수행</span>
        <span class="k">return</span> <span class="s">"view"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1333-osiv-정리">13.3.3 OSIV 정리</h3>

<p><strong>스프링 OSIV의 특징</strong></p>
<ul>
  <li>OSIV는 클라이언트의 요청이 들어올 때 영속성 컨텍스트를 생성해서 요청이 끝날 때까지 같은 영속성 컨텍스트를 유지한다.</li>
  <li>엔티티 수정은 트랜잭션이 있는 계층에서만 동작한다.</li>
  <li>트랜잭션이 없는 프리젠테이션 계층은 지연 로딩을 포함해서 조회만 할 수 있다.<br />
<br /></li>
</ul>

<p><strong>스프링 OSIV의 단점</strong></p>
<ul>
  <li>OSIV를 적용하면 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있다는 점을 주의해야 한다. 특히 롤백 주의</li>
  <li>프리젠테이션 계층에서 엔티티를 수정 후 비즈니스 로직을 수행하면 엔티티 수정사항이 반영될 수 있다.</li>
  <li>지연 로딩에 의한 성능 튜닝시에 확인해야 할 부분이 넓다.<br />
<br /></li>
</ul>

<p><strong>OSIV vs FACADE vs DTO</strong><br />
FACADE든 DTO든 OSIV를 사용하는 것과 비교해서 지루한 코드를 많이 작성해야 한다.<br />
<br /></p>

<p><strong>OSIV를 사용하는 방법이 만능은 아니다</strong><br />
복잡한 화면에서는 처음부터 화면에 맞는 JPQL로 필요한 데이터들만 조회해서 DTO로 반환하는 것이 더 나은 해결책일 수 있다.<br />
<br /></p>

<p><strong>OSIV는 같은 JVM을 벗어난 원격 상황에서는 사용할 수 없다</strong><br />
원격지에서 엔티티를 지연 로딩하는 것은 불가능하다. 그리고 엔티티는 생각보다 자주 변경된다. 따라서 외부 API는 엔티티를 직접 노출하기보다는 완충 역할을 할 수 있는 DTO로 변환해서 노출하는 것이 안전하다.<br />
<br />
<br /></p>

<h2 id="134-너무-엄격한-계층">13.4 너무 엄격한 계층</h2>
<p>OSIV를 사용하면 영속성 컨텍스트가 프리젠테이션 계층까지 살아있으므로 미리 초기화할 필요가 없다. 따라서 <strong>단순한 엔티티 조회는 컨트롤러에서 리포지토리를 직접 호출해도 문제가 없다.</strong></p>
<center><img src="/assets/images/posts/books/2/13_3_OSIV리파지토리직접호출.png" width="100%" height="100%" /></center>
<p><br />
<br />
<br />
<br />
<br /></p>

<h1 id="14-컬렉션과-부가-기능">14. 컬렉션과 부가 기능</h1>
<p>이 장에서 다룰 내용</p>
<ul>
  <li>컬렉션: 다양한 컬렉션과 특징을 설명한다.</li>
  <li>컨버터: 엔티티의 데이터를 변환해서 데이터베이스에 저장한다.</li>
  <li>리스너: 엔티티에서 발생한 이벤트를 처리한다.</li>
  <li>엔티티 그래프: 엔티티를 조회할 때 연관된 엔티티들을 선택해서 함께 조회한다.</li>
</ul>

<h2 id="14-컬렉션">14. 컬렉션</h2>
<h3 id="1411-list--ordercolumn">14.1.1 List + @OrderColumn</h3>
<p><code class="language-plaintext highlighter-rouge">List</code> 인터페이스에 <code class="language-plaintext highlighter-rouge">@OrderColumn</code>을 추가하면 순서가 있는 특수한 컬렉션으로 인식한다. 데이터베이스에 순서 값을 저장해서 조회할 때 사용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"board"</span><span class="o">)</span>
    <span class="nd">@OrderColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"POSITION"</span><span class="o">)</span> <span class="c1">// 추가</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Comment</span><span class="o">&gt;</span> <span class="n">comments</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Comment</span><span class="o">&gt;();</span>
<span class="o">}</span>


<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Comment</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">comment</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"BOARD_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Board</span> <span class="n">board</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>순서가 있는 컬렉션은 데이터베이스에 순서 값도 함께 관리한다.</p>
<center><img src="/assets/images/posts/books/2/14_1_ordercolumnTable.png" width="100%" height="100%" /></center>
<p><br /></p>

<p><strong>@OrderColumn의 단점</strong><br />
@OrderColumn은 다음과 같은 단점들 때문에 실무에서 잘 사용하지 않는다.</p>
<ul>
  <li>@OrderColumn을 Board 엔티티에 매핑하므로 Comment는 POSITION의 값을 알 수 없다.</li>
  <li>Comment를 INSERT할 때 Board.comments의 위치 값을 사용해서 POSITION의 값을 UPDATE 하는 SQL이 추가로 발생한다.</li>
  <li>List를 변경하면 연관된 위치 값을 다 변경해야 한다. 예를 들어 댓글 2를 삭제하면 댓글 3, 댓글 4의 POSITION 값을 변경하는 UPDATE SQL이 2번 추가로 발생한다.</li>
  <li>데이터베이스에서 강제로 삭제하고 다른 댓글 들의 POSITION 값을 수정하지 않으면 컬렉션을 순회할 때 NullPointException이 발생한다.<br />
<br />
<br /></li>
</ul>

<h3 id="1412-orderby">14.1.2 @OrderBy</h3>
<p>@OrderBy는 데이터베이스의 ORDER BY절을 사용해서 컬렉션을 정렬한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Team</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"team"</span><span class="o">)</span>
    <span class="nd">@OrderBy</span><span class="o">(</span><span class="s">"username desc, id asc"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;();</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>초기화할 때 실행된 SQL를 보면 ORDER BY가 사용된다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">M</span><span class="p">.</span><span class="o">*</span> <span class="k">FROM</span> <span class="n">MEMBER</span> <span class="n">M</span>
<span class="k">WHERE</span> <span class="n">M</span><span class="p">.</span><span class="n">TEAM_ID</span> <span class="o">=</span> <span class="o">?</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">M</span><span class="p">.</span><span class="n">MEMBER_NAME</span> <span class="k">DESC</span><span class="p">,</span> <span class="n">M</span><span class="p">.</span><span class="n">ID</span> <span class="k">ASC</span>
</code></pre></div></div>

<div class="notice--info">
<p><strong>참고</strong><br />
하이버네이트는 <code class="language-plaintext highlighter-rouge">Set</code>에 <code class="language-plaintext highlighter-rouge">@OrderBy</code>를 적용해서 결과를 조회하면 순서를 유지하기 위해 <code class="language-plaintext highlighter-rouge">LinkedHashSet</code>을 내부에서 사용한다.</p>
</div>
<p><br />
<br /></p>

<h2 id="142-converter">14.2 @Converter</h2>
<p>컨버터를 사용하면 엔티티의 데이터를 변환해서 데이터베이스에 저장할 수 있다.</p>

<p><a href="http://localhost:4000/etc/books/도메인주도개발시작하기/#434-attributeconverter를-이용한-밸류-매핑-처리" target="_blank">AttributeConverter를 이용한 밸류 매핑 처리</a> 참고
<br />
<br /></p>

<h2 id="143-리스너">14.3 리스너</h2>
<p>JPA 리스너 기능을 사용하면 엔티티의 생명주기에 따른 이벤트를 처리할 수 있다.</p>

<p><a href="https://docs.jboss.org/hibernate/stable/entitymanager/reference/en/html/listeners.html" target="_blank">리스너 참고</a>
<br />
<br /></p>

<h3 id="1431-이벤트-종류">14.3.1 이벤트 종류</h3>
<p>이벤트 종류와 발생 시점</p>
<center><img src="/assets/images/posts/books/2/14_3_리스너시점.png" width="100%" height="100%" /></center>
<p><br />
<br /></p>

<h3 id="1432-이벤트-적용-위치">14.3.2 이벤트 적용 위치</h3>
<p>이벤트는 엔티티에서 직접 받거나 별도의 리스너를 등록해서 받을 수 있다.</p>

<p><strong>엔티티에 직접 적용</strong> <br />
<code class="language-plaintext highlighter-rouge">@PrePersist</code>, <code class="language-plaintext highlighter-rouge">@PostLoad</code>… 등을 이용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Duck</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nd">@PrePersist</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prePersist</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"prePersist"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PostPersist</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">PostPersist</span> <span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"PostPersist"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="nd">@PostLoad</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">PostLoad</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"PostLoad"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreRemove</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">PreRemove</span> <span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"PreRemove"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PostRemove</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">PostRemove</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"PostRemove"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="nd">@PreUpdate</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">PreUpdate</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"PreUpdate"</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="nd">@PostUpdate</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">PostUpdate</span> <span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"PostUpdate "</span><span class="o">);</span>
    <span class="o">}</span>    
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<p><strong>별도의 리스너 등록</strong><br />
<code class="language-plaintext highlighter-rouge">@EntityListeners</code>를 사용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@EntityListeners</span><span class="o">(</span><span class="nc">DuckListener</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Duck</span> <span class="o">{...}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DuckListener</span> <span class="o">{</span>

    <span class="nd">@PrePersist</span>
    <span class="c1">// 특정 타입이 확실하다면 특정 타입을 받을 수 있다.</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">prePersist</span><span class="o">(</span><span class="nc">Duck</span> <span class="n">obj</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"prePersist"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PostPersist</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">PostPersist</span> <span class="o">(</span><span class="nc">Duck</span> <span class="n">obj</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"PostPersist"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreRemove</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">PreRemove</span> <span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"PreRemove"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PostRemove</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">PostRemove</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"PostRemove"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>리스너는 대상 엔티티를 파라미터로 받을 수 있다. 반환 타입은 void로 설정해야 한다.<br />
<br />
<br /></p>

<p><strong>기본 리스너 사용</strong><br />
모든 엔티티에서 이벤트를 처리하기위해 기본 리스너로 등록할 수 있다.</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>

<span class="nt">&lt;entity-mappings</span> <span class="err">...</span><span class="nt">&gt;</span>
    <span class="nt">&lt;persistence-unit-metadata&gt;</span>
        <span class="nt">&lt;persistence-unit-defaults&gt;</span>
            <span class="nt">&lt;entity-listeners&gt;</span>
                <span class="nt">&lt;entity-listener</span> <span class="na">class=</span><span class="s">"jpabook.jpashop.domain.test.listener.DefaultListener"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;/entity-listener&gt;</span>
            <span class="nt">&lt;/entity-listeners&gt;</span>
        <span class="nt">&lt;/persistence-unit-defaults&gt;</span>
    <span class="nt">&lt;/persistence-unit-metadata&gt;</span>
    
<span class="nt">&lt;/entity-mappings&gt;</span>
</code></pre></div></div>
<p><br />
<br /></p>

<p><strong>더 세밀한 설정</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">javax.persistence.ExcludeDefaultListeners</code>: 기본 리스너 무시</li>
  <li><code class="language-plaintext highlighter-rouge">java.persistence.ExcludeSuperclassListners</code>: 상위 클래스 이벤트 리스너 무시</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@EntityListeners</span><span class="o">(</span><span class="nc">DuckListener</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@ExcludeDefaultListeners</span>
<span class="nd">@ExcludeSuperclassListners</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Duck</span> <span class="kd">extends</span> <span class="nc">BaseEntity</span> <span class="o">{...}</span>
</code></pre></div></div>

<div class="notice--info">
<p><strong>여러 리스너를 등록했을 때 이벤트 호출 순서</strong></p>
<ol>
  <li>기본 리스너</li>
  <li>부모 클래스 리스너</li>
  <li>리스너</li>
  <li>엔티티</li>
</ol>
</div>

<p><br />
<br />
<br /></p>

<h2 id="144-엔티티-그래프">14.4 엔티티 그래프</h2>
<p>엔티티 그래프 기능은 엔티티 조회시점에 연관된 엔티티들을 함께 조회하는 기능이다.</p>
<ul>
  <li>정적으로 정의하는 Named 엔티티 그래프</li>
  <li>동적으로 정의하는 엔티티 그래프</li>
</ul>

<h3 id="1441-named-엔티티-그래프-정적">14.4.1 Named 엔티티 그래프 (정적)</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 주문을 조회할 때 연관된 회원도 함께 조회하는 엔티티 그래프</span>
<span class="nd">@NamedEntityGraph</span><span class="o">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"Order.withMember"</span><span class="o">,</span>
    <span class="n">attributeNodes</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@NamedAttributeNode</span><span class="o">(</span><span class="s">"member"</span><span class="o">)}</span>
<span class="o">)</span>
<span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ORDERS"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
 
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ORDER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
 
    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">,</span> <span class="n">optional</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>  <span class="c1">// 주문 회원</span>
 
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@NamedEntityGraph</code>: Named 엔티티 그래프 정의한다.</li>
  <li><code class="language-plaintext highlighter-rouge">name</code> : 엔티티 그래프의 이름을 정의한다.</li>
  <li><code class="language-plaintext highlighter-rouge">attributeNodes</code> : 함께 조회할 속성을 선택한다. 이때 <code class="language-plaintext highlighter-rouge">@NamedAttributeNode</code>를 사용하고 그 값으로 함께 조회할 속성을 선택하면 된다.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">Order.member</code>가 지연 로딩으로 설정되어 있지만, 엔티티 그래프에서 함께 조회할 속성으로 <code class="language-plaintext highlighter-rouge">member</code>를 선택했으므로 이 엔티티 그래프를 사용하면 Order를 조회할 때 연관된 <code class="language-plaintext highlighter-rouge">member</code>도 함께 조회할 수 있다.</p>

<p>엔티티 그래프를 둘 이상 정의할 경우 <code class="language-plaintext highlighter-rouge">@NamedEntityGraphs</code> 사용한다.<br />
<br />
<br /></p>

<h3 id="1442-emfind에서-엔티티-그래프-사용">14.4.2 em.find()에서 엔티티 그래프 사용</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 정의한 엔티티 그래프를 찾고</span>
<span class="nc">EntityGraph</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getEntityGraph</span><span class="o">(</span><span class="s">"Order.withMember"</span><span class="o">);</span>

<span class="c1">// 엔티티 그래프는 JPA의 힌트 기능을 사용해서 동작</span>
<span class="c1">// 힌트의 값으로 찾아온 엔티티 그래프 사용</span>
<span class="nc">Map</span> <span class="n">hints</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
<span class="n">hints</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"javax.persistence.fetchgraph"</span><span class="o">,</span> <span class="n">graph</span><span class="o">);</span>

<span class="c1">// 조회할 때 힌트정보 포함</span>
<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">orderId</span><span class="o">,</span> <span class="n">hints</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1443-subgraph">14.4.3 subgraph</h3>
<p>Order -&gt; OrderItem -&gt; Item 까지 함께 조회</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@NamedEntityGraph</span><span class="o">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"Order.withAll"</span><span class="o">,</span>
    <span class="n">attributeNodes</span> <span class="o">=</span> <span class="o">{</span>
        <span class="nd">@NamedAttributeNode</span><span class="o">(</span><span class="s">"member"</span><span class="o">),</span>
        <span class="nd">@NamedAttributeNode</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"orderItems"</span><span class="o">,</span><span class="n">subgraph</span> <span class="o">=</span> <span class="s">"orderItems"</span><span class="o">)</span>
    <span class="o">},</span>
    <span class="n">subgraphs</span> <span class="o">=</span> <span class="nd">@NamedSubgraph</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"orderItems"</span><span class="o">,</span>
        <span class="n">attributeNodes</span> <span class="o">=</span> <span class="o">{</span><span class="nd">@NamedAttributeNode</span><span class="o">(</span><span class="s">"item"</span><span class="o">)}</span>
    <span class="o">)</span>
<span class="o">)</span>
<span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ORDERS"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
 
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ORDER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">,</span> <span class="n">optional</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"MEMBER_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Member</span> <span class="n">member</span><span class="o">;</span>  <span class="c1">// 주문 회원</span>

    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"order"</span><span class="o">,</span> <span class="n">cascade</span> <span class="o">=</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">ALL</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderItem</span><span class="o">&gt;</span> <span class="n">orderItems</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">OrderItem</span><span class="o">&gt;();</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ORDER_ITEM"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderItem</span> <span class="o">{</span>
 
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ORDER_ITEM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
 
    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ITEM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Item</span> <span class="n">item</span><span class="o">;</span>  <span class="c1">// 주문 상품</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Order.All</code>이라는 <code class="language-plaintext highlighter-rouge">Named</code> 엔티티 그래프 정의했다. 이 엔티티 그래프는 다음과 같이 객체 그래프를 함께 조회한다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Order</code> -&gt; <code class="language-plaintext highlighter-rouge">Member</code></li>
  <li><code class="language-plaintext highlighter-rouge">Order</code> -&gt; <code class="language-plaintext highlighter-rouge">OrderItem</code></li>
  <li><code class="language-plaintext highlighter-rouge">OrderItem</code> -&gt; <code class="language-plaintext highlighter-rouge">Item</code> (<code class="language-plaintext highlighter-rouge">Order</code>의 객체 그래프가 아니므로 <code class="language-plaintext highlighter-rouge">subgraphs</code> 속성에 정의)<br />
<br /></li>
</ul>

<p><strong>JPQL에서 엔티티 그래프 사용</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> 
    <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select o from Order o where o.id = :orderId"</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"orderId"</span><span class="o">,</span> <span class="n">orderId</span><span class="o">)</span>
    <span class="o">.</span><span class="na">setHint</span><span class="o">(</span><span class="s">"javax.persistence.fetchgraph"</span><span class="o">,</span> <span class="n">em</span><span class="o">.</span><span class="na">getEntityGraph</span><span class="o">(</span><span class="s">"Order.withAll"</span><span class="o">))</span>
    <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1445-동적-엔티티-그래프">14.4.5 동적 엔티티 그래프</h3>
<p>엔티티 그래프를 동적으로 구성하려면 <code class="language-plaintext highlighter-rouge">createEntityGraph()</code> 메소드 사용한다.</p>

<p><strong>동적 엔티티 그래프</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityGraph</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createEntityGraph</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">graph</span><span class="o">.</span><span class="na">addAttributeNodes</span><span class="o">(</span><span class="s">"member"</span><span class="o">);</span>

<span class="nc">Map</span> <span class="n">hints</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
<span class="n">hints</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"javax.persistence.fetchgraph"</span><span class="o">,</span> <span class="n">graph</span><span class="o">);</span>

<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">orderId</span><span class="o">,</span> <span class="n">hints</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>동적 엔티티 그래프 subgraph</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityGraph</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createEntityGraph</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">graph</span><span class="o">.</span><span class="na">addAttributeNodes</span><span class="o">(</span><span class="s">"member"</span><span class="o">);</span>
<span class="nc">Subgraph</span><span class="o">&lt;</span><span class="nc">OrderItem</span><span class="o">&gt;</span> <span class="n">orderItems</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">addSubgraph</span><span class="o">(</span><span class="s">"orderItems"</span><span class="o">);</span>
<span class="n">orderItems</span><span class="o">.</span><span class="na">addAttributeNodes</span><span class="o">(</span><span class="s">"item"</span><span class="o">);</span>

<span class="nc">Map</span> <span class="n">hints</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
<span class="n">hints</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"javax.persistence.fetchgraph"</span><span class="o">,</span> <span class="n">graph</span><span class="o">);</span>

<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">orderId</span><span class="o">,</span> <span class="n">hints</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1446-엔티티-그래프-정리">14.4.6 엔티티 그래프 정리</h3>
<p><strong>ROOT에서 시작</strong><br />
엔티티 그래프틑 항상 조회하는 엔티티의 ROOT에서 시작해야 한다.</p>

<p><strong>이미 로딩된 엔티티</strong><br />
영속성 컨텍스트에 해당 엔티티가 이미 로딩되어 있으면 엔티티 그래프가 적용되지 않는다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Order</span> <span class="n">order1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">orderId</span><span class="o">);</span> <span class="c1">// 이미 조회</span>
<span class="n">hints</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"javax.persistence.fetchgraph"</span><span class="o">,</span> <span class="n">em</span><span class="o">.</span><span class="na">getEntityGraph</span><span class="o">(</span><span class="s">"Order.withMember"</span><span class="o">));</span>

<span class="c1">// 엔티티 그래프가 적용되지 않고 order1과 같은 인스턴스 반환</span>
<span class="nc">Order</span> <span class="n">order2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">orderId</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>fetchgraph, loadgraph 차이</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">javax.persistence.fetchgraph</code>: 엔티티 그래프에 선택한 속성만 함께 조회</li>
  <li><code class="language-plaintext highlighter-rouge">javax.persistence.loadgraph</code>: 엔티티 그래프에 선택한 속성 + FetchType.EAGER로 설정된 연관관계 조회<br />
<br />
<br /></li>
</ul>

<h2 id="145-정리">14.5 정리</h2>
<ul>
  <li>JPA가 지원하는 컬렉션의 종류와 특징</li>
  <li>컨버터를 사용하면 엔티티의 데이터를 변환해서 데이터베이스에 저장할 수 있다.</li>
  <li>리스너를 사용하면 엔티티에서 발생한 이벤트를 받아서 처리할 수 있다.</li>
  <li>페치 조인은 객체지향 쿼리를 사용해야 하지만 엔티티 그래프를 사용하면 객체 지향 쿼리를 사용하지 않아도 원하는 객체 그래프를 한 번에 조회할 수 있다.<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="15-고급-주제와-성능-최적화">15. 고급 주제와 성능 최적화</h1>

<h2 id="151-예외-처리">15.1 예외 처리</h2>
<ul>
  <li>트랜잭션을 롤백하는 것은 데이터베이스의 반영사항만 롤백하는 것이지 수정한 자바 객체까지 원상태로 복구해주지 않는다.</li>
  <li>엔티티 수정중 예외가 발생하면 데이터베이스의 데이터는 롤백되지만 객체는 수정된 상태로 엔티티 컨텍스트에 남아있다.</li>
  <li>따라서 영속성 컨텍스트를 초기화한 다음에 사용해야 한다.</li>
  <li>트랜잭션당 영속성 컨텍스트는 트랜잭션 종료 시점에 영속성 컨텍스트도 종료되므로 문제가 발생하지 않는다.</li>
  <li><code class="language-plaintext highlighter-rouge">OSIV</code>에서 스프링 프레임워크는 영속성 컨텍스트의 범위를 트랜잭션의 범위보다 넓게 설정하면 트랜잭션 롤백시 영속성 컨텍스트를 초기화해서 문제를 예방한다.<br />
<br />
<br /></li>
</ul>

<h2 id="152-엔티티-비교">15.2 엔티티 비교</h2>
<ul>
  <li>동일성 비교는 같은 영속성 컨텍스트의 관리를 받는 영속 상태의 엔티티에만 적용할 수 있다.</li>
  <li>그 외에는 동등성 비교를 해야한다.</li>
  <li><strong>엔티티를 비교할 때는 <code class="language-plaintext highlighter-rouge">@Id</code>등과 같은 비즈니스키를 활용한 동등성 비교를 권장한다.</strong><br />
<br /><br /></li>
</ul>

<h2 id="153-프록시-심화">15.3 프록시 심화</h2>

<h3 id="1531-영속성-컨텍스트와-프록시">15.3.1 영속성 컨텍스트와 프록시</h3>
<p>영속성 컨텍스트는 자신이 관리하는 영속 엔티티의 동일성을 보장한다. 그럼 프록시로 조회한 엔티티의 동일성도 보장할까?</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 프록시 조회</span>
<span class="nc">Member</span> <span class="n">refMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
<span class="c1">// find 조회</span>
<span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>출력 결과

refMember Type = 프록시 엔티티
findMember  Type = 프록시 엔티티
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">refMember</code>는 프록시고 <code class="language-plaintext highlighter-rouge">findMember</code>는 원본 엔티티이므로 둘은 서로 다른 인스턴스로 생각할 수 있지만, 영속 엔티티의 동일성 보장을 위해 프록시로 조회된 엔티티에 대해서 같은 엔티티를 찾으면 프록시를 반환한다.</p>

<p><br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// find 조회</span>
<span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
<span class="c1">// 프록시 조회</span>
<span class="nc">Member</span> <span class="n">refMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>출력 결과

findMember  Type = 원본 엔티티
refMember Type = 원본 엔티티
</code></pre></div></div>
<p>반대로 원본 엔티티를 먼저 조회하면 프록시를 반환할 이유가 없다. 따라서 <code class="language-plaintext highlighter-rouge">refMember</code>는 원본을 반환한다.<br />
<br /></p>

<h2 id="1532-프록시-비교-타입">15.3.2 프록시 비교 타입</h2>
<p>프록시는 원본 엔티티를 상속 받아서 만들어지므로 프록시로 조회한 엔티티의 타입을 비교할 때는 == 비교를 하면 안되고 대신에 instanceof를 사용해야한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">refMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>

<span class="nc">Assert</span><span class="o">.</span><span class="na">assertFalse</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span> <span class="o">==</span> <span class="n">refMember</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span> <span class="c1">// false</span>
<span class="nc">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">refMember</span> <span class="k">instanceof</span> <span class="nc">Member</span><span class="o">);</span> <span class="c1">// true</span>
</code></pre></div></div>
<p><br /></p>

<h3 id="1533-프록시-동등성-비교">15.3.3 프록시 동등성 비교</h3>

<center><img src="/assets/images/posts/books/2/15_3_프록시접근자사용.png" width="100%" height="100%" /></center>

<p><strong>프로시 동등성 비교 주의사항</strong></p>
<ul>
  <li>프록시의 타입 비교는 <code class="language-plaintext highlighter-rouge">==</code> 대신에 <code class="language-plaintext highlighter-rouge">instanceof</code>를 사용해야 한다.</li>
  <li>프록시의 맴버변수에 직접 접근하면 안되고 접근자 메소드(<code class="language-plaintext highlighter-rouge">Getter</code>)를 사용해야 한다.<br />
<br /></li>
</ul>

<h3 id="1534-상속관계와-프록시">15.3.4 상속관계와 프록시</h3>
<center><img src="/assets/images/posts/books/2/15_3_상속관계와프록시.png " width="100%" height="100%" /></center>

<p>프록시를 부모 타입으로 조회하면 부모 타입을 기반으로 프록시가 생성된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Item</span> <span class="n">proxyItem</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getReference</span><span class="o">(</span><span class="nc">Item</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">saveBook</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>

<span class="c1">// 예외발생 java.lang.ClassCastException</span>
<span class="c1">// Book book = (Book) proxyItem;</span>

<span class="c1">// 검증</span>
<span class="nc">Assert</span><span class="o">.</span><span class="na">assertFalse</span><span class="o">(</span><span class="n">proxyItem</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">Assert</span><span class="o">.</span><span class="na">assertFalse</span><span class="o">(</span><span class="n">proxyItem</span> <span class="k">instanceof</span> <span class="nc">Book</span><span class="o">);</span>
<span class="nc">Assert</span><span class="o">.</span><span class="na">assertTrue</span><span class="o">(</span><span class="n">proxyItem</span> <span class="k">instanceof</span> <span class="nc">Item</span><span class="o">);</span>
</code></pre></div></div>
<p>따라서 다음과 같은 문제가 있다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">instanceof</code> 연산을 사용할 수 없다.</li>
  <li>하위 타입으로 다운캐스팅을 할 수 없다.<br />
<br />
<br /></li>
</ul>

<p><strong>몇 가지 해결방법</strong><br />
<strong>1. JPQL로 대상 직접 조회</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Book</span> <span class="n">jpqlBook</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select b from Book b where b.id=:bookId"</span><span class="o">,</span> <span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"bookId"</span><span class="o">,</span> <span class="n">item</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span>
            <span class="o">.</span><span class="na">getSingleResult</span><span class="o">();</span>
</code></pre></div></div>
<p>하지만 이 방법을 사용하면 다형성을 활용할 수 없다.<br />
<br /></p>

<p><strong>2. 기능을 위한 별도의 인터페이스 제공</strong></p>
<center><img src="/assets/images/posts/books/2/15_3_상속관계와프록시3.png" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 특정 기능을 제공하는 인터페이스 생성</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">TitleView</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="nf">getTitle</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Inheritance</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">InheritanceType</span><span class="o">.</span><span class="na">SINGLE_TABLE</span><span class="o">)</span>
<span class="nd">@DiscriminatorColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"DTYPE"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Item</span> <span class="kd">implements</span> <span class="nc">TitleView</span> <span class="o">{</span>

    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ITEM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>
    
    <span class="o">...</span>
    <span class="c1">// Getter, Setter</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"M"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Movie</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">director</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">actor</span><span class="o">;</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getTitle</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"[제목:"</span> <span class="o">+</span> <span class="n">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 감독:"</span> <span class="o">+</span> <span class="n">director</span> <span class="o">+</span> <span class="s">" 배우:"</span> <span class="o">+</span> <span class="n">actor</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"B"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Book</span> <span class="kd">extends</span> <span class="nc">Item</span> <span class="o">{</span>
    
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">author</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">isbn</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getTitle</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"[제목:"</span> <span class="o">+</span> <span class="n">getName</span><span class="o">()</span> <span class="o">+</span> <span class="s">" 저자:"</span> <span class="o">+</span> <span class="n">author</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 프록시 인터페이스 제공 사용</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderItem</span> <span class="o">{</span>
    <span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
    <span class="nd">@JoinColmn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ITEM_ID"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Item</span> <span class="n">item</span><span class="o">;</span>

    <span class="o">...</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printItem</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"TITLE="</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="na">getTitle</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Item의 구현체에 따라 각각 다른 getTitle() 메소드가 호출된다.</span>
<span class="nc">OrderItem</span> <span class="n">orderItem</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">OrderItem</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">saveOrderItem</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
<span class="n">orderItem</span><span class="o">.</span><span class="na">printItem</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>3. 비지터 패턴 사용</strong><br />
구현 내용 생략, 책 참고 😅</p>

<p>장점</p>
<ul>
  <li>프록시에 대한 걱정 없이 안전하게 원본 엔티티에 접근할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">instanceof</code>와 타입 캐스팅 없이 코드를 구현할 수 있다.</li>
  <li>알고리즘과 객체 구조를 분리해서 구조를 수정하지 않고 새로운 동작을 추가할 수 있다.</li>
</ul>

<p>단점</p>
<ul>
  <li>너무 복잡하고 이해하기 어렵다.</li>
  <li>객체 구조가 변경되면 모든 <code class="language-plaintext highlighter-rouge">Visitor</code>를 수정해야 한다.<br />
<br />
<br /></li>
</ul>

<h2 id="154-성능-최적화">15.4 성능 최적화</h2>

<h3 id="1541-n1-문제">15.4.1 N+1 문제</h3>
<ul>
  <li>즉시 로딩은 JPQL을 실행할 때 N+1 문제가 발생할 수 있다.</li>
  <li>지연 로딩은 연관된 컬렉션을 사용할 때 N+1 문제가 발생할 수 있다.<br />
<br /></li>
</ul>

<p><strong>해결 방법</strong><br />
<strong>1. 페치 조인 사용</strong></p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">distinct</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">join</span> <span class="k">fetch</span> <span class="n">m</span><span class="p">.</span><span class="n">orders</span>
</code></pre></div></div>
<p>일대다 조인을 하면 결과가 늘어나서 중복된 결과가 나타날 수 있다. 따라서 <code class="language-plaintext highlighter-rouge">distinct</code>를 사용해서 중복을 제거하는 것이 좋다.<br />
<br /></p>

<p><strong>2. 하이버네이트 <code class="language-plaintext highlighter-rouge">@BatchSize</code></strong><br />
하이버네이트가 제공하는 <code class="language-plaintext highlighter-rouge">@BatchSize</code>어노테이션을 사용하면 연관된 엔티티를 조회할 때 지정한 <code class="language-plaintext highlighter-rouge">size</code>만큼 <code class="language-plaintext highlighter-rouge">SQL</code>의 <code class="language-plaintext highlighter-rouge">IN</code>절을 사용해서 조회한다. 만약 조회한 회원이 10명인데 <code class="language-plaintext highlighter-rouge">size=5</code>로 지정하면 2번의 <code class="language-plaintext highlighter-rouge">SQL</code>만 추가로 실행한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@BatchSize</span>
<span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"member"</span><span class="o">,</span> <span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;();</span>
</code></pre></div></div>

<div class="notice--info">
<p><strong>참고</strong>
hibernate.default_batch_fetch_size 속성을 사용하면 애플리케이션 전체에 기본으로 @BatchSize를 적용할 수 있다.</p>
</div>
<p><br /></p>

<p><strong>3. 하이버네이트 @Fetch(FetchMode.SUBSELECT)</strong><br />
하이버네이트가 제공하는 <code class="language-plaintext highlighter-rouge">@Fetch</code>어노테이션에 <code class="language-plaintext highlighter-rouge">FetchMode.SUBSELECT</code>로 사용하면 연관된 데이터를 조회할 때 서브 쿼리를 사용해서 N+1 문제를 해결한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Fetch</span><span class="o">(</span><span class="nc">FetchMode</span><span class="o">.</span><span class="na">SUBSELECT</span><span class="o">)</span>
<span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"member"</span><span class="o">,</span> <span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;();</span>
</code></pre></div></div>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- JPQL</span>
<span class="k">select</span> <span class="n">m</span> <span class="k">from</span> <span class="n">Member</span> <span class="n">m</span> <span class="k">where</span> <span class="n">m</span><span class="p">.</span><span class="n">id</span> <span class="o">&gt;</span> <span class="mi">10</span>

<span class="c1">-- 즉시 로딩으로 설정하면 조회 시점에</span>
<span class="c1">-- 지연 로딩으로 설정하면 지연로딩된 엔티티를 사용하는 시점에</span>
<span class="c1">-- SQL</span>
<span class="k">SELECT</span> <span class="n">O</span> <span class="k">FROM</span> <span class="n">ORDERS</span> <span class="n">O</span>
    <span class="k">WHERE</span> <span class="n">O</span><span class="p">.</span><span class="n">MEMBER_ID</span> <span class="k">IN</span> <span class="p">(</span>
        <span class="k">SELECT</span>
            <span class="n">M</span><span class="p">.</span><span class="n">ID</span>
        <span class="k">FROM</span>
            <span class="n">MEMBER</span> <span class="n">M</span>
        <span class="k">WHERE</span> <span class="n">M</span><span class="p">.</span><span class="n">ID</span> <span class="o">&gt;</span> <span class="mi">10</span>
    <span class="p">)</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>정리</strong></p>
<ul>
  <li>즉시 로딩은 성능 최적화가 어렵다.</li>
  <li>즉시 로딩은 사용하지 말고 지연 로딩만 사용하는 것을 추천한다.</li>
  <li>성능 최적화가 꼭 필요한 곳에서만 JPQL 페치 조인 사용하자.<br />
<br />
<br /></li>
</ul>

<h3 id="1542-읽기-전용-쿼리의-성능-최적화">15.4.2 읽기 전용 쿼리의 성능 최적화</h3>
<p>영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관하므로 더 많은 메모리를 사용하는 단점이 있다. 단순히 조회만 하고, 조회한 엔티티를 다시 조회할 일도 없고 수정할 일도 없다면 읽기 전용으로 엔티티를 조회하면 메모리 사용량을 최적화할 수 있다.</p>

<p><strong>스칼라 타입으로 조회</strong><br />
스칼라 타입은 영속성 컨텍스트가 결과를 관리하지 않는다.</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">o</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">price</span> <span class="k">from</span> <span class="k">Order</span> <span class="n">p</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>읽기 전용 쿼리 힌트 사용</strong><br />
하이버네이트 전용 힌트인 <code class="language-plaintext highlighter-rouge">org.hibernate.readOnly</code>를 사용하면 <strong>엔티티를 읽기 전용으로 조회할 수 있다</strong>. 영속성 컨텍스트는 스냅샷을 보관하지 않는다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TypedQuery</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select o from Order o"</span><span class="o">,</span> <span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="n">query</span><span class="o">.</span><span class="na">setHint</span><span class="o">(</span><span class="s">"org.hibernate.readOnly"</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>읽기 전용 트랜잭션 사용</strong><br />
스프링 프레임워크를 사용하면 트랜잭션을 읽기 전용 모드로 설정할 수 있다. 이 옵션은 <strong>트랜잭션을 커밋해도 영속성 컨텍스트를 플러시 하지 않는다</strong>. 스냅샷 비교와 같은 무거운 로직들을 수행하지 않으므로 성능이 향상된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span><span class="o">(</span><span class="n">readOnly</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>추천 방법</strong></p>
<ul>
  <li>읽기 전용 트랜잭션 사용: 플러시를 작동하지 않도록 해서 성능 향상</li>
  <li>읽기 전용 엔티티 사용: 엔티티를 읽기 전용으로 조회해서 메모리 절약<br />
<br />
<br /></li>
</ul>

<h3 id="1543-배치-처리">15.4.3 배치 처리</h3>
<ul>
  <li>영속성 컨텍스트에 너무 많은 엔티티가 저장되면 메모리 부족 오류가 발생할 수 있다.</li>
  <li>따라서 이러한 배치 처리를 적절한 단위로 영속성 컨텍스트를 초기화해야 한다.</li>
  <li>2차 캐시를 사용하고 있다면 2차 캐시에 엔티티를 보관하지 않도록 주의해야 한다.</li>
</ul>

<p><strong>JPA 등록 배치</strong><br />
많은 양의 엔티티를 한 번에 등록할 때 주의할 점은 영속성 컨텍스트에 <strong>엔티티가 계속 쌓이지 않도록</strong> 일정 단위마다 영속성 컨텍스트의 <strong>엔티티를 데이터베이스에 플러시</strong>하고 영속성 컨텍스트를 초기화해야 한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">entityManagerFactory</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
<span class="nc">EntityTransaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
<span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>

<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">100000</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">){</span>
    <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"item"</span><span class="o">+</span> <span class="n">i</span><span class="o">,</span> <span class="mi">10000</span><span class="o">);</span>
    <span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>

    <span class="c1">//100건마다 플러시와 영속성 컨텍스트 초기화</span>
    <span class="k">if</span><span class="o">(</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">)</span> <span class="o">{</span>
        <span class="n">em</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">em</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span><span class="err">​</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>JPA 수정 배치</strong><br />
배치 처리는 아주 많은 데이터를 조회해서 수정한다. 이때 수많은 데이터들을 한 번에 메모리에 올려둘 수 없어서 다음 방법을 주로 사용한다.</p>

<p><strong>1. JPA 페이징 배치 처리</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">entityManagerFactory</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
<span class="nc">EntityTransaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>

<span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
<span class="kt">int</span> <span class="n">pageSize</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 조회</span>
    <span class="nc">List</span> <span class="o">&lt;</span> <span class="nc">Product</span> <span class="o">&gt;</span> <span class="n">resultList</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select p from Product p"</span><span class="o">,</span> <span class="nc">Product</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
        <span class="o">.</span><span class="na">setFirstResult</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">pageSize</span><span class="o">)</span>
        <span class="o">.</span><span class="na">setMaxResults</span><span class="o">(</span><span class="n">pageSize</span><span class="o">)</span>
        <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>

    <span class="c1">//비즈니스 로직 실행 </span>
    <span class="k">for</span> <span class="o">(</span><span class="nc">Product</span> <span class="nl">product:</span> <span class="n">resultList</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">product</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="n">product</span><span class="o">.</span><span class="na">getPrice</span> <span class="o">+</span> <span class="mi">100</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 플러시, 초기화</span>
    <span class="n">em</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
    <span class="n">em</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
<span class="o">}</span>
<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="n">em</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>2. 하이버네이트 scroll 사용</strong><br />
<code class="language-plaintext highlighter-rouge">JPA</code>는 <code class="language-plaintext highlighter-rouge">JDBC 커서(CURSOR)</code>를 지원하지 않는다. 따라서 <code class="language-plaintext highlighter-rouge">커서</code>를 사용하려면 <code class="language-plaintext highlighter-rouge">하이버네이트 세션(SESSION)</code>을 사용해야 한다. 하이버네이트는 <code class="language-plaintext highlighter-rouge">scroll</code>이라는 이름으로 <code class="language-plaintext highlighter-rouge">JDBC 커서</code>를 지원한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityTransaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
<span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">unwrap</span><span class="o">(</span><span class="nc">Session</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

<span class="n">tx</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span>
<span class="nc">ScrollableResults</span> <span class="n">scroll</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select p from Product p"</span><span class="o">)</span>
    <span class="o">.</span><span class="na">setCacheMode</span><span class="o">(</span><span class="nc">CacheMode</span><span class="o">.</span><span class="na">IGNORE</span><span class="o">)</span> <span class="c1">// 2차 캐시 기능을 끈다.</span>
    <span class="o">.</span><span class="na">scroll</span><span class="o">(</span><span class="nc">ScrollMode</span><span class="o">.</span><span class="na">FORWARD_ONLY</span><span class="o">);</span>

<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">scroll</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">Product</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Product</span><span class="o">)</span> <span class="n">scroll</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">);</span>

    <span class="n">count</span><span class="o">++;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">session</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span> <span class="c1">//플러시</span>
        <span class="n">session</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span> <span class="c1">//영속성 컨텍스트 초기화</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="n">session</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>
<p><br /></p>

<p><strong>3. 하이버네이트 무상태 세션 사용</strong></p>
<ul>
  <li>하이버네이트는 무상태 세션이라는 특별한 기능을 제공한다.</li>
  <li>무상태 세션은 영속성 컨텍스트를 만들지 않고 심지어 2차 캐시도 사용하지 않는다.</li>
  <li>엔티티를 수정하려면 무상태 세션이 제공하는 <code class="language-plaintext highlighter-rouge">update()</code> 메소드를 직접 호출해야 한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">SessionFactory</span> <span class="n">sessionFactory</span> <span class="o">=</span> <span class="n">entityManagerFactory</span><span class="o">.</span><span class="na">unwrap</span><span class="o">(</span><span class="nc">SessionFactory</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="nc">StatelessSession</span> <span class="n">session</span> <span class="o">=</span> <span class="n">sessionFactory</span><span class="o">.</span><span class="na">openStatelessSession</span><span class="o">();</span>
<span class="nc">Transaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">beginTransaction</span><span class="o">();</span>
<span class="nc">ScrollableResults</span> <span class="n">scroll</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select p from Product p"</span><span class="o">).</span><span class="na">scroll</span><span class="o">();</span>

<span class="k">while</span> <span class="o">(</span><span class="n">scroll</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">Product</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Product</span><span class="o">)</span> <span class="n">scroll</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">setPrice</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">+</span> <span class="mi">100</span><span class="o">);</span>
    <span class="n">session</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">p</span><span class="o">);</span> <span class="c1">// 직접 update를 호출해야 한다.</span>
<span class="o">}</span>
<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span>
<span class="n">session</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1544-sql-쿼리-힌트-사용">15.4.4 SQL 쿼리 힌트 사용</h3>
<p>JPA는 데이터베이스 SQL 힌트 기능을 제공하지 않는다. SQL 힌트를 사용하려면 하이버네이트를 직접 사용해야 한다. 여기서 말하는 SQL 힌트는 JPA 구현체에게 제공하는 힌트가 아니다. 데이터베이스 벤더에게 제공하는 힌트다.</p>

<p><strong>SQL 쿼리 힌트 사용</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Session</span> <span class="n">session</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">unwrap</span><span class="o">(</span><span class="nc">Session</span><span class="o">.</span><span class="na">class</span><span class="o">);</span> <span class="c1">// 하이버네이트 직접 사용</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="na">creatQuery</span><span class="o">(</span><span class="s">"select m from Member m"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">addQueryHint</span><span class="o">(</span><span class="s">"FULL (MEMBER)"</span><span class="o">)</span> <span class="c1">// SQL 힌트 추가</span>
            <span class="o">.</span><span class="na">list</span><span class="o">();</span>
</code></pre></div></div>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 실행된 SQL을 보면 추가한 힌트가 있다.</span>
<span class="k">select</span>
    <span class="cm">/*+ FULL (MEMBER) */</span> <span class="n">m</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span>
<span class="k">from</span>
    <span class="n">Member</span> <span class="n">m</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h3 id="1545-트랜잭션을-지원하는-쓰기-지연-성능-최적화">15.4.5 트랜잭션을 지원하는 쓰기 지연 성능 최적화</h3>
<p>성능 최적화를 위해 SQL 배치를 이용한다. 하이버네이트에서 배치를 설정하면 데이터를 등록, 수정 삭제할 때 SQL 배치 기능을 사용한다</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"hibernate.jdbc.batch_size"</span> <span class="na">value=</span><span class="s">"50"</span><span class="nt">&gt;</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">hibernate.jdbc.batch_size</code> 속성의 속성 값을 50으로 주면 최대 50건씩 모아서 SQL 배치를 실행한다. 하지만 <strong>SQL 배치는 같은 SQL일 때만 유효하다.</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">ner</span> <span class="nf">Member</span><span class="o">());</span> <span class="c1">// 1</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">ner</span> <span class="nf">Member</span><span class="o">());</span> <span class="c1">// 2</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">ner</span> <span class="nf">Member</span><span class="o">());</span> <span class="c1">// 3</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">ner</span> <span class="nf">Member</span><span class="o">());</span> <span class="c1">// 4</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">ner</span> <span class="nf">Child</span><span class="o">());</span>  <span class="c1">// 5, 다른 연산</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">ner</span> <span class="nf">Member</span><span class="o">());</span> <span class="c1">// 6</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">ner</span> <span class="nf">Member</span><span class="o">());</span> <span class="c1">// 7</span>
</code></pre></div></div>
<p>이렇게 하면 1,2,3,4를 모아서 하나의 SQL 배치를 실행하고 5를 한 번 실행하고 6,7을 모아서 실행한다. 총 3번의 SQL 배치를 실행한다.</p>

<p><br />
<br /></p>

<h2 id="155-정리">15.5 정리</h2>
<ul>
  <li>JPA의 예외는 트랜잭션 롤백을 표시하는 예외와 표시하지 않는 예외로 나눈다. 트랜잭션을 롤백하는 예외는 심각한 예외이므로 트랜잭션을 강제로 커밋해도 커밋되지 않고 롤백된다.</li>
  <li>영속성 컨텍스트의 엔티티는 비즈니스 키를 사용한 동등성 비교를 해야 한다.</li>
  <li>프록시를 사용하는 클라이언트는 조회한 엔티티가 프록시인지 원본 엔티티인지 구분하지 않고 사용할 수 있어야 한다. 하지만 프록시는 기술적인 한계가 있으므로 한계점을 인식하고 사용해야 한다.</li>
  <li>JPA를 사용할 때 N+1 문제를 가장 조심해야 한다. 주로 페치 조인으로 해결한다.</li>
  <li>엔티티를 읽기 전용으로 조회하면 스냅샷을 유지할 필요가 없고 영속성 컨텍스트를 플러시하지 않아도 된다.</li>
  <li>대량의 엔티티를 배치 처리하려면 적절한 시점에 꼭 플러시를 호출하고 영속성 컨텍스트도 초기화해야 한다.</li>
  <li>JPA는 SQL 쿼리 힌트를 지원하지 않지만 하이버네이트 구현체를 사용하면 SQL 쿼리 힌트를 사용할 수 있다.</li>
</ul>

<p><br />
<br />
<br /></p>

<h1 id="16-트랜잭션과-락-2차-캐시">16. 트랜잭션과 락, 2차 캐시</h1>
<h2 id="161-트랜잭션과-락">16.1 트랜잭션과 락</h2>
<p>트랜잭션 기초와 JPA가 제공하는 낙관적 락과 비관적 락에 대해 알아본다.<br />
<br /></p>

<h3 id="1611-트랜잭션과-격리-수준">16.1.1 트랜잭션과 격리 수준</h3>
<p>트랜잭션은 <code class="language-plaintext highlighter-rouge">ACID</code>라 하는 원자성(<code class="language-plaintext highlighter-rouge">Atomicty</code>), 일관성(<code class="language-plaintext highlighter-rouge">Consistency</code>), 격리성(<code class="language-plaintext highlighter-rouge">Isolation</code>), 지속성(<code class="language-plaintext highlighter-rouge">Durability</code>)을 보장해야 한다.</p>
<ul>
  <li><strong>원자성</strong>: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공 하든가 모두 실패해야 한다.</li>
  <li><strong>일관성</strong>: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.</li>
  <li><strong>격리성</strong>: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.</li>
  <li><strong>지속성</strong>: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.<br />
<br /></li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">ANSI</code> 표준 트랜잭션의 격리 수준 4단계</strong></p>
<ul>
  <li><strong>READ UNCOMMITED</strong>
    <ul>
      <li>트랜잭션에서 변경하는 내용이 commit과 rollback여부에 관계 없이 다른 트랜잭션에게 노출된다.</li>
    </ul>
  </li>
  <li><strong>READ COMMITTED</strong>
    <ul>
      <li>트랜잭션에서 변경한 레코드는 commit이 완료된 데이터만 조회할 수 있다.</li>
      <li>commit 전에 조회를 시도한다면 UNDO영역에 백업된 레코드를 조회할 수 있다.</li>
    </ul>
  </li>
  <li><strong>REPEATABLE READ</strong>
    <ul>
      <li>InnoDB 엔진에서 사용하는 기본 격리 수준.</li>
      <li>REPEATABLE READ란 하나의 트랜잭션 내부에서 같은 SELECT 문은 항상 같은 결과를 보여주는 것.</li>
      <li>MySQL InnoDB에서는 트랜잭션별로 식별자를 주고 트랜잭션에서 변경하는 데이터를 UNDO영역에 백업한다.</li>
      <li>이 백업된 데이터와 트랜잭션 식별자로 동일 트랜잭션에서 동일 결과값을 보여줄 수 있도록 보장한다.</li>
    </ul>
  </li>
  <li><strong>SERIALIZABLE</strong>
    <ul>
      <li>가장 높은 격리 수준.</li>
      <li>레코드를 조회할 때 Shared Lock을 획득해야만 조회할 수 있다.</li>
      <li>데이터를 변경할 때에는 Exclusive Lock을 획득해야만 변경할 수 있다.</li>
      <li>즉 한 트랜잭션에서 사용하는 데이터는 다른 트랜잭션에서 접근할 수 없게 만든다.</li>
      <li>데이터 정합성을 지키는 면은 가장 우수하지만 동시 처리 성능이 떨어진다.<br />
<br /></li>
    </ul>
  </li>
</ul>

<p><strong>격리 수준에 따른 문제점</strong></p>
<ul>
  <li><strong>DIRTY READ</strong>
    <ul>
      <li>트랜잭션에서 작업이 다 끝나지 않았지만 다른 트랜잭션에서 작업 내용을 볼 수 있는 것을 DIRTY READ라고 한다.</li>
      <li>변경된 데이터가 롤백될지, 커밋될지 모르는 상황에서 작업 내용을 조회할 수 있기 때문에 데이터 정합성에 큰 문제를 유발할 수 있다.</li>
    </ul>
  </li>
  <li><strong>NON REPEATABLE READ</strong>
    <ul>
      <li>하나의 트랜잭션에서 같은 SELECT문으로 조회할 때 마다 다른결과를 받을 수 있다면 이를 NON REPEATABLE READ상태라고 부른다.</li>
    </ul>
  </li>
  <li><strong>PHANTOM READ</strong>
    <ul>
      <li>하나의 트랜잭션에서 같은 SELECT문으로 조회할 때 이전 SELECT에서는 존재하지 않던 값이 다음 SELECT에 조회되는 것을 의미한다.<br />
<br /></li>
    </ul>
  </li>
</ul>

<p><strong>트랜잭션 격리 수준과 문제점 정리</strong></p>

<table>
  <thead>
    <tr>
      <th><strong>격리 수준</strong></th>
      <th><strong>DIRTY READ</strong></th>
      <th><strong>NON-REPEATABLE READ</strong></th>
      <th><strong>PHANTOM READ</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>READ UNCOMMITED</td>
      <td>O</td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>READ COMMITTED</td>
      <td> </td>
      <td>O</td>
      <td>O</td>
    </tr>
    <tr>
      <td>REPEATABLE READ</td>
      <td> </td>
      <td> </td>
      <td>O</td>
    </tr>
    <tr>
      <td>SERIALIZABLE</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h3 id="1612-낙관적-락과-비관적-락-기초">16.1.2 낙관적 락과 비관적 락 기초</h3>
<p><code class="language-plaintext highlighter-rouge">JPA</code>는 데이터베이스 트랜잭션 격리 수준을 <code class="language-plaintext highlighter-rouge">READ COMMITED</code> 정도로 가정한다. 만약 일부 로직에 더 높은 격리 수준이 필요하면 낙관적 락과 비관적 락 중 하나를 사용하면 된다.</p>

<p><strong>낙관적 락</strong><br />
데이터베이스가 제공하는 락 기능을 사용하는 것이 아니라 JPA가 제공하는 버전 관리 기능을 사용한다. 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다는 특징이 있다.</p>

<p><strong>비관적 락</strong><br />
트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법이다. 데이터베이스가 제공하는 락 기능을 사용한다. 대표적으로 select for update 구문이 있다.</p>

<p><strong>두 번의 갱신 분실 문제</strong><br />
사용자 A가 수정하고 사용자 B가 1초 뒤에 수정 요청을 하게 되면 사용자 B의 수정사항만 남게 된다. 이것을 두 번의 갱신 분실 문제라 한다. 이를 해결하기 위한 3가지 선택 방법이 있다.</p>

<ul>
  <li>마지막 커밋만 인정하기: 사용자 A의 내용은 무시하고 마지막에 커밋한 사용자 B의 내용만 인정한다.</li>
  <li>최초 커밋만 인정하기: 사용자 A가 이미 수정을 완료했으므로 사용자 B가 수정을 완료할 때 오류가 발생한다.</li>
  <li>충돌하는 갱신 내용 병합하기: 사용자 A와 사용자 B의 수정사항을 병합한다.</li>
</ul>

<p><br />
<br /></p>

<h3 id="1613-version">16.1.3 @Version</h3>
<p>JPA가 제공하는 낙관적 락을 사용하려면 <code class="language-plaintext highlighter-rouge">@Version</code> 어노테이션을 사용해서 버전 관리 기능을 추가해야 한다.</p>

<div class="notice--info">
<p><strong>@Version 적용 가능 타입</strong></p>
<ul>
  <li>Long (long)</li>
  <li>Integer (int)</li>
  <li>Shoort (short)</li>
  <li>Timestamp</li>
</ul>
</div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Board</span> <span class="o">{</span>

	<span class="nd">@Id</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>

	<span class="nd">@Version</span>
	<span class="kd">private</span> <span class="nc">Integer</span> <span class="n">version</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<p>이제부터 엔티티를 수정할 때 마다 버전이 하나씩 자동으로 증가한다. 그리고 엔티티를 수정할 때 조회 시점의 버전과 수정 시점의 버전이 다르면 예외가 발생한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 트랜잭션 1 조회 title="제목A", version=1</span>
<span class="nc">Board</span> <span class="n">board</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Board</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>

<span class="c1">// 트랜잭션 2에서 해당 게시물을 수정해서 title="제목C", version=2로 증가</span>
<span class="n">board</span><span class="o">.</span><span class="na">setTitle</span><span class="o">(</span><span class="s">"제목B"</span><span class="o">);</span> <span class="c1">// 트랜잭션 1 데이터 수정</span>

<span class="n">save</span><span class="o">(</span><span class="n">board</span><span class="o">);</span>
<span class="n">tx</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span> <span class="c1">//예외 발생, 데이터베이스 version=2, 엔티티 version=1</span>
</code></pre></div></div>

<center><img src="/assets/images/posts/books/2/16_1_version.png" width="100%" height="100%" /></center>

<p>트랜잭션 1이 데이터를 제목 B로 변경하고 트랜잭션을 커밋하는 순간 엔티티를 조회할 때 버전과 데이터베이스의 현재 버전 정보가 다르므로 예외가 발생한다. <strong>따라서 버전 정보를 사용하면 최초 커밋만 인정하기가 적용</strong>된다.</p>

<p><code class="language-plaintext highlighter-rouge">@Version</code>으로 추가한 <strong>버전 관리 필드는 JPA가 직접 관리하므로 개발자가 임의로 수정하면 안 된다(벌크 연산 제외)</strong> 만약 버전 값을 강제로 증가 하려면 특별한 락 옵션을 선택하면 된다.</p>

<div class="notice--info">
<p><strong>참고</strong><br />
벌크 연산은 버전을 무시한다. 벌크 연산에서 버전을 증가하려면 버전 필드를 강제로 증가시켜야 한다.<br />
<code class="language-plaintext highlighter-rouge">update Member m set m.name = '변경', m.version = m.version + 1</code></p>
</div>
<p><br />
<br /></p>

<h3 id="1614-jpa-락-사용">16.1.4 JPA 락 사용</h3>

<div class="notice--info">
<p><strong>참고</strong><br />
JPA를 사용할 때 추천하는 전략은 <code class="language-plaintext highlighter-rouge">READ COMMITTED</code> 트랜잭션 격리 수준 + 낙관적 버전 관리다. (두 번의 갱신 내역 분실 문제 예방)</p>
</div>

<p>락은 다음 위치에 적용할 수 있다.</p>
<ul>
  <li>EntityManager.lock(), EntityManager.find(), EntityManager.refresh()</li>
  <li>Query.setLockMode() (TypeQuery 포함)</li>
  <li>@NamedQuery</li>
</ul>

<p>JPA가 제공하는 락 옵션은 <code class="language-plaintext highlighter-rouge">javax.persistence.LockModeType</code>에 정의되어 있다.</p>

<table>
  <thead>
    <tr>
      <th><strong>락 모드</strong></th>
      <th><strong>타입</strong></th>
      <th><strong>설명</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>낙관적 락</td>
      <td>OPTIMISTIC</td>
      <td>낙관적 락을 사용한다.</td>
    </tr>
    <tr>
      <td>낙관적 락</td>
      <td>OPTIMISTIC_FORCE_INCREMENT</td>
      <td>낙관적 락 + 버전정보를 강제로 증가한다.</td>
    </tr>
    <tr>
      <td>비관적 락</td>
      <td>PESSIMISTIC_READ</td>
      <td>비관적 락, 읽기 락을 사용한다.</td>
    </tr>
    <tr>
      <td>비관적 락</td>
      <td>PESSIMISTIC_WRITE</td>
      <td>비관적 락, 쓰기 락을 사용한다.</td>
    </tr>
    <tr>
      <td>비관적 락</td>
      <td>PESSIMISTIC_FORCE_INCREMENT</td>
      <td>비관적 락, 버전정보를 강제로 증가한다.</td>
    </tr>
    <tr>
      <td>기타</td>
      <td>NONE</td>
      <td>락을 걸지 않는다.</td>
    </tr>
    <tr>
      <td>기타</td>
      <td>READ</td>
      <td>JPA1.0 호환 기능이다. OPTIMISTIC과 같으므로 OPTIMISTIC을 사용하면 된다.</td>
    </tr>
    <tr>
      <td>기타</td>
      <td>WRITE</td>
      <td>JPA1.0 호환 기능이다. OPTIMISTIC_FORCE_INCREMENT와 같다</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h3 id="1615-jpa-낙관적-락">16.1.5 JPA 낙관적 락</h3>
<p>JPA가 제공하는 낙관적 락은 버전을 사용한다. 따라서 낙관적 락을 사용하려면 버전이 있어야 한다. 낙관적 락은 트랜잭션을 커밋하는 시점에 충돌을 알 수 있다는 특징이 있다. 낙관적 락의 옵션에 따른 효과를 알아보자.</p>

<p><strong>NONE</strong><br />
락 옵션을 적용하지 않아도 엔티티에 <code class="language-plaintext highlighter-rouge">@Version</code>이 적용된 필드만 있으면 낙관적 락이 적용된다.</p>
<ul>
  <li>용도: 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경(삭제)되지 않아야 한다. 조회 시점부터 수정 시점까지를 보장한다.</li>
  <li>동작: 엔티티를 수정할 때 버전을 체크하면서 버전을 증가한다.(UPDATE 쿼리 사용). 이때 데이터베이스의 버전 값이 현재 버전이 아니면 예외가 발생한다.</li>
  <li>이점: 두 번의 갱신 분실 문제를 예방한다.<br />
<br /></li>
</ul>

<p><strong>OPTIMISTIC</strong><br />
<code class="language-plaintext highlighter-rouge">@Version</code>만 적용했을 때는 엔티티를 수정해야 버전을 체크하지만 이 옵션을 추가하면 <strong>엔티티를 조회만 해도 버전을 체크</strong>한다. <strong>한 번 조회한 엔티티는 트랜잭션을 종료할 때까지 다른 트랜잭션에서 변경되지 않음을 보장</strong>한다.</p>
<ul>
  <li>용도: 조회 시점부터 트랜잭션이 끝날 때까지 조회한 엔티티가 변경되지 않음을 보장한다.</li>
  <li>동작: 트랜잭션을 커밋할 때 버전 정보를 조회해서 현재 엔티티의 버전과 같은지 검증한다. 만약 같지 않으면 예외가 발생한다.</li>
  <li>이점: <code class="language-plaintext highlighter-rouge">OPTIMISTIC</code> 옵션은 <code class="language-plaintext highlighter-rouge">DIRTY READ</code>와 <code class="language-plaintext highlighter-rouge">NON-REPEATABLE READ</code>를 방지한다.<br />
<br /></li>
</ul>

<p><strong>OPTIMISTIC_FORCE_INCREMENT</strong><br />
트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해서 버전 정보를 강제로 증가시킨다.</p>
<ul>
  <li>용도: 논리적인 단위의 엔티티 묶음을 관리할 수 있다. 게시물과 첨부파일이 일대다, 다대일의 양방향 연관관계이고 첨부파일이 연관관계의 주인이다. 게시물을 수정하는 데 단순히 첨부파일만 추가하면 게시물의 버전은 증가하지 않는다. 이때 게시물의 버전도 강제로 증가하려면 <code class="language-plaintext highlighter-rouge">OPTIMISTIC_FORCE_INCREMENT</code>를 사용하면 된다.</li>
  <li>동작: <strong>트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해서 버전 정보를 강제로 증가시킨다.</strong> 추가로 엔티티를 수정하면 수정 시 버전 UPDATE가 발생한다. 따라서 총 2번의 버전 증가가 나타날 수 있다.</li>
  <li>이점: 강제로 버전을 증가해서 논리적인 단위의 엔티티 묶음을 버전 관리할 수 있다.<br />
<br />
<br />
<br /></li>
</ul>

<h3 id="1616-jpa-비관적-락">16.1.6 JPA 비관적 락</h3>
<p>JPA가 제공하는 <strong>비관적 락은 데이터베이스 트랜잭션 락 메커니즘에 의존하는 방법</strong>이다. 주로 SQL 쿼리에 <code class="language-plaintext highlighter-rouge">select for update</code> 구문을 사용하면서 시작하고 버전 정보는 사용하지 않는다.</p>

<p><strong>비관적 락의 특징</strong></p>
<ul>
  <li>엔티티가 아닌 스칼라 타입을 조회할 때도 사용할 수 있다.</li>
  <li>데이터를 수정하는 즉시 트랜잭션 충돌을 감지할 수 있다.<br />
<br /></li>
</ul>

<p><strong>PESSIMISTIC_WRITE</strong></p>
<ul>
  <li>용도: 데이터베이스에 쓰기 락을 건다</li>
  <li>동작: 데이터베이스 <code class="language-plaintext highlighter-rouge">select for update</code>를 사용해서 락을 건다.</li>
  <li>이점: <code class="language-plaintext highlighter-rouge">NON-REPEATABLE READ</code>를 방지한다. 락이 걸린 로우는 다른 트랜잭션이 수정할 수 없다.<br />
<br /></li>
</ul>

<p><strong>PESSIMISTIC_READ</strong><br />
데이터를 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용한다. 데이터베이스 대부분은 <code class="language-plaintext highlighter-rouge">PESSIMISTIC_WRITE</code>로 동작한다.</p>
<ul>
  <li>MySQL: lock in share mode</li>
  <li>PostgreSQL: for share<br />
<br /></li>
</ul>

<p><strong>PESSIMISTIC_FORCE_INCREMENT</strong><br />
비관적 락중 유일하게 버전 정보를 사용한다. 하이버네이트는 <code class="language-plaintext highlighter-rouge">nowait</code>를 지원하는 데이터베이스에 대해서 <code class="language-plaintext highlighter-rouge">for update nowait</code> 옵션을 적용한다.</p>
<ul>
  <li>오라클: for update nowait</li>
  <li>PostreSQL: for update nowait</li>
  <li>nowait를 지원하지 않으면 for update가 사용된다.<br />
<br />
<br /></li>
</ul>

<h3 id="1617-비관적-락과-타임아웃">16.1.7 비관적 락과 타임아웃</h3>
<p>비관적 락을 사용하면 락을 획득할 때까지 트랜잭션이 대기한다. 무한정 기다릴 수는 없으므로 타임아웃 시간을 줄 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">properties</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;();</span>

<span class="c1">// 타임아웃 10초까지 대기 설정</span>
<span class="n">properties</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"java.persistence.lock.timeout"</span><span class="o">,</span> <span class="mi">10000</span><span class="o">);</span>

<span class="nc">Board</span> <span class="n">board</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Board</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"boardId"</span><span class="o">,</span> <span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">,</span> <span class="n">properties</span><span class="o">);</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h2 id="162-2차-캐시">16.2 2차 캐시</h2>
<p>JPA가 제공하는 애플리케이션 범위의 캐시에 대해 알아보고 하이버네이트와 EHCACHE를 사용해서 실제 캐시를 적용해보자.</p>

<h3 id="1621-1차-캐시와-2차-캐시">16.2.1 1차 캐시와 2차 캐시</h3>
<p>영속성 컨텍스트로 얻을 수 있는 이점이 많지만, 일반적인 웹 애플리케이션 환경은 트랜잭션을 시작하고 종료할 때까지만 1차 캐시가 유효하다. OSIV를 사용해도 클라이언트의 요청이 들어올 때부터 끝날 때까지만 1차 캐시가 유효하다. 따라서 애플리케이션 전체로 보면 데이터베이스 접근 횟수를 획기적으로 줄이지는 못한다. 하이버네이트를 포함한 대부분의 JPA 구현체들은 <strong>애플리케이션 범위의 캐시를 지원하는데 이것을 공유 캐시 또는 2차 캐시라 한다.</strong></p>

<center><img src="/assets/images/posts/books/2/16_2_2차캐시적용.png" width="90%" height="90%" /></center>
<p><br /></p>

<p><strong>1차 캐시</strong><br />
1차 캐시는 영속성 컨텍스트 내부에 있다. 엔티티 매니저로 조회하거나 변경하는 모든 엔티티는 1차 캐시에 저장된다. 트랜잭션을 커밋하거나 플러시를 호출하면 1차 캐시에 있는 엔티티의 변경 내역을 데이터베이스에 동기화 한다.</p>
<center><img src="/assets/images/posts/books/2/16_2_1차캐시동작방식.png" width="90%" height="90%" /></center>
<p><br /></p>

<p><strong>2차 캐시</strong><br />
2차 캐시는 애플리케이션 범위의 캐시다. 따라서 애플리케이션을 종료할 때까지 캐시가 유지된다. 분산 캐시나 클러스터링 환경의 캐시는 애플리케이션보다 더 오래 유지될 수도 있다. 2차 캐시를 적절히 활용하면 데이터베이스 조회 횟수를 획기적으로 줄일 수 있다.</p>
<center><img src="/assets/images/posts/books/2/16_2_2차캐시동작방식.png" width="90%" height="90%" /></center>
<p><br /></p>

<p><strong>2차 캐시의 특징</strong></p>
<ul>
  <li>2차 캐시는 영속성 유닛 범위의 캐시다</li>
  <li>2차 캐시는 조회한 객체를 그대로 반환하는 것이 아니라 복사본을 만들어서 반환한다.</li>
  <li>2차 캐시는 데이터베이스 기본 키를 기준으로 캐시하지만 영속성 컨텍스트가 다르면 객체 <code class="language-plaintext highlighter-rouge">동일성(a==b)</code>을 보장하지 않는다.<br />
<br />
<br /></li>
</ul>

<h3 id="1622-jpa-2차-캐시-기능">16.2.2 JPA 2차 캐시 기능</h3>

<p><strong>캐시 모드 설정</strong><br />
2차 캐시를 사용하려면 <code class="language-plaintext highlighter-rouge">javax.persistence.Cacheable</code> 어노테이션을 사용하면 된다. <code class="language-plaintext highlighter-rouge">@Cacheable</code>은 <code class="language-plaintext highlighter-rouge">@Cacheable(true)</code>, <code class="language-plaintext highlighter-rouge">@Cacheable(false)</code>를 설정할 수 있는데 기본값은 <code class="language-plaintext highlighter-rouge">true</code>다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Cacheable</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

	<span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
	<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
	<span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">shared-cache-mode</code>를 설정해서 애플리케이션 전체(정확히는 영속성 유닛 단위)에 캐시를 어떻게 적용할지 옵션을 설정해야 한다.</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- 스프링 프레임워크 캐시 모드 설정 --&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"entityManagerFactory"</span> <span class="na">class=</span><span class="s">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"sharedCacheMode"</span> <span class="na">value=</span><span class="s">"ENABLE_SELECTIVE"</span><span class="nt">&gt;</span>
    ...
</code></pre></div></div>
<p>캐시 모드는 <code class="language-plaintext highlighter-rouge">javax.persistence.SharedCacheMode</code>에 정의되어 있다.</p>

<table>
  <thead>
    <tr>
      <th><strong>캐시 모드</strong></th>
      <th><strong>설명</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ALL</td>
      <td>모든 엔티티를 캐시한다.</td>
    </tr>
    <tr>
      <td>NONE</td>
      <td>캐시를 사용하지 않는다.</td>
    </tr>
    <tr>
      <td>ENABLE_SELECTIVE</td>
      <td>Cacheable(true)로 설정된 엔티티만 캐시를 적용한다.</td>
    </tr>
    <tr>
      <td>DISABLE_SELECTIVE</td>
      <td>모든 엔티티를 캐시하는데 Cacheable(false)로 명시된 엔티티는 캐시하지 않는다.</td>
    </tr>
    <tr>
      <td>UNSPECIFIED</td>
      <td>JPA 구현체가 정의한 설정을 따른다.</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<h3 id="1623-하이버네이트와-ehcache-적용">16.2.3 하이버네이트와 EHCACHE 적용</h3>
<p>하이버네이트가 지원하는 캐시는 크게 3가지가 있다.</p>
<ul>
  <li>엔티티 캐시: 엔티티 단위로 캐시한다. 식별자로 엔티티를 조회하거나 컬렉션이 아닌 연관된 엔티티를 로딩할 때 사용한다.</li>
  <li>컬렉션 캐시: 엔티티와 연관된 컬렉션을 캐시한다. 컬렉션이 엔티티를 담고 있으면 식별자 값만 캐시한다(하이버네이트 기능)</li>
  <li>쿼리 캐시: 쿼리와 파라미터 정보를 키로 사용해서 캐시한다. 결과가 엔티티면 식별자 값만 캐시한다.(하이버네이트 기능)<br />
<br /></li>
</ul>

<p><strong>환경설정</strong><br />
라이브러리 추가</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>org.hibernate<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>hibernate-ehcache<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>4.3.10.Final<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</code></pre></div></div>
<p><br /></p>

<p>캐시 정책 설정</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- src/main/resources/ehcache.xml --&gt;</span>
<span class="nt">&lt;ehcache&gt;</span>
    <span class="nt">&lt;defaultCache</span>
        <span class="na">maxElementsInMemory=</span><span class="s">"10000"</span>
        <span class="na">eternal=</span><span class="s">"false"</span>
        <span class="na">timeToIdleSeconds=</span><span class="s">"1200"</span>
        <span class="na">timeToLiveSeconds=</span><span class="s">"1200"</span>
        <span class="na">diskExpiryThreadIntervalSeconds=</span><span class="s">"1200"</span>
        <span class="na">memoryStoreEvictionPolicy=</span><span class="s">"LRU"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/ehcache&gt;</span>
</code></pre></div></div>
<p><br /></p>

<p>하이버네이트 캐시 사용 정보를 정의</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># application.yml</span>
<span class="na">spring</span><span class="pi">:</span>
  <span class="na">jpa</span><span class="pi">:</span>
    <span class="na">properties</span><span class="pi">:</span>
      <span class="na">hibernate</span><span class="pi">:</span>
        <span class="na">generate_statistics</span><span class="pi">:</span> <span class="no">true</span>
        <span class="na">format_sql</span><span class="pi">:</span> <span class="no">true</span>

        <span class="na">cache</span><span class="pi">:</span>
          <span class="na">use_second_level_cache</span><span class="pi">:</span> <span class="no">true</span>
          <span class="na">region</span><span class="pi">:</span>
            <span class="na">factory_class</span><span class="pi">:</span> <span class="s">org.hibernate.cache.ehcache.EhCacheRegionFactory // EHCACHE</span>

      <span class="na">javax</span><span class="pi">:</span>
        <span class="na">persistence</span><span class="pi">:</span>
          <span class="na">sharedCache</span><span class="pi">:</span>
            <span class="na">mode</span><span class="pi">:</span> <span class="s">ENABLE_SELECTIVE</span>
</code></pre></div></div>
<ul>
  <li>hibernate.cache.use_second_level_cache: 2차 캐시를 활성화 한다. 엔티티 캐시와 컬렉션 캐시를 사용할 수 있다.</li>
  <li>hibernate.cache.use_query_cach: 쿼리 캐시를 활성화 한다.</li>
  <li>hibernate.cache.region.factory_class: 2차 캐시를 처리할 클래스를 지정한다.</li>
  <li>hibernate.generate_statistics: 이 속성을 true로 설정하면 하이버네이트가 여러 통계정보를 출력해주는데 캐시 적용 여부를 확인할 수 있다.(성능에 영향을 주므로 개발 환경에서만 적용하는 것이 좋다)<br />
<br />
<br /></li>
</ul>

<p><strong>@Cache</strong><br />
하이버네이트 전용인 <code class="language-plaintext highlighter-rouge">@Cache</code> 어노테이션을 사용하면 세밀한 캐시 설정이 가능하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Cacheable</span> <span class="c1">// 엔티티 캐시</span>
<span class="nd">@Cache</span><span class="o">(</span><span class="n">usage</span> <span class="o">=</span> <span class="nc">CacheConcurrencyStrategy</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">)</span> <span class="c1">// 하이버네이트 전용, 캐시와 관련된 더 세밀할 설정 가능</span>
<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ParentMember</span> <span class="o">{</span>

	<span class="nd">@Id</span> <span class="nd">@GeneratedValue</span>
	<span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

	<span class="nd">@Cache</span><span class="o">(</span><span class="n">usage</span> <span class="o">=</span> <span class="nc">CacheConcurrencyStrategy</span><span class="o">.</span><span class="na">READ_WRITE</span><span class="o">)</span> <span class="c1">// 컬렉션도 캐시 적용 가능</span>
	<span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"parentMember"</span><span class="o">,</span> <span class="n">cascade</span> <span class="o">=</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">ALL</span><span class="o">)</span>
	<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">ChildMember</span><span class="o">&gt;</span> <span class="n">childMembers</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>하이버네이트 <code class="language-plaintext highlighter-rouge">@Cache</code> 속성</p>

<table>
  <thead>
    <tr>
      <th><strong>속성</strong></th>
      <th><strong>설명</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>usage</td>
      <td>CacheConcurrencyStrategy를 사용해서 캐시 동시성 전략을 설정한다.</td>
    </tr>
    <tr>
      <td>region</td>
      <td>캐시 지역 설정</td>
    </tr>
    <tr>
      <td>include</td>
      <td>연관 객체를 캐시에 포함할지 선택한다. all, non-laze 옵션을 선택할 수 있다.(기본값 all)</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">CacheConcurrencyStrategy</code> 속성</p>

<table>
  <thead>
    <tr>
      <th><strong>속성</strong></th>
      <th><strong>설명</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>NONE</td>
      <td>캐시를 설정하지 않는다.</td>
    </tr>
    <tr>
      <td>READ_ONLY</td>
      <td>읽기 전용으로 설정한다. 등록, 삭제는 가능하지만 수정은 불가능하다. 참고로 읽기 전용인 불변 객체는 수정되지 않으므로 하이버네이트는 2차 캐시를 조회할 때 객체를 복사하지 않고 원본 객체를 반환한다.</td>
    </tr>
    <tr>
      <td>NONSTRICT_READ_WRITE</td>
      <td>엄격하지 않은 읽고 쓰기 전략이다. 동시에 같은 엔티티를 수정하면 데이터 일관성이 깨질 수 있다. EHCACHE는 데이터를 수정하면 캐시 데이터를 무효화한다.</td>
    </tr>
    <tr>
      <td>READ_WRITE</td>
      <td>읽기 쓰기가 가능하고 READ COMMITTED 정도의 격리 수준을 보장한다.</td>
    </tr>
    <tr>
      <td>TRANSACTIONAL</td>
      <td>컨테이너 관리 환경에서 사용할 수 있다. 설정에 따라 REPEATABLE READ 정도의 격리 수준을 보장받을 수 있다.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>캐시 동시성 전략 지원 여부</p>

<table>
  <thead>
    <tr>
      <th><strong>Cache</strong></th>
      <th><strong>read-only</strong></th>
      <th><strong>nonstrict-read-write</strong></th>
      <th><strong>nonstrict-read-write</strong></th>
      <th><strong>transactional</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ConcurrentHashMap</td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
      <td> </td>
    </tr>
    <tr>
      <td>EHCache</td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>Infinispan</td>
      <td>yes</td>
      <td> </td>
      <td> </td>
      <td>yes</td>
    </tr>
  </tbody>
</table>

<p><br />
<br /></p>

<p><strong>캐시 영역</strong><br />
위에서 캐시를 적용한 코드(엔티티 코드)는 다음 캐시 영역에 저장된다.</p>
<ul>
  <li>엔티티 캐시 영역
    <ul>
      <li><code class="language-plaintext highlighter-rouge">jpabook.jpashop.domain.test.cache.ParentMember</code></li>
      <li>기본값으로 [패키지 명 + 클래스 명]을 사용</li>
    </ul>
  </li>
  <li>컬렉션 캐시 영역
    <ul>
      <li><code class="language-plaintext highlighter-rouge">jpabook.jpashop.domain.test.cache.ParentMember.childMembers</code></li>
      <li>엔티티 캐시 영역 이름 + 캐시한 컬렉션의 필드 명</li>
    </ul>
  </li>
</ul>

<p>필요하다면 <code class="language-plaintext highlighter-rouge">@Cache(region = "customRegion", ...)</code> 처럼 <code class="language-plaintext highlighter-rouge">region</code> 속성을 사용해서 캐시 영역을 직접 지정할 수 있다.<br />
<br /></p>

<p>캐시 영역이 정해져 있으면 영역별로 세부 설정을 할 수 있다.</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;ehcache&gt;</span>
    <span class="nt">&lt;defaultCache</span>
        <span class="na">maxElementsInMemory=</span><span class="s">"10000"</span>
        <span class="na">eternal=</span><span class="s">"false"</span>
        <span class="na">timeToIdleSeconds=</span><span class="s">"1200"</span>
        <span class="na">timeToLiveSeconds=</span><span class="s">"1200"</span>
        <span class="na">diskExpiryThreadIntervalSeconds=</span><span class="s">"1200"</span>
        <span class="na">memoryStoreEvictionPolicy=</span><span class="s">"LRU"</span> <span class="nt">/&gt;</span>
    
    <span class="c">&lt;!-- ParentMember를 600초 마다 캐시에서 제거 --&gt;</span>
    <span class="nt">&lt;cache</span>
        <span class="na">name=</span><span class="s">"jpabook.jpashop.domain.test.cache.ParentMember"</span>
        <span class="na">maxElementsInMemory=</span><span class="s">"10000"</span>
        <span class="na">eternal=</span><span class="s">"false"</span>
        <span class="na">timeToIdleSeconds=</span><span class="s">"600"</span>
        <span class="na">timeToLiveSeconds=</span><span class="s">"600"</span>
        <span class="na">overflowToDisk=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/ehcache&gt;</span>
</code></pre></div></div>
<p><br />
<br /></p>

<p><strong>쿼리 캐시</strong></p>
<ul>
  <li>쿼리 캐시는 쿼리와 파라미터 정보를 키로 사용해서 쿼리 결과를 캐시하는 방법이다.</li>
  <li>쿼리 캐시를 적용하려면 영속성 유닛 설정에 <code class="language-plaintext highlighter-rouge">hibernate.cache.use_query_cache</code> 옵션을 꼭 <code class="language-plaintext highlighter-rouge">true</code>로 설정해야 한다.</li>
  <li>그리고 쿼리 캐시를 적용하려는 쿼리마다 <code class="language-plaintext highlighter-rouge">org.hibernate.cacheable</code>을 <code class="language-plaintext highlighter-rouge">true</code>로 설정하는 힌트를 주면 된다</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 쿼리 캐시 사용</span>
<span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="s">"select i from Item i"</span><span class="o">,</span> <span class="nc">Item</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="o">.</span><span class="na">setHint</span><span class="o">(</span><span class="s">"org.hibernate.cacheable"</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
    <span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
 
<span class="c1">// @NamedQuery에 쿼리 캐시 적용</span>
<span class="nd">@Entity</span>
<span class="nd">@NamedQuery</span><span class="o">(</span>
    <span class="n">hints</span> <span class="o">=</span> <span class="nd">@QueryHint</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"org.hibernate.cacheable"</span><span class="o">,</span> <span class="n">value</span> <span class="o">=</span> <span class="s">"true"</span><span class="o">),</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"Member.findByUsername"</span><span class="o">,</span>
    <span class="n">query</span> <span class="o">=</span> <span class="s">"select m.address from Member m where m.name = :username"</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{...}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<p><strong>쿼리 캐시 영역</strong><br />
<code class="language-plaintext highlighter-rouge">hibernate.cache.use_query_cache</code> 옵션을 <code class="language-plaintext highlighter-rouge">true</code>로 설정해서 쿼리 캐시를 활성화 하면 다음 두 캐시 영역이 추가된다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">org.hibernate.cache.internal.StandardQueryCache</code>: 쿼리 캐시를 저장하는 영역이다. 이곳에는 쿼리, 쿼리 결과 집합, 쿼리를 실행한 시점의 타임스탬프를 보관한다.</li>
  <li><code class="language-plaintext highlighter-rouge">org.hibernate.cache.spi.UpdateTimestampsCache</code>: 쿼리 캐시가 유효한지 확인하기 위해 쿼리 대상 테이블의 가장 최근 변경(등록, 수정, 삭제) 시간을 저장하는 영역이다. 이곳에는 테이블 명과 해당 테이블의 최근 변경된 타임스탬프를 보관한다.</li>
</ul>

<p>쿼리 캐시는 캐시한 데이터 집합을 최신 데이터로 유지하려고 쿼리 캐시를 실행하는 시간과 쿼리 캐시가 사용하는 테이블들이 가장 최근에 변경된 시간을 비교한다. <strong>쿼리 캐시를 적용하고 난 후에 쿼리 캐시가 사용하는 테이블에 조금이라도 변경이 있으면 데이터베이스에서 데이터를 읽어와서 쿼리 결과를 다시 캐시한다.</strong></p>

<p><strong>쿼리 캐시를 잘 활용하면 극적인 성능 향상이 있지만 빈번하게 변경이 있는 테이블에 사용하면 오히려 성능이 더 저하된다.</strong> 따라서 수정이 거의 일어나지 않는 테이블에 사용해야 효과를 볼 수 있다.</p>

<div class="notice--warning">
<p><strong>주의</strong><br />
<code class="language-plaintext highlighter-rouge">org.hibernate.cache.spi.UpdateTimestampsCache</code> 쿼리 캐시 영역은 만료되지 않도록 설정해야 한다. 해당 영역이 만료되면 모든 쿼리 캐시가 무효화된다. <code class="language-plaintext highlighter-rouge">EHCACHE</code>의 <code class="language-plaintext highlighter-rouge">eternal="true"</code> 옵션을 사용하면 캐시에서 삭제되지 않는다.</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;cache</span>
    <span class="na">name=</span><span class="s">"org.hibernate.cache.spi.UpdateTimestampsCache"</span>
    <span class="na">maxElementsInMemory=</span><span class="s">"10000"</span>
    <span class="na">eternal=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>
</div>
<p><br /></p>

<p><strong>쿼리 캐시와 컬렉션 캐시의 주의점</strong><br />
엔티티 캐시를 사용해서 엔티티를 캐시하면 엔티티 정보를 모두 캐시하지만 <strong>쿼리 캐시와 컬렉션 캐시는 결과 집합의 식별자 값만 캐시한다.</strong> 그리고 이 식별자 값을 한나씩 엔티티 캐시에 조회해서 실제 엔티티를 찾는다.</p>

<p><strong>문제는 쿼리 캐시나 컬렉션 캐시만 사용하고 대상 엔티티에 엔티티 캐시를 적용하지 않으면 성능상 심각한 문제가 발생할 수 있다.</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">select m from Member m</code> 쿼리를 실행했는데 쿼리 캐시가 적용되어 있다. 조회 결과는 100건이다.</li>
  <li>결과 집합에는 식별자만 있르므로 한 건씩 엔티티 캐시 영역에서 조회한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Member</code> 엔티티는 엔티티 캐시를 사용하지 않으므로 한 건씩 데이터베이스에서 조회한다.</li>
  <li>100건의 SQL이 실행된다.</li>
</ol>

<p>따라서 <strong>쿼리 캐시나 컬렉션 캐시를 사용하면 결과 대상 엔티티에는 꼭 엔티티 캐시를 적용해야 한다.</strong></p>

<p><br />
<br /></p>

<h2 id="163-정리">16.3 정리</h2>
<ul>
  <li>트랜잭션의 격리 수준은 4단계가 있다. 격리 수준이 낮을수록 동시성은 증가하지만 격리 수준에 따른 다양한 문제가 발생한다.</li>
  <li>영속성 컨텍스트는 데이터베이스 트랜잭션이 <code class="language-plaintext highlighter-rouge">READ COMMITTED</code> 격리 수준이어도 애플리케이션 레벨에서 반복 가능한 읽기(<code class="language-plaintext highlighter-rouge">REPEATABLE READ</code>)를 제공한다.</li>
  <li>JPA는 낙관적 락과 비관적 락을 지원한다. 낙관적 락은 애플리케이션이 지원하는 락이고, 비관적 락은 데이터베이스 트랜잭션 락 메커니즘에 의존한다.</li>
  <li>2차 캐시를 사용하면 애플리케이션의 조회 성능 극적으로 끌어올릴 수 있다.</li>
</ul>

<p><br />
<br />
<br />
<br /></p>

<p><strong>감사합니다</strong> 🙇🏻‍♂️</p>

<p><a href="https://product.kyobobook.co.kr/detail/S000000935744" target="_blank">자바 ORM 표준 JPA 프로그래밍</a></p>]]></content><author><name>Oh</name></author><category term="Books" /><category term="Books" /><category term="JPA" /><category term="ORM" /><summary type="html"><![CDATA[자바 ORM 표준 JPA 프로그래밍 책을 읽고 내용을 아주 간단하게 정리한 글입니다. 책에는 자세한 설명과 예제가 많으니 꼭 구입해서 읽는것을 추천합니다~👍]]></summary></entry><entry><title type="html">📖 도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지</title><link href="http://localhost:4000/books/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="📖 도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지" /><published>2023-01-09T00:00:00+09:00</published><updated>2023-01-09T00:00:00+09:00</updated><id>http://localhost:4000/books/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/books/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"><![CDATA[<p><a href="https://product.kyobobook.co.kr/detail/S000001810495" target="_blank">도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지</a> 책을 읽고 내용을 아주 간단하게 정리한 글입니다. 책에는 자세한 설명과 예제가 많으니 <strong>꼭 구입해서 읽는것을 추천</strong>합니다~👍</p>

<hr />

<h1 id="1-도메인-모델-시작하기">1. 도메인 모델 시작하기</h1>
<h2 id="11-도메인이란">1.1 도메인이란?</h2>
<p>소프트웨어로 해결하고자 하는 문제 영역을 도메인이라 한다.</p>

<h2 id="12-도메인-전문가와-개발자-간-지식공유">1.2 도메인 전문가와 개발자 간 지식공유</h2>
<p>전문가나 관련자가 요구한 내용이 항상 올바른 것은 아니다. 그래서 개발자는 요구사항을 이해할 때 왜 이런 기능을 요구하는지 또는 실제로 원하는게 무엇인지 생각하고 전문가와 대화를 통해 진짜로 원하는 것을 찾아야 한다.</p>

<h2 id="13-도메인-모델">1.3 도메인 모델</h2>
<p>도메인 모델은 특정 도메인을 개념적으로 표현한 것이다. 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는데 도움이 된다. 도메인 모델을 이해하는 데 도움이 된다면 객체기반 표현이든, 함수 표현이든 표현 방식이 무엇인지는 중요하지 않다.</p>
<center><img src="/assets/images/posts/books/1/1_3_객체기반도메인모델.png" alt="객체기반도메인모델" width="100%" height="100%" /></center>
<center><img src="/assets/images/posts/books/1/1_3_상태다이어그램도메인모델.png" alt="상태다이어그램도메인모델" width="100%" height="100%" /></center>

<h2 id="14-도메인-모델-패턴">1.4 도메인 모델 패턴</h2>
<center><img src="/assets/images/posts/books/1/1_4_아키텍처구성.png" alt="아키텍처구성" width="70%" height="70%" /></center>

<table>
  <thead>
    <tr>
      <th>영역</th>
      <th>설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>사용자 인터페이스(UI) 또는 표현(Presentation)</td>
      <td>사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 여기서 사용자는 소프트웨어를 사용하는 사람뿐만 아니라 외부 시스템일 수도 있다.</td>
    </tr>
    <tr>
      <td>응용(Application)</td>
      <td>사용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다.</td>
    </tr>
    <tr>
      <td>도메인(Domain)</td>
      <td>시스템이 제공할 도메인 규칙을 구현한다.</td>
    </tr>
    <tr>
      <td>인프라스트럭처(Infrastructure)</td>
      <td>데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리한다.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p><strong>개념 모델과 구현 모델</strong><br />
<strong>개념 모델은 순수하게 문제를 분석한 결과물</strong>이다. 개념 모델은 데이터베이스, 트랜잭션 처리, 성능, 구현 기술과 같은 것을 고려하고 있지 않기 때문에 실제 코드를 작성할 때 개념 모델을 있는 그대로 사용할 수 없다. 그래서 개념 모델을 구현 가능한 형태의 모델로 전환하는 과정을 거치게 된다.</p>

<p><strong>처음부터 완벽한 개념 모델을 만들기보다는 전반적인 개요를 알 수 있는 수준으로 개념 모델을 작성</strong>해야한다. 프로젝트 초기에는 개요 수준의 개념 모델로 도메인에 대한 전체 윤곽을 이해하는 데 집중하고, <strong>구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전</strong>시켜 나가야 한다.</p>

<h2 id="15-도메인-모델-도출">1.5 도메인 모델 도출</h2>
<p>도메인을 모델링할 때 기본이 되는 작업은 <strong>모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것</strong>이다. 이 과정은 요구사항에서 출발한다. <strong>요구사항을 통해 도메인 모델을 점진적으로 만들어 나간다</strong>. 이렇게 만든 모델은 요구사항 정련을 위해 도메인 전문가나 다른 개발자와 논의하는 과정에서 공유되기도 한다. 모델을 공유할 때는 화이트보드나 위키 같은 도구를 사용해서 누구나 쉽게 접근할 수 있도록 하면 좋다.</p>

<h2 id="16-엔티티와-벨류">1.6 엔티티와 벨류</h2>
<h3 id="161-엔티티">1.6.1 엔티티</h3>
<ul>
  <li>식별자를 가진다.</li>
  <li>식별자는 엔티티 객체마다 고유하다.</li>
</ul>

<h3 id="162-엔티티의-식별자-생성">1.6.2 엔티티의 식별자 생성</h3>
<ul>
  <li>특정 규칙에 따라 생성.</li>
  <li>UUID나 Nano ID와 같은 고유 식별자 생성기 사용.</li>
  <li>값을 직접 입력.</li>
  <li>일련번호 사용(시퀀스나 DB의 자동 증가 컬럼 사용).</li>
</ul>

<h3 id="163-밸류-타입">1.6.3 밸류 타입</h3>
<ul>
  <li>밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용한다.</li>
  <li>의미를 명확하게 표현하기 위해 사용되기도 한다.</li>
  <li>밸류 타입을 위한 기능을 추가할 수 있다.</li>
  <li>불변으로 구현한다.</li>
</ul>

<h3 id="164-엔티티-식별자와-밸류-타입">1.6.4 엔티티 식별자와 밸류 타입</h3>
<ul>
  <li>식별자를 위한 밸류 타입을 사용해서 의미가 잘 드러나도록 할 수 있다.</li>
</ul>

<h3 id="165-도메인-모델에-set-넣지-않기">1.6.5 도메인 모델에 set 넣지 않기</h3>
<ul>
  <li>상태 변경을 위한 set 사용시 도메인 지식이 코드에서 사라진다.</li>
  <li>객체를 생성할 때 온전하지 않은 상태가 될 수 있다.</li>
</ul>

<p><strong>DTO도 최대한 불변 객체로 사용하도록 하자</strong></p>

<h2 id="17-도메인-용어와-유비쿼터스-언어">1.7 도메인 용어와 유비쿼터스 언어</h2>
<p><strong>도메인 용어</strong><br />
STEP1, STEP2 같은것이 아닌 PAYMENT_WAITING, PREPARING 같은 도메인 용어를 사용하여 코드를 작성한다.</p>

<p><strong>유비쿼터스 언어</strong><br />
전문가, 관계자 개발자가 도메인과 관련된 공통의 언어를 만들고 이를 대화, 문서, 도메인 모델, 코드 테스트 등 모든 곳에서 같은 용어를 사용한다. 이렇게 하면 소통 과정에서 발생하는 용어의 모호함을 줄일 수 있고 개발자는 도메인과 코드 사이에서 불필요한 해석 과정을 줄일 수 있다.</p>

<p><br />
<br />
<br /></p>

<h1 id="2-아키택처-개요">2. 아키택처 개요</h1>
<h2 id="21-네-개의-영역">2.1 네 개의 영역</h2>
<p><strong>표현 영역</strong><br />
사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할</p>
<center><img src="/assets/images/posts/books/1/2_1_표현영역.png" alt="표현영역" width="80%" height="80%" /></center>

<p><br /></p>

<p><strong>응용 영역</strong><br />
표현 영역을 통해 요청을 전달받아 시스템이 사용자에게 제공해야 할 기능을 구현하는 역할. 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.</p>
<center><img src="/assets/images/posts/books/1/2_1_응용영역.png" alt="응용영역" width="80%" height="80%" /></center>

<p><br /></p>

<p><strong>도메인 영역</strong><br />
도메인 모델을 구현. 도메인 모델은 도메인의 핵심 로직을 구현한다.</p>

<p><br /></p>

<p><strong>인프라스트럭처 영역</strong><br />
구현 기술에 대한 것을 다룬다. 이 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.</p>
<center><img src="/assets/images/posts/books/1/2_1_인프라스트럭처영역.png" alt="인프라스트럭처영역" width="60%" height="60%" /></center>

<h2 id="22-계층-구조-아키텍처">2.2 계층 구조 아키텍처</h2>
<center><img src="/assets/images/posts/books/1/2_2_계층구조.png" alt="계층구조" width="60%" height="60%" /></center>
<center><img src="/assets/images/posts/books/1/2_2_계층구조상의존관계.png" alt="계층구조상의존관계" width="60%" height="60%" /></center>
<ul>
  <li>상위 계층에서 하위 계층으로 의존만 존재하고 하위 계층에서 상위 계층에 의존하지 않는다.</li>
</ul>

<h2 id="23-dip">2.3 DIP</h2>
<p>DIP(Dependency Inversion Principle) 의존성 역전 원칙</p>

<center><img src="/assets/images/posts/books/1/2_3_고수준저수준.png" alt="고수준저수준" width="60%" height="60%" /></center>
<center><img src="/assets/images/posts/books/1/2_3_고수준저수준2.png" alt="고수준저수준2" width="60%" height="60%" /></center>
<center><img src="/assets/images/posts/books/1/2_3_고수준저수준3.png" alt="고수준저수준3" width="60%" height="60%" /></center>
<center><img src="/assets/images/posts/books/1/2_3_DIP.png" alt="DIP" width="70%" height="70%" /></center>

<h2 id="24-도메인-영역의-주요-구성요소">2.4 도메인 영역의 주요 구성요소</h2>

<table>
  <thead>
    <tr>
      <th><strong>요소</strong></th>
      <th><strong>설명</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>엔티티 ENTITY</td>
      <td>고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다. 주문, 회원, 상품과 같이 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다.</td>
    </tr>
    <tr>
      <td>밸류 VALUE</td>
      <td>고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현한다. 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다.</td>
    </tr>
    <tr>
      <td>애그리거트 AGGREGATE</td>
      <td>연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. 예를 들어 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 ‘주문’ 애그리거트로 묶을 수 있다.</td>
    </tr>
    <tr>
      <td>리포지터리 REPOSITORY</td>
      <td>도메인 모델의 영속성을 처리한다. 예를 들어 DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공한다.</td>
    </tr>
    <tr>
      <td>도메인 서비스 DOMAIN SERVICE</td>
      <td>특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다.</td>
    </tr>
  </tbody>
</table>

<h2 id="25-요청-처리-흐름">2.5 요청 처리 흐름</h2>
<center><img src="/assets/images/posts/books/1/2_5_요청처리흐름.png" alt="요청처리흐름" width="80%" height="80%" /></center>

<h2 id="26-인프라스트럭처-개요">2.6 인프라스트럭처 개요</h2>
<ul>
  <li>도메인 객체의 영속성 처리, 트랜젝션, REST 클라이언트 등 다른영역에서 필요로 하는 프레임워크, 구현 기술, 보조 기능을 지원한다.</li>
  <li>보통 의존성역전 사용</li>
  <li>@Transactional 같은 DIP를 사용하지 않는 예외도 편의를 위해 허용</li>
</ul>

<h2 id="27-모듈-구성">2.7 모듈 구성</h2>
<center><img src="/assets/images/posts/books/1/2_7_모듈구성1.png" alt="모듈구성1" width="80%" height="80%" /></center>
<center><img src="/assets/images/posts/books/1/2_7_모듈구성2.png" alt="모듈구성2" width="80%" height="80%" /></center>
<center><img src="/assets/images/posts/books/1/2_7_모듈구성3.png" alt="모듈구성3" width="80%" height="80%" /></center>

<p><br />
<br />
<br /></p>

<h1 id="3-애그리거트">3. 애그리거트</h1>
<h2 id="31-애그리거트">3.1 애그리거트</h2>
<p>복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만드려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 애그리거트다. 애그리거트는 관련된 객체를 하나의 군으로 묶어 준다.</p>
<center><img src="/assets/images/posts/books/1/3_1_애거리거트모델.png" alt="애거리거트모델" width="80%" height="80%" /></center>

<p>애그리거트는 경계를 갖는다. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 애그리거트는 독립된 객체 군이며 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다. 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다. 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.</p>

<h2 id="32-애그리거트-루트">3.2 애그리거트 루트</h2>
<p>애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트 루트 엔티티이다. 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다.</p>
<center><img src="/assets/images/posts/books/1/3_2_애그리거트루트.png" alt="애그리거트루트" width="80%" height="80%" /></center>

<h3 id="321-도메인-규칙과-일관성">3.2.1 도메인 규칙과 일관성</h3>
<ul>
  <li>애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.</li>
  <li>애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다. 이것은 모델의 일관성을 깨는 원인이 된다.</li>
  <li>단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.</li>
  <li>밸류 타입은 불변으로 구현한다.</li>
</ul>

<h3 id="322-애그리거트-루트의-기능-구현">3.2.2 애그리거트 루트의 기능 구현</h3>
<ul>
  <li>애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해 기능을 완성한다.</li>
  <li>애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니다. 기능 실행을 위임하기도 한다.</li>
</ul>

<h3 id="323-트랜젝션-범위">3.2.3 트랜젝션 범위</h3>
<ul>
  <li>작을수록 좋다</li>
  <li>한 트랜젝션에서는 한 개의 애그리거트만 수정한다.</li>
  <li>부득이하게 한 트랜젝션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 수정하지 말고, 응용 서비스에서 애그리거트를 수정하도록 구현한다.</li>
  <li>두 개 이상의 애그리거트를 수정해야 한다면, 도메인 이벤트를 사용한다.</li>
</ul>

<h2 id="33-리포지터리와-애그리거트">3.3 리포지터리와 애그리거트</h2>
<ul>
  <li>애그리거트: 개념상 완전한 하나의 도메인 모델</li>
  <li>리포지터리: 애그리거트 영속성을 처리
    <ul>
      <li>save: 애그리거트 저장</li>
      <li>findById: ID로 애그리거트를 구함</li>
    </ul>
  </li>
</ul>

<h2 id="34-id를-이용한-애그리거트-참조">3.4 ID를 이용한 애그리거트 참조</h2>
<ul>
  <li>애그리거트도 다른 애그리거트를 참조한다.</li>
  <li>애그리거트 참조는 애그리거트 루트가 다른 애그리거트 루트를 참조한다는 뜻이다.</li>
</ul>

<p><br /></p>

<p><strong>필드 참조</strong></p>
<center><img src="/assets/images/posts/books/1/3_4_필드참조.png" alt="필드참조" width="80%" height="80%" /></center>

<p><strong>필드 참조 문제점</strong></p>
<ul>
  <li>편한 탐색 오용</li>
  <li>결합도 증가</li>
  <li>성능에 대한 고민</li>
  <li>확장 어려움</li>
</ul>

<p><br /></p>

<p><strong>ID를 이용한 참조</strong></p>
<center><img src="/assets/images/posts/books/1/3_4_ID참조.png" alt="ID참조" width="80%" height="80%" /></center>

<p><strong>ID 참조 장점</strong></p>
<ul>
  <li>모델의 복잡도를 낮춘다</li>
  <li>응집도 증가</li>
  <li>구현 난이도 감소</li>
  <li>확장 용이</li>
</ul>

<h3 id="341-id를-이용한-참조와-조회-성능">3.4.1 ID를 이용한 참조와 조회 성능</h3>

<p>ID를 이용한 조회는 <strong>N + 1 문제가 발생</strong>한다.<br />
해결방법은 아래와 같다.</p>
<ul>
  <li>조회 전용 쿼리를 만들어 사용한다.</li>
  <li>쿼리가 복잡하거나 특화된 기능을 사용해야 한다면 마이바티스와 같은 기술로 구현하는걸 고려한다.</li>
</ul>

<h2 id="35-애그리거트-간-집합-연관">3.5 애그리거트 간 집합 연관</h2>
<p>1-N, M-N 연관에 대해 살펴본다.</p>

<p><strong>1-N</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Category</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span><span class="o">;</span> <span class="c1">//다른 애그리거트에 대한 1-N 연관</span>
<span class="o">}</span>
</code></pre></div></div>
<p>조회시 개념적으로 애거리거트 간에 1-N 연관이 있더라도 성능 문제 때문에 실제 구현에 반영하지 않는다. N-1로 연관지어 구현한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">CategoryId</span> <span class="n">categoryId</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductListService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Page</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="nf">getProductOfCategory</span><span class="o">(</span><span class="nc">Long</span> <span class="n">categoryId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">page</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Category</span> <span class="n">category</span> <span class="o">=</span> <span class="n">categoryRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">categoryId</span><span class="o">);</span>
        <span class="n">checkCategory</span><span class="o">(</span><span class="n">category</span><span class="o">);</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span> <span class="o">=</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">findByCategoryId</span><span class="o">(</span><span class="n">category</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">page</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">totalCount</span> <span class="o">=</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">countByCategoryId</span><span class="o">(</span><span class="n">category</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Page</span><span class="o">(</span><span class="n">page</span><span class="o">,</span> <span class="n">size</span><span class="o">,</span> <span class="n">totalCount</span><span class="o">,</span> <span class="n">products</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>M-N</strong><br />
M-N 연관은 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다. 하지만 구현은 요구사항을 고려해서 결정한다. 개념적으로는 상품과 카테고리의 양방향 M-N 연관이 존재하지만 실제 구현에서는 상품에서 카테고리로의 단방향 M-N 연관만 적용하면 되는 것이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">CategoryId</span><span class="o">&gt;</span> <span class="n">categoryIds</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>RDBMS에서 M-N 연관 구현</strong></p>
<center><img src="/assets/images/posts/books/1/3_5_RDBMS_M-N연관.png" alt="RDBMS_M-N연관" width="80%" height="80%" /></center>

<p><br /></p>

<p><strong>JPA를 이용하여 ID 참조를 이용한 M-N 단방향 연관 구현</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="nd">@EmbeddedId</span>
    <span class="kd">private</span> <span class="nc">ProductId</span> <span class="n">id</span><span class="o">;</span>
    
    <span class="nd">@ElementCollection</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_category"</span><span class="o">,</span>
        <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_id"</span><span class="o">))</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">CategoryId</span><span class="o">&gt;</span> <span class="n">categoryIds</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="36-애그리거트를-팩토리로-사용하기">3.6 애그리거트를 팩토리로 사용하기</h2>
<ul>
  <li>애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려한다.</li>
  <li>별도의 도메인 서비스나, 팩토리 클래스를 만들 수도 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Store</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">Product</span> <span class="nf">createProduct</span> <span class="o">(</span><span class="nc">ProductId</span> <span class="n">newProductId</span><span class="o">,</span> <span class="o">...</span><span class="na">생략</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isBlocked</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">StoreBlockedException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Product</span><span class="o">(</span><span class="n">newProductId</span><span class="o">,</span> <span class="n">getId</span><span class="o">(),</span> <span class="o">...</span><span class="na">생략</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br /></p>

<h1 id="4-리포지터리와-모델-구현">4. 리포지터리와 모델 구현</h1>
<p>자세한 설명은 아래의 문서와 책을 읽는 것을 추천합니다. 👍</p>
<ul>
  <li><a href="https://product.kyobobook.co.kr/detail/S000001810495" target="_blank">도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지</a></li>
  <li><a href="http://www.yes24.com/Product/Goods/19040233" target="_blank">자바 ORM 표준 JPA 프로그래밍</a></li>
  <li><a href="https://spring.io/projects/spring-data-jpa" target="_blank">Spring Data JPA</a></li>
</ul>

<h2 id="41-jpa를-이용한-리포지터리-구현">4.1 JPA를 이용한 리포지터리 구현</h2>
<h3 id="411-모듈-위치">4.1.1 모듈 위치</h3>
<center><img src="/assets/images/posts/books/1/4_1_모듈위치.png" alt="모듈위치" width="80%" height="80%" /></center>

<h3 id="412-리포지터리-기본-기능-구현">4.1.2 리포지터리 기본 기능 구현</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderRepository</span> <span class="o">{</span>
    <span class="nc">Order</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">OrderNo</span> <span class="n">no</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JpaOrderRepository</span> <span class="kd">implements</span> <span class="nc">OrderRepository</span> <span class="o">{</span>
    <span class="nd">@PersistenceContext</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">entityManager</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Order</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">OrderNo</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">entityManager</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="42-스프링-데이터-jpa를-이용한-리포지터리-구현">4.2 스프링 데이터 JPA를 이용한 리포지터리 구현</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"purchase_order"</span><span class="o">)</span>
<span class="nd">@Access</span><span class="o">(</span><span class="nc">AccessType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="nd">@EmbeddedId</span>
    <span class="kd">private</span> <span class="nc">OrderNo</span> <span class="n">number</span><span class="o">;</span>

    <span class="nd">@Version</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">version</span><span class="o">;</span>

    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Orderer</span> <span class="n">orderer</span><span class="o">;</span>

    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderRepository</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">,</span> <span class="nc">OrderNo</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">OrderNo</span> <span class="n">id</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">);</span>

    <span class="k">default</span> <span class="nc">OrderNo</span> <span class="nf">nextOrderNo</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">randomNo</span> <span class="o">=</span> <span class="nc">ThreadLocalRandom</span><span class="o">.</span><span class="na">current</span><span class="o">().</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">900000</span><span class="o">)</span> <span class="o">+</span> <span class="mi">100000</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">number</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"%tY%&lt;tm%&lt;td%&lt;tH-%d"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">(),</span> <span class="n">randomNo</span><span class="o">);</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">OrderNo</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CancelOrderService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">OrderRepository</span> <span class="n">orderRepository</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">CancelPolicy</span> <span class="n">cancelPolicy</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CancelOrderService</span><span class="o">(</span><span class="nc">OrderRepository</span> <span class="n">orderRepository</span><span class="o">,</span> <span class="nc">CancelPolicy</span> <span class="n">cancelPolicy</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">orderRepository</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cancelPolicy</span> <span class="o">=</span> <span class="n">cancelPolicy</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(</span><span class="nc">OrderNo</span> <span class="n">orderNo</span><span class="o">,</span> <span class="nc">Canceller</span> <span class="n">canceller</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">orderNo</span><span class="o">)</span>
                <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">NoOrderException</span><span class="o">());</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">cancelPolicy</span><span class="o">.</span><span class="na">hasCancellationPermission</span><span class="o">(</span><span class="n">order</span><span class="o">,</span> <span class="n">canceller</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoCancellablePermission</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">order</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="43-매핑-구현">4.3 매핑 구현</h2>
<h3 id="431-엔티티와-밸류-기본-매핑-구현">4.3.1 엔티티와 밸류 기본 매핑 구현</h3>
<p>애그리거트와 JPA 매핑을 위한 기본 규칙</p>
<ul>
  <li>애그리거트 루트는 엔티티이므로 <code class="language-plaintext highlighter-rouge">@Entity</code>로 매핑 설정한다.</li>
</ul>

<p>한 테이블에 엔티티와 밸류 데이터가 같이 있다면</p>
<ul>
  <li>밸류는 <code class="language-plaintext highlighter-rouge">@Embeddable</code>로 매핑 설정한다.</li>
  <li>밸류 타입 프로퍼티는 <code class="language-plaintext highlighter-rouge">@Embedded</code>로 매핑 설정한다.</li>
  <li>매핑할 컬럼명 변경은 <code class="language-plaintext highlighter-rouge">@AttributeOverrides</code> 를 이용한다</li>
</ul>

<center><img src="/assets/images/posts/books/1/4_3_매핑구현.png" alt="매핑구현" width="80%" height="80%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShippingInfo</span> <span class="o">{</span>
    <span class="nd">@Embedded</span>
    <span class="nd">@AttributeOverrides</span><span class="o">({</span>
            <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"zipCode"</span><span class="o">,</span> <span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"shipping_zip_code"</span><span class="o">)),</span>
            <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"address1"</span><span class="o">,</span> <span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"shipping_addr1"</span><span class="o">)),</span>
            <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"address2"</span><span class="o">,</span> <span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"shipping_addr2"</span><span class="o">))</span>
    <span class="o">})</span>
    <span class="kd">private</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"shipping_message"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">message</span><span class="o">;</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Receiver</span> <span class="n">receiver</span><span class="o">;</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"purchase_order"</span><span class="o">)</span>
<span class="nd">@Access</span><span class="o">(</span><span class="nc">AccessType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">Orderer</span> <span class="n">orderer</span><span class="o">;</span>

    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">ShippingInfo</span> <span class="n">shippingInfo</span><span class="o">;</span>
    <span class="o">...</span>
</code></pre></div></div>

<h3 id="432-기본-생성자">4.3.2 기본 생성자</h3>
<p>엔티티는 기본 생성자가 필요하다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protected</span> <span class="nf">Receiver</span><span class="o">(){}</span>
</code></pre></div></div>

<h3 id="432-필드-접근-방식-사용">4.3.2 필드 접근 방식 사용</h3>
<p><code class="language-plaintext highlighter-rouge">@Access</code>를 이용해서 명시적으로 접근 방식을 지정하지 않으면 <code class="language-plaintext highlighter-rouge">@Id</code>나 <code class="language-plaintext highlighter-rouge">@EmbeddedId</code>의 위치에 따라 접근 방식을 결정한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"purchase_order"</span><span class="o">)</span>
<span class="nd">@Access</span><span class="o">(</span><span class="nc">AccessType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="434-attributeconverter를-이용한-밸류-매핑-처리">4.3.4 AttributeConverter를 이용한 밸류 매핑 처리</h3>
<p><strong>두 개 이상의 프로퍼티를 가진 밸류 타입을 한 개 컬럼에 매핑</strong>하려면 <code class="language-plaintext highlighter-rouge">@Embeddable</code> 애너테이션으로는 처리할 수 없다. 이럴 때 사용할 수 있는 것이 <code class="language-plaintext highlighter-rouge">AttributeConverter</code>이다.</p>

<center><img src="/assets/images/posts/books/1/4_3_두개프러퍼컬럼매핑.png" alt="두개프러퍼컬럼매핑" width="100%" height="100%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Converter</span><span class="o">(</span><span class="n">autoApply</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MoneyConverter</span> <span class="kd">implements</span> <span class="nc">AttributeConverter</span><span class="o">&lt;</span><span class="nc">Money</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span> 
    <span class="c1">// Money는 밸류 타입, Integer는 DB 타입</span>

    <span class="c1">// 밸류 타입을 DB 칼럼 값으로 변환</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">convertToDatabaseColumn</span><span class="o">(</span><span class="nc">Money</span> <span class="n">money</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">money</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">money</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// DB 칼럼 값을 밸류로 변환</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">Money</span> <span class="nf">convertToEntityAttribute</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">Money</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @Converter(autoApply = true) 작성한 타입에 대해 자동 적용</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"total_amounts"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Money</span> <span class="n">totalAmounts</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @Converter(autoApply = false) 기본값, 직접 지정해야함</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>

    <span class="nd">@Convert</span><span class="o">(</span><span class="n">converter</span> <span class="o">=</span> <span class="nc">MoneyConverter</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"total_amounts"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Money</span> <span class="n">totalAmounts</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="435-밸류-컬렉션-별도-테이블-매핑">4.3.5 밸류 컬렉션: 별도 테이블 매핑</h3>
<p>밸류 컬렉션을 별도 테이블로 매핑할때는 <code class="language-plaintext highlighter-rouge">@ElementCollection</code>과 <code class="language-plaintext highlighter-rouge">@CollectionTable</code>을 함께 사용한다.</p>

<center><img src="/assets/images/posts/books/1/4_3_밸류컬렉션테이블매핑.png" alt="밸류컬렉션테이블매핑" width="70%" height="70%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"purchase_order"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="nd">@EmbeddedId</span>
    <span class="kd">private</span> <span class="nc">OrderNo</span> <span class="n">number</span><span class="o">;</span>

    <span class="nd">@ElementCollection</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"order_line"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"order_number"</span><span class="o">))</span>
    <span class="nd">@OrderColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"line_idx"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderLine</span> <span class="o">{</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">ProductId</span> <span class="n">productId</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"price"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Money</span> <span class="n">price</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"quantity"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"amounts"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Money</span> <span class="n">amounts</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="436-밸류-컬렉션-한-개-컬럼-매핑">4.3.6 밸류 컬렉션: 한 개 컬럼 매핑</h3>
<p>한 개 컬럼에 콤마로 구분해서 저장할 때 사용. <code class="language-plaintext highlighter-rouge">AttributeConverter</code>를 이용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailSet</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Email</span><span class="o">&gt;</span> <span class="n">emails</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="nf">EmailSet</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Email</span><span class="o">&gt;</span> <span class="n">emails</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">emails</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">emails</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Email</span><span class="o">&gt;</span> <span class="nf">getEmails</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="n">emails</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailSetConverter</span> <span class="kd">implements</span> <span class="nc">AttributeConverter</span><span class="o">&lt;</span><span class="nc">EmailSet</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">convertToDatabaseColumn</span><span class="o">(</span><span class="nc">EmailSet</span> <span class="n">attribute</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">attribute</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">attribute</span><span class="o">.</span><span class="na">getEmails</span><span class="o">().</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">email</span> <span class="o">-&gt;</span> <span class="n">email</span><span class="o">.</span><span class="na">getAddress</span><span class="o">())</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">","</span><span class="o">));</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">EmailSet</span> <span class="nf">convertToEntityAttribute</span><span class="o">(</span><span class="nc">String</span> <span class="n">dbData</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">dbData</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">emails</span> <span class="o">=</span> <span class="n">dbData</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Email</span><span class="o">&gt;</span> <span class="n">emailSet</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">emails</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">value</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Email</span><span class="o">(</span><span class="n">value</span><span class="o">))</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toSet</span><span class="o">());</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">EmailSet</span><span class="o">(</span><span class="n">emailSet</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="437-밸류를-이용한-id-매핑">4.3.7 밸류를 이용한 ID 매핑</h3>
<p>JPA에서 식별자 타입은 <code class="language-plaintext highlighter-rouge">Serializable</code> 타입이어야 하므로 <code class="language-plaintext highlighter-rouge">Serializable</code> 인터페이스를 상속받아야 한다. 밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점은 식별자에 기능을 추가할 수 있다는 점이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"purchase_order"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="nd">@EmbeddedId</span>
    <span class="kd">private</span> <span class="nc">OrderNo</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderNo</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"order_number"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="438-별도-테이블에-저장하는-밸류-매핑">4.3.8 별도 테이블에 저장하는 밸류 매핑</h3>
<p>루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해 봐야한다. 단지 별도 테이블에 데이터를 저장 한다고 해서 엔티티인 것은 아니다.</p>

<p>예를 들어 게시글 데이터를 <code class="language-plaintext highlighter-rouge">ARTICLE</code> 테이블과 <code class="language-plaintext highlighter-rouge">ARTICLE_CONTENT</code> 테이블로 나눠서 저장한다고 하자.</p>

<p><strong>엔티티로 매핑 예 (잘못 됨)</strong></p>
<center><img src="/assets/images/posts/books/1/4_3_밸류매핑잘못.png" alt="밸류매핑잘못" width="80%" height="80%" /></center>
<p><code class="language-plaintext highlighter-rouge">ARTICLE_CONTENT</code>에 ID는 식별자이긴 하지만 이는 <code class="language-plaintext highlighter-rouge">ARTICLE</code> 테이블과 연결을 위함이지 <code class="language-plaintext highlighter-rouge">ARTICLE_CONTENT</code>를 위한 별도 식별자가 필요해서가 아니다.</p>

<p><br /></p>

<p><strong>별도 테이블로 매핑</strong></p>
<center><img src="/assets/images/posts/books/1/4_3_밸류매핑별도테이블.png" alt="밸류매핑별도테이블" width="80%" height="80%" /></center>
<p><code class="language-plaintext highlighter-rouge">ARTICLE_CONTENT</code>을 밸류로 만들고 @Embeddable로 매핑한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"article"</span><span class="o">)</span>
<span class="nd">@SecondaryTable</span><span class="o">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s">"article_content"</span><span class="o">,</span>
        <span class="n">pkJoinColumns</span> <span class="o">=</span> <span class="nd">@PrimaryKeyJoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"id"</span><span class="o">)</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Article</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">title</span><span class="o">;</span>

    <span class="nd">@AttributeOverrides</span><span class="o">({</span>
            <span class="nd">@AttributeOverride</span><span class="o">(</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s">"content"</span><span class="o">,</span>
                    <span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">table</span> <span class="o">=</span> <span class="s">"article_content"</span><span class="o">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"content"</span><span class="o">)),</span>
            <span class="nd">@AttributeOverride</span><span class="o">(</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s">"contentType"</span><span class="o">,</span>
                    <span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">table</span> <span class="o">=</span> <span class="s">"article_content"</span><span class="o">,</span> <span class="n">name</span> <span class="o">=</span> <span class="s">"content_type"</span><span class="o">))</span>
    <span class="o">})</span>
    <span class="nd">@Embedded</span>
    <span class="kd">private</span> <span class="nc">ArticleContent</span> <span class="n">content</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>밸류 매핑을 별도 테이블로 저장 하려면 <code class="language-plaintext highlighter-rouge">@SecondaryTable</code>과 <code class="language-plaintext highlighter-rouge">@AttributeOverride</code>을 사용한다.
하지만 <code class="language-plaintext highlighter-rouge">@SecondaryTable</code>은 <code class="language-plaintext highlighter-rouge">jpa.find("id");</code>(조회)를 실행할 때 두 테이블을 조인해서 가져온다. 게시글 목록 같은 화면은 <code class="language-plaintext highlighter-rouge">ARTICLE</code>의 데이터만 필요하지 <code class="language-plaintext highlighter-rouge">ARTICLE_CONTENT</code>는 필요없다.</p>

<p>이를 해결하기 위해 <code class="language-plaintext highlighter-rouge">ARTICLE_CONTENT</code>을 엔티티로 매핑하고 <code class="language-plaintext highlighter-rouge">ARTICLE</code>에서 <code class="language-plaintext highlighter-rouge">ARTICLE_CONTENT</code>을 지연로딩 할 수도 있다. 하지만 이는 밸류 모델을 엔티티로 만드는 것이므로 좋은 방법은 아니다. 대신 조회 전용 기능을 사용하는 것이 좋다.</p>

<h3 id="439-밸류-컬렉션을-entity로-매핑하기">4.3.9 밸류 컬렉션을 @Entity로 매핑하기</h3>
<p><code class="language-plaintext highlighter-rouge">@OneToMany</code> 사용하여 연관관계를 맺는다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">cascade</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CascadeType</span><span class="o">.</span><span class="na">PERSIST</span><span class="o">,</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">REMOVE</span><span class="o">},</span>
            <span class="n">orphanRemoval</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_id"</span><span class="o">)</span>
    <span class="nd">@OrderColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"list_idx"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Image</span><span class="o">&gt;</span> <span class="n">images</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">@Inheritance</code>를 이용하여 엔티티 상속도 가능하다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Inheritance</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">InheritanceType</span><span class="o">.</span><span class="na">SINGLE_TABLE</span><span class="o">)</span>
<span class="nd">@DiscriminatorColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"image_type"</span><span class="o">)</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"image"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Image</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"II"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InternalImage</span> <span class="kd">extends</span> <span class="nc">Image</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"EI"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExternalImage</span> <span class="kd">extends</span> <span class="nc">Image</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
</code></pre></div></div>

<h3 id="4310-id-참조와-조인-테이블을-이용한-단방향-m-n-매핑">4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@ElementCollection</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_category"</span><span class="o">,</span>
            <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_id"</span><span class="o">))</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">CategoryId</span><span class="o">&gt;</span> <span class="n">categoryIds</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="44-애그리거트-로딩-전략">4.4 애그리거트 로딩 전략</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @Embeddable 컬렉션에 대한 즉시 로딩 설정</span>
<span class="nd">@ElementCollection</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>

<span class="c1">// @Entity 컬렉션에 대한 지연 로딩 설정</span>
<span class="nd">@OneToMany</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
</code></pre></div></div>
<ul>
  <li>즉시 로딩: 에그리거트 루트를 구할 때 연관된 구성 요소를 DB에서 함께 읽어온다.</li>
  <li>지연 로딩: 실제 컬렉션에 접근할 때 DB에서 조회한다.</li>
</ul>

<h2 id="45-애그리거트-영속성-전파">4.5 애그리거트 영속성 전파</h2>
<p>애그리거트가 완전한 상태여야 한다는 것은 <strong>애그리거트 루트를 조회할 때뿐만 아니라 저장하고 삭제할 때도 하나로 처리해야 함을 의미</strong>한다.</p>
<ul>
  <li><strong>저장 메서드</strong>는 애그리거트 루트만 저장하면 안되고 <strong>애그리거트에 속한 모든 객체를 저장</strong>해야 한다.</li>
  <li><strong>삭제 메서드</strong>는 애그리거트 루트뿌만 아니라 <strong>애그리거트에 속한 모든 객체를 삭제</strong>해야 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">@Embeddable</code> 매핑 타입은 함께 저장되고 삭제 되므로 추가 설정이 필요없다.</li>
  <li><code class="language-plaintext highlighter-rouge">@Entity</code> 타입에 대한 매핑은 <code class="language-plaintext highlighter-rouge">cascade</code> 속성을 사용한다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@OneToMany</span><span class="o">(</span><span class="n">cascade</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CascadeType</span><span class="o">.</span><span class="na">PERSIST</span><span class="o">,</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">REMOVE</span><span class="o">})</span>
</code></pre></div></div>

<h2 id="46-식별자-생성-기능">4.6 식별자 생성 기능</h2>
<p>식별자는 크게 세 가지 방식 중 하나로 생성한다.</p>
<ul>
  <li>사용자가 직접 생성</li>
  <li>도메인 로직으로 생성</li>
  <li>DB를 이용한 일련번호 사용</li>
</ul>

<h2 id="47-도메인-구현과-dip">4.7 도메인 구현과 DIP</h2>
<p>JPA의 @Entity나 @Table, extends Repository 인터페이스는 DIP 원칙을 어기고 있지만 개발 편의성과 실용성을 가지고, 복잡도를 높이지 않으면서 기술에 따른 구현 제약이 낮다면 합리적으로 선택하여 사용할 수 있다.</p>

<p><br />
<br />
<br /></p>

<h1 id="5-스프링-데이터-jpa를-이용한-조회-기능">5. 스프링 데이터 JPA를 이용한 조회 기능</h1>

<h2 id="51-시작에-앞서">5.1 시작에 앞서</h2>
<h2 id="52-검색을-위한-스펙">5.2 검색을 위한 스펙</h2>
<p>조회를 위해 다양한 검색 조건을 조합해야 할 때가 있다. 이 때 사용할 수 있는 것이 스펙(<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#specifications" target="_blank">Specification</a>)이다.</p>

<h2 id="53-스프링-데이터-jpa를-이용한-스펙-구현">5.3 스프링 데이터 JPA를 이용한 스펙 구현</h2>

<p><strong>스프링 데이터 JPA가 제공하는 Specification 인터페이스</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nc">Predicate</span> <span class="nf">toPredicate</span><span class="o">(</span><span class="nc">Root</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span> <span class="nc">CriteriaQuery</span><span class="o">&lt;?&gt;</span> <span class="n">query</span><span class="o">,</span> <span class="nc">CriteriaBuilder</span> <span class="n">builder</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>레포지토리 인터페이스 상속</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">CustomerRepository</span> <span class="kd">extends</span> <span class="nc">CrudRepository</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;,</span> <span class="nc">JpaSpecificationExecutor</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">(</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="n">spec</span><span class="o">);</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">(</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="n">spec</span><span class="o">,</span> <span class="nc">Sort</span> <span class="n">sort</span><span class="o">);</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">(</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="n">spec</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>스펙 생성 기능을 별도 클래스로 구현</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomerSpecs</span> <span class="o">{</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="nf">isLongTermCustomer</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">query</span><span class="o">,</span> <span class="n">builder</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
      <span class="nc">LocalDate</span> <span class="n">date</span> <span class="o">=</span> <span class="nc">LocalDate</span><span class="o">.</span><span class="na">now</span><span class="o">().</span><span class="na">minusYears</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">builder</span><span class="o">.</span><span class="na">lessThan</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">Customer_</span><span class="o">.</span><span class="na">createdAt</span><span class="o">),</span> <span class="n">date</span><span class="o">);</span>
    <span class="o">};</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="nf">hasSalesOfMoreThan</span><span class="o">(</span><span class="nc">MonetaryAmount</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">query</span><span class="o">,</span> <span class="n">builder</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
      <span class="c1">// build query here</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="54-리포지터리dao에서-스펙-사용하기">5.4 리포지터리/DAO에서 스펙 사용하기</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="n">customers</span> <span class="o">=</span> <span class="n">customerRepository</span><span class="o">.</span><span class="na">findAll</span><span class="o">(</span><span class="n">isLongTermCustomer</span><span class="o">());</span>
</code></pre></div></div>

<h2 id="55-스펙-조합">5.5 스펙 조합</h2>
<p>스펙 인터페이스는 <code class="language-plaintext highlighter-rouge">and</code>와 <code class="language-plaintext highlighter-rouge">or</code> 등 조합 메서드를 제공한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">MonetaryAmount</span> <span class="n">amount</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MonetaryAmount</span><span class="o">(</span><span class="mf">200.0</span><span class="o">,</span> <span class="nc">Currencies</span><span class="o">.</span><span class="na">DOLLAR</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="n">customers</span> <span class="o">=</span> <span class="n">customerRepository</span><span class="o">.</span><span class="na">findAll</span><span class="o">(</span>
  <span class="n">isLongTermCustomer</span><span class="o">().</span><span class="na">or</span><span class="o">(</span><span class="n">hasSalesOfMoreThan</span><span class="o">(</span><span class="n">amount</span><span class="o">)));</span>
</code></pre></div></div>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">null</code> 가능성이 있는 스펙 객체의 조합은 <code class="language-plaintext highlighter-rouge">where</code>를 사용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">Customer</span><span class="o">&gt;</span> <span class="n">spec</span> <span class="o">=</span> <span class="nc">Specification</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">createNullableSpec</span><span class="o">()).</span><span class="na">and</span><span class="o">(</span><span class="n">createOtherSpec</span><span class="o">());</span>
</code></pre></div></div>

<h2 id="56-정렬-지정하기">5.6 정렬 지정하기</h2>
<p>스프링 데이터 JPA는 두 가지 방법을 사용해서 정렬을 지정할 수 있다.</p>
<ul>
  <li>메서드 이름에 OrderBy를 사용해서 정렬 기준 지정</li>
  <li>Sort를 인자로 전달</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderSummaryDao</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="c1">// OrderBy</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="nf">findByOrdererIdOrderByNumberDesc</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">);</span>

    <span class="c1">// Sort</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="nf">findByOrdererId</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">,</span> <span class="nc">Sort</span> <span class="n">sort</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Sort</span> <span class="n">sort</span> <span class="o">=</span> <span class="nc">Sort</span><span class="o">.</span><span class="na">by</span><span class="o">(</span><span class="nc">Sort</span><span class="o">.</span><span class="na">Direction</span><span class="o">.</span><span class="na">DESC</span><span class="o">,</span> <span class="s">"number"</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">orderSummaryDao</span><span class="o">.</span><span class="na">findByOrdererId</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="n">sort</span><span class="o">);</span>
</code></pre></div></div>

<h2 id="57-페이징-처리하기">5.7 페이징 처리하기</h2>
<p>스프링 데이터 JPA는 페이징 처리를 위해 <code class="language-plaintext highlighter-rouge">Pageable</code> 타입을 이용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberDataDao</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="nf">findByNameLike</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">);</span>
    <span class="nc">Page</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="nf">findByBlocked</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">blocked</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1은 페이지 번호, 0부터 시작한다.  10은 개수</span>
<span class="c1">// Sort 사용 가능</span>
<span class="nc">Sort</span> <span class="n">sort</span> <span class="o">=</span> <span class="nc">Sort</span><span class="o">.</span><span class="na">by</span><span class="o">(</span><span class="nc">Sort</span><span class="o">.</span><span class="na">Direction</span><span class="o">.</span><span class="na">DESC</span><span class="o">,</span> <span class="s">"name"</span><span class="o">);</span>
<span class="nc">PageRequest</span> <span class="n">pageReq</span> <span class="o">=</span> <span class="nc">PageRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="n">sort</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">memberDataDao</span><span class="o">.</span><span class="na">findByNameLike</span><span class="o">(</span><span class="s">"이름%"</span><span class="o">,</span> <span class="n">pageReq</span><span class="o">);</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>Page 리턴 타입</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PageRequest</span> <span class="n">pageReq</span> <span class="o">=</span> <span class="nc">PageRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
<span class="nc">Page</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">page</span> <span class="o">=</span> <span class="n">memberDataDao</span><span class="o">.</span><span class="na">findByBlocked</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">pageReq</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">content</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getContent</span><span class="o">();</span> <span class="c1">// 조회 결과 목록</span>
<span class="kt">long</span> <span class="n">totalElements</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getTotalElements</span><span class="o">();</span> <span class="c1">// 조건에 해당하는 전체 개수</span>
<span class="kt">int</span> <span class="n">totalPages</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getTotalPages</span><span class="o">();</span> <span class="c1">// 전체 페이지 번호</span>
<span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getNumber</span><span class="o">();</span> <span class="c1">// 현재 페이지 번호</span>
<span class="kt">int</span> <span class="n">numberOfElements</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getNumberOfElements</span><span class="o">()</span> <span class="c1">// 조회 결과 개수</span>
<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getSize</span><span class="o">();</span> <span class="c1">// 페이지 크기</span>
</code></pre></div></div>

<p>Page 리턴 타입은 COUNT 쿼리를 실행하므로 List만 필요한 경우 리턴 타입을 List로 한다.</p>

<h2 id="58-스펙-조합을-위한-스펙-빌더-클래스">5.8 스펙 조합을 위한 스펙 빌더 클래스</h2>
<p>스펙을 조합할 때 스펙 빌더를 만들어 사용할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">spec</span> <span class="o">=</span> <span class="nc">SpecBuilder</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="nc">MemberData</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                <span class="o">.</span><span class="na">ifTrue</span><span class="o">(</span><span class="n">searchRequest</span><span class="o">.</span><span class="na">isOnlyNotBlocked</span><span class="o">(),</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">MemberDataSpecs</span><span class="o">.</span><span class="na">nonBlocked</span><span class="o">())</span>
                <span class="o">.</span><span class="na">ifHasText</span><span class="o">(</span><span class="n">searchRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">name</span> <span class="o">-&gt;</span> <span class="nc">MemberDataSpecs</span><span class="o">.</span><span class="na">nameLike</span><span class="o">(</span><span class="n">searchRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">toSpec</span><span class="o">();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">memberDataDao</span><span class="o">.</span><span class="na">findAll</span><span class="o">(</span><span class="n">spec</span><span class="o">,</span> <span class="nc">PageRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpecBuilder</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">builder</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">specs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="kd">public</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">and</span><span class="o">(</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">spec</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">specs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">spec</span><span class="o">);</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">ifHasText</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">,</span>
                                    <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">specSupplier</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasText</span><span class="o">(</span><span class="n">str</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">specs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">specSupplier</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">str</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">ifTrue</span><span class="o">(</span><span class="nc">Boolean</span> <span class="n">cond</span><span class="o">,</span>
                                 <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">specSupplier</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cond</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cond</span><span class="o">.</span><span class="na">booleanValue</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">specs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">specSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">toSpec</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">spec</span> <span class="o">=</span> <span class="nc">Specification</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">:</span> <span class="n">specs</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">spec</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="59-동적-인스턴스-생성">5.9 동적 인스턴스 생성</h2>
<p>JPQL의 new 키워드를 통해 객체를 동적으로 생성할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderSummaryDao</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="nd">@Query</span><span class="o">(</span><span class="s">"""    
            select new com.myshop.order.query.dto.OrderView(
                o.number, o.state, m.name, m.id, p.name
            )
            from Order o join o.orderLines ol, Member m, Product p
            where o.orderer.memberId.id = :ordererId
            and o.orderer.memberId.id = m.id
            and index(ol) = 0
            and ol.productId.id = p.id
            order by o.number.number desc
            """</span><span class="o">)</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderView</span><span class="o">&gt;</span> <span class="nf">findOrderView</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="510-하이버네이트-subselect-사용">5.10 하이버네이트 @Subselect 사용</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">@Subselect</code>는 쿼리 결과를 <code class="language-plaintext highlighter-rouge">@Entity</code>로 매핑할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">@Immutable</code>, <code class="language-plaintext highlighter-rouge">@Subselect</code>, <code class="language-plaintext highlighter-rouge">@Synchronize</code> 와 같이 사용한다.</li>
  <li>뷰를 수정할 수 없듯 <code class="language-plaintext highlighter-rouge">@Subselect</code>로 조회한 <code class="language-plaintext highlighter-rouge">@Entity</code> 역시 수정할 수 없다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="nd">@Immutable</span>
<span class="nd">@Subselect</span><span class="o">(</span>
        <span class="s">"""
        select o.order_number as number,
        o.version,
        o.orderer_id,
        o.orderer_name,
        o.total_amounts,
        o.receiver_name,
        o.state,
        o.order_date,
        p.product_id,
        p.name as product_name
        from purchase_order o inner join order_line ol
            on o.order_number = ol.order_number
            cross join product p
        where
        ol.line_idx = 0
        and ol.product_id = p.product_id"""</span>
<span class="o">)</span>
<span class="nd">@Synchronize</span><span class="o">({</span><span class="s">"purchase_order"</span><span class="o">,</span> <span class="s">"order_line"</span><span class="o">,</span> <span class="s">"product"</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderSummary</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">number</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">version</span><span class="o">;</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"orderer_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">ordererId</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="kd">protected</span> <span class="nf">OrderSummary</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br /></p>

<h1 id="6-응용-서비스와-표현-영역">6. 응용 서비스와 표현 영역</h1>

<h2 id="61-표현-영역과-응용-영역">6.1 표현 영역과 응용 영역</h2>
<center><img src="/assets/images/posts/books/1/6_1_표현영역과응용영역.png" alt="표현영역과응용영역.png" width="80%" height="80%" /></center>

<p><strong>표현 영역</strong></p>
<ul>
  <li>표현 영역은 사용자의 요청을 해석한다.</li>
  <li>사용자가 실행하고 싶은 기능을 판별하고 그 기능을 제공하는 응용 서비스를 실행한다.</li>
  <li>응용 서비스가 요구하는 형식으로 사용자 요청을 변환한다.</li>
  <li>응용 서비스의 실행 결과를 사용자에게 알맞은 형식으로 응답한다.</li>
</ul>

<p><strong>응용 영역</strong></p>
<ul>
  <li>실제 사용자가 원하는 기능을 제공한다.</li>
  <li>응용 서비스는 표현 영역에 의존하지 않는다.</li>
</ul>

<h2 id="62-응용-서비스의-역할">6.2 응용 서비스의 역할</h2>
<ul>
  <li>사용자(표현 영역)가 요청한 기능을 실행한다.</li>
  <li>도메인 객체를 사용해서 요청을 처리한다.</li>
  <li>도메인 객체 간의 흐름을 제어한다.</li>
  <li>트랜잭션 처리를 담당한다.</li>
  <li>접근 제어와 이벤트 처리를 한다.</li>
</ul>

<h3 id="621-도메인-로직-넣지-않기">6.2.1 도메인 로직 넣지 않기</h3>
<p>도메인 로직은 도메인 영역에 위치하고, 응용 서비스는 도메인 로직을 구현하지 않는다.</p>

<p><strong>이유</strong></p>
<ul>
  <li>코드의 응집성이 떨어진다.</li>
  <li>여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다.</li>
  <li>결과적으로 코드 변경을 어렵게 만든다.</li>
</ul>

<h2 id="63-응용-서비스의-구현">6.3 응용 서비스의 구현</h2>
<p>응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 한다.(파사드 facade)</p>

<h3 id="631-응용-서비스의-크기">6.3.1 응용 서비스의 크기</h3>
<p>응용 서비스의 구현 방법은 크게 두 가지가 있다.</p>
<ul>
  <li>한 응용 서비스 클래스에 회원 도메인 모든 기능 구현하기</li>
  <li><strong>구분되는 기능별로 응용 서비스 클래스를 따로 구현하기</strong>(추천) 👍</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 각 응용 서비스에서 공통되는 로직을 별도 클래스로 구현</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">MemberServiceHelper</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Member</span> <span class="nf">findExistingMember</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">repo</span><span class="o">,</span> <span class="nc">String</span> <span class="n">memberId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">memberId</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">member</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoMemberException</span><span class="o">(</span><span class="n">memberId</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">member</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 공통 로직을 제공하는 메서드를 응용 서비스에서 사용</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">com</span><span class="o">.</span><span class="na">myshop</span><span class="o">.</span><span class="na">member</span><span class="o">.</span><span class="na">application</span><span class="o">.</span><span class="na">MemberServiceHelper</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChangePasswordService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changePassword</span><span class="o">(</span><span class="nc">String</span> <span class="n">memberId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">curPw</span><span class="o">,</span> <span class="nc">String</span> <span class="n">newPw</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">findExistingMember</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">,</span> <span class="n">memberId</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">changePassword</span><span class="o">(</span><span class="n">curPw</span><span class="o">,</span> <span class="n">newPw</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="632-응용-서비스의-인터페이스와-클래스">6.3.2 응용 서비스의 인터페이스와 클래스</h3>
<p>인터페이스가 명확하게 필요하지 않다면 응용 서비스의 인터페이스 작성은 좋은 선택이 아니다. 소스 파일만 많아지고 간접 참조가 증가해서 전체 구조가 복잡해진다.</p>

<p><strong>인터페이스가 필요한 상황</strong></p>
<ul>
  <li>구현 클래스가 여러개인 경우</li>
</ul>

<h3 id="633-메서드-파라미터와-값-리턴">6.3.3 메서드 파라미터와 값 리턴</h3>
<ul>
  <li>도메인을 이용해 기능을 실행하는 데 필요한 값을 파라미터로 전달받아야 한다.</li>
  <li>각 값을 개별 파라미터로 전달받을 수도 있고 <strong>DTO를 만들어 전달</strong>받을 수도 있다.</li>
  <li>응용 서비스의 결과를 표현 영역에서 사용해야 한다면, 응용 서비스의 결과로 필요한 데이터를 리턴한다.</li>
  <li><strong>애그리거트 자체를 리턴하는 것은 응집도를 낮추어 비추천</strong>한다.</li>
</ul>

<h3 id="634-표현-영역에-의존하지-않기">6.3.4 표현 영역에 의존하지 않기</h3>
<p>표현 영역에 해당하는 HttpServletRequest, HttpSession 등을 응용 서비스에에 파라미터로 전달하면 안 된다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="nc">ChangePasswordService</span> <span class="n">changePasswordService</span><span class="o">;</span>

<span class="nd">@PostMapping</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">sumbit</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 응용 서비스가 표현 영역을 의존하면 안된다.</span>
    <span class="n">changePasswordService</span><span class="o">.</span><span class="na">changePassword</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="635-트랜잭션-처리">6.3.5 트랜잭션 처리</h3>
<p>스프링과 같은 프레임워크가 제공하는 트랜잭션 관리 기능을 이용한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Transactional</span>
</code></pre></div></div>

<h2 id="64-표현-영역">6.4 표현 영역</h2>
<ul>
  <li>사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어한다.</li>
  <li>사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.</li>
  <li>사용자의 세션을 관리한다.</li>
</ul>
<center><img src="/assets/images/posts/books/1/6_2_표현영역사용자흐름.png" alt="표현영역사용자흐름" width="60%" height="60%" /></center>

<h2 id="65-값-검증">6.5 값 검증</h2>
<p>값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있다. <strong>원칙적으로는 응용 서비스에서 처리</strong>한다.</p>

<p>응용 서비스를 사용하는 표현 영역의 코드가 한 곳이면 구현의 편리함을 위해 다음과 같이 역할을 나누어 검증을 수행할 수도 있다.</p>
<ul>
  <li>표현 영역: 필수 값, 값의 형식, 범위 등을 검증한다.</li>
  <li>응용 서비스: 데이터의 존재 유무와 같은 논리적 오류를 검증한다.</li>
</ul>

<h2 id="66-권한-검사">6.6 권한 검사</h2>
<p>다음 세 곳에서 권한 검사를 수행할 수 있다.</p>
<ul>
  <li>표현 영역
    <ul>
      <li>서블릿 필터</li>
    </ul>
  </li>
  <li>응용 서비스
    <ul>
      <li>AOP</li>
    </ul>
  </li>
  <li>도메인
    <ul>
      <li>직접 로직 구현</li>
    </ul>
  </li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 스프링 시큐리티 활용</span>
<span class="nd">@PreAuthorize</span><span class="o">(</span><span class="s">"hasRole('ADMIN')"</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="67-조회-전용-기능과-응용-서비스">6.7 조회 전용 기능과 응용 서비스</h2>
<p>응용 서비스가 사용자 요청 기능을 실행하는 데 별다른 기여를 하지 못한다면 굳이 서비스를 만들지 않아도 된다.</p>

<p><img src="/assets/images/posts/books/1/6_4_응용서비스생략.png" alt="응용서비스생략" width="80%" height="80%" /></p>

<p><br />
<br />
<br /></p>

<h1 id="7-도메인-서비스">7. 도메인 서비스</h1>
<h2 id="71-여러-애그리거트가-필요한-기능">7.1 여러 애그리거트가 필요한 기능</h2>
<p>한 애그리거트에 넣기 애매한, 여러 애그리거트가 필요한 기능이라면 별도 도메인 서비스로 구현한다.</p>

<h2 id="72-도메인-서비스">7.2 도메인 서비스</h2>
<p>도메인 서비스는 도메인 영역에 위치한 도메인 로직을 표현할 때 사용한다. 주로 다음 상황에서 도메인 서비스를 사용한다.</p>
<ul>
  <li>계산 로직: 여러 애그리거트가 필요한 계산로직이나, 한 애그리거트에 넣기에는 다소 복잡한 계산 로직</li>
  <li>외부 시스템 연동이 필요한 도메인 로직: 구현하기 위해 타 시스템을 사용해야 하는 도메인 로직</li>
</ul>

<h3 id="721-계산-로직과-도메인-서비스">7.2.1 계산 로직과 도메인 서비스</h3>

<p><strong>도메인 서비스를 사용하는 주체</strong></p>
<ul>
  <li>애그리거트</li>
  <li>응용 서비스</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 애그리거트가 사용</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>
    <span class="c1">// 도메인 서비스</span>
    <span class="kd">private</span> <span class="nc">DiscountCalculationService</span> <span class="n">discountCalculationService</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Order</span> <span class="nf">createOrder</span><span class="o">(</span><span class="nc">OrderNo</span> <span class="n">orderNo</span><span class="o">,</span> <span class="nc">OrderRequest</span> <span class="n">orderReq</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">findMember</span><span class="o">(</span><span class="n">orderReq</span><span class="o">.</span><span class="na">getOrdererId</span><span class="o">());</span>
        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">(</span><span class="n">orderNo</span><span class="o">,</span> <span class="o">...</span><span class="na">생략</span><span class="o">);</span>
        <span class="c1">// 애그리거트 객체에 도메인 서비스 전달</span>
        <span class="n">order</span><span class="o">.</span><span class="na">calculateAmounts</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">discountCalculationService</span><span class="o">,</span> <span class="n">member</span><span class="o">.</span><span class="na">getGrade</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 응용 서비스가 사용</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TransferService</span> <span class="o">{</span> <span class="c1">// 도메인 서비스</span>

    <span class="c1">// 도메인 서비스의 기능을 실행할 때 애그리거트를 전달</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">transfer</span><span class="o">(</span><span class="nc">Account</span> <span class="n">fromAcc</span><span class="o">,</span> <span class="nc">Account</span> <span class="n">toAcc</span><span class="o">,</span> <span class="nc">Money</span> <span class="n">amounts</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">fromAcc</span><span class="o">.</span><span class="na">withdraw</span><span class="o">(</span><span class="n">amounts</span><span class="o">);</span>
        <span class="n">toAcc</span><span class="o">.</span><span class="na">credit</span><span class="o">(</span><span class="n">amounts</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br /></p>

<p><strong>특정 기능이 응용 서비스인지 도메인 서비스인지 확인하는 방법</strong></p>

<p>아래의 행위가 일어나면 도메인 서비스</p>
<ul>
  <li>애그리거트의 상태를 변경</li>
  <li>애그리거트의 상태 값을 계산</li>
</ul>

<h3 id="722-외부-시스템-연동과-도메인-서비스">7.2.2 외부 시스템 연동과 도메인 서비스</h3>
<p>시스템 간 연동은 HTTP API 호출로 이루어질 수 있지만, 도메인 입장에서는 도메인 로직으로 볼 수 있다. <strong>도메인 관점에서 인터페이스를 작성</strong>한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 도메인 서비스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">SurveyPermissionChecker</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">hasUserCreationPermission</span><span class="o">(</span><span class="nc">String</span> <span class="n">userId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//응용 서비스는 도메인 서비스를 이용</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CreateSurveyService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">SurveyPermissionChecker</span> <span class="n">surveyPermissionChecker</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">createSurvey</span><span class="o">(</span><span class="nc">CreateSurveyRequest</span> <span class="n">req</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">validate</span><span class="o">(</span><span class="n">req</span><span class="o">);</span>

        <span class="c1">// 도메인 서비스를 이용해서 외부 시스템 연동을 표현</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">surveyPermissionChecker</span><span class="o">.</span><span class="na">hasUserCreationPermission</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getRequestorId</span><span class="o">()))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoPermissionException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">SurveyPermissionChecker</code> 인터페이스를 구현한 클래스는 인프라스트럭처 영역에 위치한다.</p>

<h3 id="723-도메인-서비스의-패키지-위치">7.2.3 도메인 서비스의 패키지 위치</h3>
<center><img src="/assets/images/posts/books/1/7_2_도메인서비스위치.png" alt="도메인서비스위치" width="80%" height="80%" /></center>

<p><br /></p>

<p>도메인 서비스의 개수가 많거나 명시적으로 구분하고 싶다면 아래와 같이 하위 패키지로 구분한다.</p>
<ul>
  <li>domain
    <ul>
      <li>domain.model</li>
      <li>domain.service</li>
      <li>domain.repository</li>
    </ul>
  </li>
</ul>

<h3 id="724-도메인-서비스의-인터페이스와-클래스">7.2.4 도메인 서비스의 인터페이스와 클래스</h3>
<p>도메인 서비스의 로직이 고정되어 있지 않은 경우 <strong>도메인 서비스 자체를 인터페이스로 구현</strong>하고 이를 구현한 클래스를 둘 수도 있다.</p>

<center><img src="/assets/images/posts/books/1/7_2_도메인서비스인터페이스.png" alt="도메인서비스인터페이스" width="80%" height="80%" /></center>

<p><br />
<br />
<br /></p>

<h1 id="8-애그리거트-트랜잭션-관리">8. 애그리거트 트랜잭션 관리</h1>

<h2 id="81-애그리거트와-트랜잭션">8.1 애그리거트와 트랜잭션</h2>
<center><img src="/assets/images/posts/books/1/8_1_트랜잭션.png" alt="트랜잭션" width="60%" height="60%" /></center>

<p>트랜잭션 처리 방식</p>
<ul>
  <li>선점 잠금 (Pessimistic Lock, 비관적 잠금)</li>
  <li>비선점 잠금 (Optimistic Lock, 낙관적 잠금)</li>
</ul>

<h2 id="82-선점-잠금">8.2 선점 잠금</h2>
<center><img src="/assets/images/posts/books/1/8_2_선점잠금.png" alt="선점잠금" width="60%" height="60%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JPA</span>
<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">orderNo</span><span class="o">,</span> <span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">);</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 스프링 데이터 JPA</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberREpository</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">MemberId</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Lock</span><span class="o">(</span><span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">)</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">MemberId</span> <span class="n">memberId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="821-선점-잠금과-교착-상태">8.2.1 선점 잠금과 교착 상태</h3>
<p>다음 상황은 교착 상태에 빠진다.</p>
<ol>
  <li>스레드 1: 🐳 애그리거트에 대한 선점 잠금 구함</li>
  <li>스레드 2: 🦍 애그리거트에 대한 선점 잠금 구함</li>
  <li>스레드 1: 🦍 애그리거트에 대한 선점 잠금 시도</li>
  <li>스레드 2: 🐳 애그리거트에 대한 선점 잠금 시도</li>
</ol>

<p><br /></p>

<p><strong>해결 방법</strong><br />
힌트를 제공해 최대 대기시간을 지정한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JPA</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">hints</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">hints</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"javax.persistence.lock.timeout"</span><span class="o">,</span> <span class="mi">2000</span><span class="o">);</span>
<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">orderNo</span><span class="o">,</span> <span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">,</span> <span class="n">hints</span><span class="o">);</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 스프링 데이터 JPA</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberREpository</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">MemberId</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Lock</span><span class="o">(</span><span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">)</span>
    <span class="nd">@QueryHints</span><span class="o">({</span>
        <span class="nd">@QueryHint</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"javax.persistence.lock.timeout"</span><span class="o">,</span> <span class="n">value</span> <span class="o">=</span> <span class="s">"2000"</span><span class="o">)</span>
    <span class="o">})</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">MemberId</span> <span class="n">memberId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<p>DBMS에 따라 교착 상태에 빠진 커넥션을 처리하는 방식이 다르다. 사용하는 DBMS에 대해 JPA가 어떤 식으로 대기시간을 처리하는지 반드시 확인해야 한다.</p>

<h2 id="83-비선점-잠금">8.3 비선점 잠금</h2>
<p>선점 잠금으로 모든 트랜잭션 충돌 문제가 해결되는 것은 아니다</p>
<center><img src="/assets/images/posts/books/1/8_3_비선점잠금.png" alt="비선점잠금" width="60%" height="60%" /></center>

<p>비선점 잠금은 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식이다.</p>

<p>비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야 한다. 애그리거트를 수정할 때마다 버전으로 사용할 프로퍼티 값이 1씩 증가한다.</p>

<center><img src="/assets/images/posts/books/1/8_3_비선점잠금트랜잭션.png" alt="비선점잠금트랜잭션" width="60%" height="60%" /></center>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JPA</span>
<span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"purchase_order"</span><span class="o">)</span>
<span class="nd">@Access</span><span class="o">(</span><span class="nc">AccessType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="nd">@Version</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">version</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<p>JPA 엔티티가 변경되어 UPDATE 쿼리를 실행할 때 <code class="language-plaintext highlighter-rouge">@Version</code>에 명시한 필드를 이용해서 비선점 잠금 쿼리를 실행한다. 응용 서비스는 버전에 대해 알 필요가 없다.</p>

<p>트랜잭션 충돌이 발생하면 <code class="language-plaintext highlighter-rouge">OptimisticLockingFailureException</code>이 발생한다.</p>

<p><br /></p>

<p><strong>비선점 잠금 확장</strong></p>
<center><img src="/assets/images/posts/books/1/8_3_비선점잠금트랜잭션확장.png" alt="비선점잠금트랜잭션확장" width="60%" height="60%" /></center>

<p><br /></p>

<p>비선점 잠금 방식을 여러 트랜잭션으로 확장하려면 애그리거트 버전 정보를 응용 서비스에 전달한다. 응용 서비스는 전달받은 버전 값을 이용해서 애그리거트 버전과 일치하는지 확인하고, 일치하는 경우에만 기능을 수행한다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StartShippingRequest</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">orderNumber</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">version</span><span class="o">;</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 응용 서비스</span>
<span class="kd">public</span> <span class="nc">StartShippingService</span> <span class="o">{</span>

    <span class="nd">@PreAuthorize</span><span class="o">(</span><span class="s">"hasRole('ADMIN')"</span><span class="o">)</span>
    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startShipping</span><span class="o">(</span><span class="nc">StartShippingRequest</span> <span class="n">req</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="k">new</span> <span class="nc">OrderNo</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">()));</span>
        <span class="c1">// version 확인</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">order</span><span class="o">.</span><span class="na">matchVersion</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getVersion</span><span class="o">()))</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">VersionConflictException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="831-강제-버전-증가">8.3.1 강제 버전 증가</h3>
<p>기능 실행 도중 루트가 아닌 다른 엔티티의 값만 변경된다면, JPA는 루트 엔티티 버전 값을 증가시키지 않는다.</p>

<p>JPA는 이런 문제를 처리할 수 있도록 EntityManager#find() 메서드로 엔티티를 구할 때 강제로 버전 값을 증가시키는 잠금 모드를 지원한다. <code class="language-plaintext highlighter-rouge">LockModeType.OPTIMISTIC_FORCE_INCREMENT</code>를 사용하면 해당 엔티티의 상태가 변경되었는지에 상관없이 트랜잭션 종료 시점에 버전 값 증가 처리를 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JPA</span>
<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">orderNo</span><span class="o">,</span> <span class="nc">LockModeType</span><span class="o">.</span><span class="na">OPTIMISTIC_FORCE_INCREMENT</span><span class="o">);</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 스프링 데이터 JPA</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberREpository</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">MemberId</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Lock</span><span class="o">(</span><span class="nc">LockModeType</span><span class="o">.</span><span class="na">OPTIMISTIC_FORCE_INCREMENT</span><span class="o">)</span>
    <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findById</span><span class="o">(</span><span class="nc">MemberId</span> <span class="n">memberId</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="84-오프라인-선점-잠금">8.4 오프라인 선점 잠금</h2>
<p>누군가 수정 화면을 보고 있을 때 수정 화면 자체를 실행하지 못하게 하는 것이 오프라인 선점 잠금 방식이다.</p>
<center><img src="/assets/images/posts/books/1/8_4_오프라인선점잠금방식.png" alt="오프라인선점잠금방식" width="60%" height="60%" /></center>

<h3 id="841-오프라인-선점-잠금을-위한-lockmanager-인터페이스와-관련-클래스">8.4.1 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스</h3>
<p>필요 기능</p>
<ul>
  <li>잠금 선점 시도</li>
  <li>잠금 확인</li>
  <li>잠금 해제</li>
  <li>잠금 유효시간</li>
</ul>

<p>구현 코드는 <a href="https://product.kyobobook.co.kr/detail/S000001810495" target="_blank">책</a>에서 확인해주세요. 🔎</p>

<h3 id="842-db를-이용한-lockmanager-구현">8.4.2 DB를 이용한 LockManager 구현</h3>
<p>구현 코드는 <a href="https://product.kyobobook.co.kr/detail/S000001810495" target="_blank">책</a>에서 확인해주세요. 🔎</p>

<p><br />
<br />
<br /></p>

<h1 id="9-도메인-모델과-바운디드-컨텍스트">9. 도메인 모델과 바운디드 컨텍스트</h1>
<h2 id="91-도메인-모델과-경계">9.1 도메인 모델과 경계</h2>
<p>논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다.</p>
<center><img src="/assets/images/posts/books/1/9_1_하위도메인별용어.png" alt="하위도메인별용어" width="80%" height="80%" /></center>

<p>이렇게 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다.</p>

<p><strong>모델은 특정한 컨텍스트(문맥) 하에서 완전한 의미를 갖는다</strong>. 같은 제품이라도 카탈로그 컨텍스트와 재고 컨텍스트에서 의미가 서로 다르다. 이렇게 <strong>구분되는 경계를 갖는 컨텍스트를 DDD에서는 바운디드 컨텍스트(Bounded Context)라고 부른다</strong>.</p>

<h2 id="92-바운디드-컨텍스트">9.2 바운디드 컨텍스트</h2>
<ul>
  <li>도메인 모델의 경계를 결정한다.</li>
  <li>용어를 기준으로 구분한다.</li>
  <li>한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.</li>
  <li>한 개의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도, 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 한다.</li>
</ul>

<p><br /></p>

<p><strong>아직 명확하게 구분되지 않은 경우 두 하위 도메인을 하나의 바운디드 컨텍스트에서 구현하기도 한다.</strong><br />
<img src="/assets/images/posts/books/1/9_2_바운디드컨텍스트.png" alt="바운디드컨텍스트" width="70%" height="70%" /></p>

<p><br /></p>

<p><strong>한 개의 바운디드 컨텍스트가 여러 하위 도메인을 포함하더라도, 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 한다.</strong><br />
<img src="/assets/images/posts/books/1/9_2_바운디드컨텍스트2.png" alt="바운디드컨텍스트" width="70%" height="70%" /></p>

<p><br /></p>

<p><strong>같은 상품이라도 각자 구현하는 하위 도메인에 맞는 모델을 갖는다.</strong><br />
<img src="/assets/images/posts/books/1/9_2_바운디드컨텍스트3.png" alt="바운디드컨텍스트" width="70%" height="70%" /></p>

<h2 id="93-바운디드-컨텍스트-구현">9.3 바운디드 컨텍스트 구현</h2>
<p>바운디드 컨텍스트는 도메인 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, 인프라스트럭처, 테이블 영역을 포함한다.</p>
<center><img src="/assets/images/posts/books/1/9_3_바운디드컨텍스트영역.png" alt="바운디드컨텍스트영역" width="70%" height="70%" /></center>

<p><br />
<br /></p>

<p>CQRS (Command Query Responsibility Segregation, 명령 조회 책임 분리) 패턴을 사용할 수도 있다.</p>
<center><img src="/assets/images/posts/books/1/9_3_바운디드컨텍스트CQRS.png" alt="바운디드컨텍스트CQRS" width="60%" height="60%" /></center>

<p><br />
<br /></p>

<p>바운디드 컨텍스트는 UI를 갖지 않을 수도 있다.</p>
<center><img src="/assets/images/posts/books/1/9_3_바운디드컨텍스트UI미포함.png" alt="바운디드컨텍스트UI미포함" width="60%" height="60%" /></center>

<p><br />
<br /></p>

<p>바운디드 컨텍스트는 UI서버를 통해 간접적으로 브라우저와 통신할 수도 있다. 여기서 UI서버는 파사드 역할을 수행한다.</p>
<center><img src="/assets/images/posts/books/1/9_3_바운디드컨텍스트UI서버.png" alt="바운디드컨텍스트UI서버" width="60%" height="60%" /></center>

<h2 id="94-바운디드-컨텍스트-간-통합">9.4 바운디드 컨텍스트 간 통합</h2>
<p>바운디드 컨텍스트 간 통합이 필요할 때도 있다.</p>

<p><strong>REST API를 이용한 직접 통합</strong></p>
<ul>
  <li>통신</li>
</ul>

<p><img src="/assets/images/posts/books/1/9_4_바운디드컨텍스트간통합.png" alt="바운디드컨텍스트간통합" width="80%" height="80%" /></p>

<p><br /></p>

<ul>
  <li>도메인에 맞는 모델로 변환</li>
</ul>

<p><img src="/assets/images/posts/books/1/9_4_바운디드컨텍스트간통합2.png" alt="바운디드컨텍스트간통합" width="80%" height="80%" /></p>

<p><br />
<br /></p>

<p><strong>메시지 큐를 사용하여 통합</strong>
<img src="/assets/images/posts/books/1/9_4_바운디드컨텍스트간통합3.png" alt="바운디드컨텍스트간통합" width="80%" height="80%" /></p>

<p><img src="/assets/images/posts/books/1/9_4_바운디드컨텍스트간통합4.png" alt="바운디드컨텍스트간통합" width="80%" height="80%" /></p>

<p><br />
<br /></p>

<p><strong>마이크로서비스와 바운디드 컨텍스트</strong><br />
마이크로서비스는 애플리케이션을 작은 서비스로 나누어 개발하는 아키텍처 스타일이다. 개별 서비스를 독립된 프로세스로 실행하고 각 서비스가 REST API나 메시징을 이용해서 통신하는 구조를 갖는다.</p>

<p>바운디드 컨텍스트를 마이크로서비스로 구현하면 자연스럽게 컨텍스트별로 모델이 분리된다. 마이크로서비스마다 프로젝트를 생성하므로 <strong>바운디드 컨텍스트마다 프로젝트를 만들게 된다</strong>. 이것은 코드 수준에서 모델을 분리하여 두 바운디드 컨텍스트의 모델이 섞이지 않도록 해준다.</p>

<h2 id="95-바운디드-컨텍스트-간-관계">9.5 바운디드 컨텍스트 간 관계</h2>
<p>바운디드 컨텍스트는 어떤 식으로든 연결되기 때문에 두 바운디드 컨텍스트는 다양한 방식으로 관계를 맺는다.</p>

<p><strong>REST API</strong><br />
<img src="/assets/images/posts/books/1/9_5_바운디드컨텍스트관계.png" alt="바운디드컨텍스트간통합" width="80%" height="80%" /></p>

<p><br />
<br /></p>

<p><strong>단일 API</strong><br />
<img src="/assets/images/posts/books/1/9_5_바운디드컨텍스트관계2.png" alt="바운디드컨텍스트간통합" width="80%" height="80%" /></p>

<p><br />
<br /></p>

<p><strong>독립 방식</strong><br />
그냥 서로 통합하지 않는 방식이다. 서로 독립적으로 모델을 발전 시킨다. 하지만 규모가 커질수록 한계가 있으므로 그 전에 두 바운디드 컨텍스트를 통합해야 한다.</p>

<p><img src="/assets/images/posts/books/1/9_5_바운디드컨텍스트관계3.png" alt="바운디드컨텍스트간통합" width="80%" height="80%" /></p>

<p><img src="/assets/images/posts/books/1/9_5_바운디드컨텍스트관계4.png" alt="바운디드컨텍스트간통합" width="80%" height="80%" /></p>

<h2 id="96-컨텍스트-맵">9.6 컨텍스트 맵</h2>
<p>개별 바운디드 컨텍스트에 매몰되면 전체를 보지 못할 때가 있다. 전체 바운디드 컨텍스트 간 관계를 볼 수 있는 지도가 필요한데 그것이 바로 컨텍스트 맵이다.</p>

<p><img src="/assets/images/posts/books/1/9_6_컨텍스트맵.png" alt="컨텍스트맵" width="80%" height="80%" /></p>

<p><br />
<br />
<br /></p>

<h1 id="10-이벤트">10. 이벤트</h1>
<h2 id="101-시스템-간-강결합-문제">10.1 시스템 간 강결합 문제</h2>
<ul>
  <li>트렌젝션 문제</li>
  <li>외부 서비스의 성능에 영향을 받음</li>
  <li>설계상 문제 (로직이 섞임)</li>
  <li>기능 추가의 어려움</li>
</ul>

<h2 id="102-이벤트-개요">10.2 이벤트 개요</h2>
<p>여기서 사용되는 이벤트라는 용어는 ‘과거에 벌어진 어떤 것’을 의미한다.</p>
<ul>
  <li>이벤트 발생</li>
  <li>이벤트에 반응하여 동작 수행</li>
</ul>

<h3 id="1021-이벤트-관련-구성요소">10.2.1 이벤트 관련 구성요소</h3>
<ul>
  <li>이벤트</li>
  <li>이벤트 생성 주체</li>
  <li>이벤트 디스패처 (퍼블리셔)</li>
  <li>이벤트 핸들러 (구독자)</li>
</ul>

<p><img src="/assets/images/posts/books/1/10_2_이벤트구성요소.png" alt="이벤트구성요소" width="80%" height="80%" /></p>

<p>도메인 모델에서 이벤트 생성 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다. 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다.</p>

<h3 id="1022-이벤트의-구성">10.2.2 이벤트의 구성</h3>
<p>이벤트는 발생한 이벤트에 대한 정보를 담는다.</p>
<ul>
  <li>이벤트 종류: 클래스 이름으로 이벤트 종류를 표현</li>
  <li>이벤트 발생 시간</li>
  <li>추가 데이터: 주문번호, 시규배송지 정보 등 이벤트와 관련된 정보</li>
</ul>

<h3 id="1023-이벤트-용도">10.2.3 이벤트 용도</h3>
<ul>
  <li>후처리를 실행하기 위한 트리거</li>
  <li>서로 다른 시스템 간의 데이터 동기화</li>
</ul>

<p><img src="/assets/images/posts/books/1/10_2_이벤트용도.png" alt="이벤트용도" width="80%" height="80%" /></p>

<h3 id="1024-이벤트-장점">10.2.4 이벤트 장점</h3>
<ul>
  <li>서로 다른 도메인 로직이 섞이는 것을 방지</li>
  <li>도메인 로직에 영향 없이 기능 확장</li>
</ul>

<p><img src="/assets/images/posts/books/1/10_2_이벤트장점.png" alt="이벤트장점" width="80%" height="80%" /></p>

<h2 id="103-이벤트-핸들러-디스패처-구현">10.3 이벤트, 핸들러, 디스패처 구현</h2>
<p>이벤트와 관련된 코드</p>
<ul>
  <li>이벤트 클래스: 이벤트를 표현한다.</li>
  <li>디스패처: 스프링이 제공하는 ApplicationEventPublisher를 이용한다.</li>
  <li>Events: 이벤트를 발행한다. 이벤트 발행을 위해 ApplicationEventPublisher를 사용한다.</li>
  <li>이벤트 핸들러: 이벤트를 수신해서 처리한다. 스프링이 제공하는 기능을 사용한다.</li>
</ul>

<h3 id="1031-이벤트-클래스">10.3.1 이벤트 클래스</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 공통 추상 클래스</span>
<span class="kn">package</span> <span class="nn">com.myshop.common.event</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Event</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Event</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">timestamp</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCanceledEvent</span> <span class="kd">extends</span> <span class="nc">Event</span> <span class="o">{</span>

    <span class="c1">// 이벤트는 핸들러에서 이벤트를 처리하는 데 필요한 데이터를 포함</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">orderNumber</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">OrderCanceledEvent</span><span class="o">(</span><span class="nc">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">orderNumber</span> <span class="o">=</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="1032-events-클래스와-applicationeventpublisher">10.3.2 Events 클래스와 ApplicationEventPublisher</h3>
<p>이벤트 발생과 출판을 위해 스프링이 제공하는 <code class="language-plaintext highlighter-rouge">ApplicationEventPublisher</code>를 사용한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 설정</span>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventsConfiguration</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">;</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">InitializingBean</span> <span class="nf">eventsInitializer</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Events</span><span class="o">.</span><span class="na">setPublisher</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Events는 ApplicationEventPublisher를 사용해서 이벤트를 발생</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Events</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">ApplicationEventPublisher</span> <span class="n">publisher</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setPublisher</span><span class="o">(</span><span class="nc">ApplicationEventPublisher</span> <span class="n">publisher</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Events</span><span class="o">.</span><span class="na">publisher</span> <span class="o">=</span> <span class="n">publisher</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">raise</span><span class="o">(</span><span class="nc">Object</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">publisher</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">publisher</span><span class="o">.</span><span class="na">publishEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="1033-이벤트-발생과-이벤트-핸들러">10.3.3 이벤트 발생과 이벤트 핸들러</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이벤트 발생</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">...</span><span class="na">생략</span><span class="o">...</span>
        <span class="nc">Events</span><span class="o">.</span><span class="na">raise</span><span class="o">(</span><span class="k">new</span> <span class="nc">OrderCanceledEvent</span><span class="o">(</span><span class="n">number</span><span class="o">.</span><span class="na">getNumber</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 이벤트 핸들러</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCanceledEventHandler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">RefundService</span> <span class="n">refundService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">OrderCanceledEventHandler</span><span class="o">(</span><span class="nc">RefundService</span> <span class="n">refundService</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">refundService</span> <span class="o">=</span> <span class="n">refundService</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@EventListener</span><span class="o">(</span><span class="nc">OrderCanceledEvent</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">OrderCanceledEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">refundService</span><span class="o">.</span><span class="na">refund</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="1034-흐름-정리">10.3.4 흐름 정리</h3>
<p><img src="/assets/images/posts/books/1/10_3_이벤트흐름.png" alt="이벤트흐름" width="80%" height="80%" /></p>

<h2 id="104-동기-이벤트-처리-문제">10.4 동기 이벤트 처리 문제</h2>
<p>동기 이벤트 처리는 다음과 같은 문제가 발생한다.</p>
<ul>
  <li>외부 연동 과정에서 익셉션이 발생하면 트랜잭션 처리는?</li>
  <li>이벤트 처리하는 코드가 느려지거나 익셉션이 발생하면?</li>
</ul>

<h2 id="105-비동기-이벤트-처리">10.5 비동기 이벤트 처리</h2>
<p>비동기 이벤트 처리로 해결한다.</p>
<ul>
  <li>로컬 핸들러를 비동기로 실행하기</li>
  <li>메시지 큐를 사용하기</li>
  <li>이벤트 저장소와 이벤트 포워더 사용하기</li>
  <li>이벤트 저장소와 이벤트 제공 API 사용하기</li>
</ul>

<h3 id="1051-로컬-핸들러-비동기-실행">10.5.1 로컬 핸들러 비동기 실행</h3>
<p>이벤트 핸들러를 별도 스레드로 실행한다. 스프링이 제공하는 <code class="language-plaintext highlighter-rouge">@Async</code> 에너테이션을 사용하면 손쉽게 비동기로 이벤트 핸들러를 실행할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableAsync</span>  <span class="c1">// 기능 활성화</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShopApplication</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">ShopApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 핸들러</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCanceledEventHandler</span> <span class="o">{</span>

    <span class="nd">@Async</span> <span class="c1">// @Async 에너테이션 사용</span>
    <span class="nd">@EventListener</span><span class="o">(</span><span class="nc">OrderCanceledEvent</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">OrderCanceledEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">refundService</span><span class="o">.</span><span class="na">refund</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="1052-메시징-시스템을-이용한-비동기-구현">10.5.2 메시징 시스템을 이용한 비동기 구현</h3>
<p>Kafka나 RabbitMQ와 같은 메시징 시스템을 사용</p>
<ul>
  <li>RabbitMQ
    <ul>
      <li>글로벌 트랜잭션 지원</li>
    </ul>
  </li>
  <li>Kafka
    <ul>
      <li>글로벌 트랜잭션 지원 X</li>
      <li>다른 메시징 시스템에 비해 <strong>높은 성능</strong></li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/posts/books/1/10_5_이벤트메시지큐.png" alt="이벤트메시지큐" width="80%" height="80%" /></p>

<h3 id="1053-이벤트-저장소를-이용한-비동기-처리">10.5.3 이벤트 저장소를 이용한 비동기 처리</h3>
<p>이벤트를 일단 DB에 저장한 뒤에 별도 프로그램을 이용해서 이벤트 핸들러에 전달</p>

<p><img src="/assets/images/posts/books/1/10_5_이벤트저장소이용포워더.png" alt="이벤트저장소이용포워더" width="80%" height="80%" /></p>

<p><img src="/assets/images/posts/books/1/10_5_이벤트저장소이용API.png" alt="이벤트저장소이용API" width="80%" height="80%" /></p>

<p><br /></p>

<p>API방식과 포워더 방식의 차이점은 이벤트를 전달하는 방식에 있다.</p>
<ul>
  <li>포워더
    <ul>
      <li>포워더를 이용해서 이벤트를 외부에 전달.</li>
      <li>이벤트를 어디까지 처리했는지 추적하는 역할이 포워더에 있다.</li>
    </ul>
  </li>
  <li>API
    <ul>
      <li>외부 핸들러가 API 서버를 통해 이벤트 목록을 가져감.</li>
      <li>이벤트를 어디까지 처리했는지 추적하는 역할이 외부 핸들러에 있다.</li>
    </ul>
  </li>
</ul>

<p><br /></p>

<p><strong>구현 방법은 책 참고</strong><br />
…생략…😅</p>

<p><br /></p>

<p><strong>자동 증가 칼럼 주의 사항</strong><br />
트랜잭션 커밋 시점에 따른 자동 증가 칼럼 문제<br />
<a href="https://javacan.tistory.com/entry/MySQL-auto-inc-col-gotcha" target="_blank">자동 증가 칼럼 주의 사항 링크</a></p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 트랜잭션 커밋 시점에 따른 ID 값
시간 흐름 ---&gt;  
트랜잭션 1: 1, 2       5, 6
트랜잭션 2:       3, 4      7, 8
</code></pre></div></div>

<h2 id="106-이벤트-적용-시-추가-고려-사항">10.6 이벤트 적용 시 추가 고려 사항</h2>
<p>이벤트 적용 시 다음 고려사항을 생각해본다.</p>
<ul>
  <li><strong>이벤트 소스를 EventEntry에 추가할지?</strong>
    <ul>
      <li>EventEntry는 이벤트 발생 주체에 대한 정보를 갖지 않는다.</li>
      <li>특정 주체가 발생시킨 이벤트만 조회하는 기능을 구현할 수 없다.</li>
      <li>이 기능을 구현하려면 이벤트에 발생 주체 정보를 추가해야 한다.</li>
    </ul>
  </li>
  <li><strong>포워더에서 전송 실패를 얼마나 허용할지?</strong>
    <ul>
      <li>포워더는 이벤트 전송에 실패하면 실패한 이벤트부터 다시 읽어와 전송을 시도한다.</li>
      <li>특정 이벤트가 계속 실패한다면?</li>
      <li>실패한 이벤트의 재전송 횟수 제한을 두어야 한다.</li>
      <li>실패한 이벤트는 실패용 DB나 메시지 큐에 저장한다.</li>
    </ul>
  </li>
  <li><strong>이벤트 손실은?</strong>
    <ul>
      <li>이벤트 저장소를 사용하면 이벤트 발생과 이벤트 저장을 한 트랜잭션으로 처리하기 때문에 트랜잭션에 성공하면 이벤트가 저장소에 보관된다는 것을 보장할 수 있다.</li>
      <li>이벤트를 비동기로 처리할 경우 이벤트 처리에 실패하면 이벤트를 유실하게 된다.</li>
    </ul>
  </li>
  <li><strong>이벤트 순서는?</strong>
    <ul>
      <li>이벤트 발생 순서대로 외부 시스템에 전달해야 할 경우는 이벤트 저장소를 사용한다.</li>
      <li>메시징 시스템은 사용 기술에 따라 이벤트 발생 순서와 메시지 순서가 다를 수 있다.</li>
    </ul>
  </li>
  <li><strong>이벤트 재처리는?</strong>
    <ul>
      <li>이벤트의 순번을 기억한다.</li>
      <li>이벤트 멱등성으로 처리한다</li>
    </ul>
  </li>
</ul>

<p><strong>멱등성이란?</strong><br />
연산을 여러번 적용해도 결과가 달라지지 않는 성질을 멱등성이라고 한다.</p>

<h3 id="1061-이벤트-처리와-db-트랜잭션-고려">10.6.1 이벤트 처리와 DB 트랜잭션 고려</h3>
<p>이벤트 처리를 동기로 하든 비동기로 하든 이벤트 처리 실패와 <strong>트랜잭션 실패를 함께 고려</strong>해야 한다. 트랜잭션 실패와 이벤트 처리 실패 모두 고려하면 복잡해지므로 경우의 수를 줄이면 도움이 된다. 경우의 수를 줄이는 방법은 <strong>트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 것이다.</strong></p>

<p>스프링은 <code class="language-plaintext highlighter-rouge">@TransactionalEventListener</code> 에너테이션을 지원한다. 이 애너테이션은 트랜잭션 상태에 따라 이벤트 핸들러를 실행할 수 있게 한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@TransactionalEventListener</span><span class="o">(</span>
        <span class="n">classes</span> <span class="o">=</span> <span class="nc">OrderCanceledEvent</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="nc">TransactionPhase</span><span class="o">.</span><span class="na">AFTER_COMMIT</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">OrderCanceledEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">refundService</span><span class="o">.</span><span class="na">refund</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div></div>

<p><br />
<br />
<br /></p>

<h1 id="11-cqrs">11. CQRS</h1>
<h2 id="111-단일-모델의-단점">11.1 단일 모델의 단점</h2>
<p>조회 기능을 구현하려면 여러 애그리거트에서 데이터를 가져와야 할 경우가 많다. 이 때 식별자를 이용한 참조 방식이든, 직접 참조하는 방식이든 고민해야 할 것들이 많다. 이는 구현 복잡도를 높인다.</p>

<p>이런 구현 복잡도를 낮추는 간단한 방법이 바로 CQRS (Command Query Responsibility Segregation, 명령 조회 책임 분리)다.</p>

<h2 id="112-cqrs">11.2 CQRS</h2>

<p><img src="/assets/images/posts/books/1/11_2_CQRS패턴.png" alt="CQRS패턴" width="80%" height="80%" /></p>

<p><br /></p>

<p><strong>CQRS를 사용하면 각 모델에 맞는 구현 기술을 선택할 수 있다.</strong></p>

<p><img src="/assets/images/posts/books/1/11_2_CQRS_3.png" alt="CQRS" width="70%" height="70%" /></p>

<p><img src="/assets/images/posts/books/1/11_2_CQRS_2.png" alt="CQRS_2" width="70%" height="70%" /></p>

<p>단순히 데이터를 읽어와 조회하는 기능은 응용 서비스를 제외할 수도 있다.</p>

<p><br /></p>

<p><strong>CQRS를 사용하면 각 모델에 맞는 데이터 저장소를 선택할 수 있다.</strong></p>

<p><img src="/assets/images/posts/books/1/11_2_CQRS_4.png" alt="CQRS" width="70%" height="70%" /></p>

<p>명령 모델은 트랜잭션을 지원하는 RDBMS를 사용하고, 조회 모델은 조회 성능이 좋은 메모리 기반 NoSQL을 사용할 수 있다.</p>

<h3 id="1121-웹과-cqrs">11.2.1 웹과 CQRS</h3>
<p>일반적인 웹 서비스는 <strong>상태를 변경하는 요청보다 상태를 조회하는 요청이 많다</strong>. 대규모 트래픽이 발생하는 웹 서비스는 알게 모르게 CQRS를 적용하게 된다. <strong>조회 속도를 높이기 위해 별도 처리를 하고 있다면 CQRS를 적용하자</strong>. 이를 통해 <strong>조회 기능 때문에 명령 모델이 복잡해지는 것을 막을 수 있고, 명령 모델에 관계없이 조회 기능에 특화된 구현 기법을 보다 쉽게 적용할 수 있다</strong>.</p>

<h3 id="1122-cqrs-장단점">11.2.2 CQRS 장단점</h3>
<ul>
  <li>장점
    <ul>
      <li>명령 모델을 구현할 때 도메인 자체에 집중할 수 있다.</li>
      <li>조회 성능 향상에 유리</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>구현해야 할 코드가 더 많다.</li>
      <li>더 많은 구현 기술이 필요하다.</li>
    </ul>
  </li>
</ul>

<p>장단점을 고려해 CQRS 패턴 도입 여부를 결정한다. 도메인이 복잡하지 않은데 CQRS를 도입하면 유지 비용만 높아진다. 반면 트래픽이 높은 서비스인데 단일 모델을 고집하면 유지 보수 비용이 오히려 높아질 수 있으므로 CQRS 도입을 고려하자.</p>

<p><br />
<br />
<br />
<br /></p>

<p><strong>감사합니다</strong> 🙇🏻‍♂️</p>

<ul>
  <li><a href="https://product.kyobobook.co.kr/detail/S000001810495" target="_blank">도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지</a></li>
  <li><a href="https://github.com/madvirus/ddd-start2" target="_blank">예제 코드</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Books" /><category term="Books" /><category term="DDD" /><summary type="html"><![CDATA[도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지 책을 읽고 내용을 아주 간단하게 정리한 글입니다. 책에는 자세한 설명과 예제가 많으니 꼭 구입해서 읽는것을 추천합니다~👍]]></summary></entry><entry><title type="html">MAC 단축키 모음 💻</title><link href="http://localhost:4000/mac/%EB%8B%A8%EC%B6%95%ED%82%A4/" rel="alternate" type="text/html" title="MAC 단축키 모음 💻" /><published>2023-01-08T00:00:00+09:00</published><updated>2023-01-08T00:00:00+09:00</updated><id>http://localhost:4000/mac/%EB%8B%A8%EC%B6%95%ED%82%A4</id><content type="html" xml:base="http://localhost:4000/mac/%EB%8B%A8%EC%B6%95%ED%82%A4/"><![CDATA[<h2 id="-일반-단축키">⌨ 일반 단축키</h2>
<ul>
  <li>화면 잠금: <strong>Control + Command + Q</strong></li>
  <li>복제: <strong>Command + x</strong></li>
  <li>다시찾기: <strong>Command + G</strong></li>
  <li>윈도우 최소화: <strong>Command + M</strong></li>
  <li>프린트: <strong>Command + P</strong></li>
  <li>붙여넣기: <strong>Command + V</strong></li>
  <li>모두선택: <strong>Command + A</strong></li>
  <li>복사: <strong>Command + C</strong></li>
  <li>숨기기: <strong>Command + H</strong></li>
  <li>선택항목 열기: <strong>Command + O</strong></li>
  <li>문서 저장: <strong>Command + S</strong></li>
  <li>이전명령: <strong>Command + Z</strong></li>
  <li>항목찾기: <strong>Command + F</strong></li>
  <li>새 탭 열기: <strong>Command + T</strong></li>
  <li>창 닫기: <strong>Command + W</strong></li>
  <li>강제 종료: <strong>Option + Command + Esc</strong></li>
  <li>Spotlight 표시/숨기기: <strong>Command + Spacebar</strong></li>
  <li>이모티콘 및 기타 기호: <strong>Ctrl + Command + Spacebar</strong></li>
  <li>전체화면: <strong>Ctrl + Command + F</strong></li>
  <li>스크린샷 및 화면 기록: <strong>Shift + Command + 5</strong></li>
  <li>새폴더 생성: <strong>Shift + Command + N</strong></li>
  <li>환경설정 열기: <strong>Command + ,</strong></li>
  <li>최근 사용 앱으로 전환: <strong>Command + Tab</strong></li>
  <li>훑어보기: <strong>Spacebar</strong></li>
</ul>

<h2 id="-finder-및-시스템-단축키">⌨ Finder 및 시스템 단축키</h2>
<ul>
  <li>선택 파일 복제: <strong>Command + D</strong></li>
  <li>Finder 윈도우에서 Spotlight 검색 시작: <strong>Command + F</strong></li>
  <li>선택 디스크 또는 볼륨 추출: <strong>Command + E</strong></li>
  <li>선택 파일의 정보 가져오기: <strong>Command + I</strong></li>
  <li>가상본의 원본 파일이 형성: <strong>Command + R</strong></li>
  <li>컴퓨터 윈도우 열기: <strong>Shift + Command + C</strong></li>
  <li>최근 윈도우/파일 표시: <strong>Shift + Command + F</strong></li>
  <li>현재 macOS 사용자 계정 폴더 열기: <strong>Shift + Command + H</strong></li>
  <li>데스크탑 폴더 열기: <strong>Shift + Command + D</strong></li>
  <li>폴더로 이동 윈도우 열기: <strong>Shift + Command + G</strong></li>
  <li>iCloud Drive 열기: <strong>Shift + Command + I</strong></li>
  <li>네트위크 윈도우 열기: <strong>Shift + Command K</strong></li>
  <li>새 폴더 생성: <strong>Shift + Command + N</strong></li>
  <li>Finder 미리보기 패널 표시/가리기: <strong>Shift + Command + P</strong></li>
  <li>다운로드 폴더 열기: <strong>Shift + Command + L</strong></li>
  <li>문서 폴더 열기: <strong>Shift + Command + O</strong></li>
  <li>AirDrop 윈도우 열기: <strong>Shift + Command + R</strong></li>
</ul>

<h2 id="-참고-사이트">🔎 참고 사이트</h2>
<p><a href="https://www.invaiz.com/blog/?q=YToxOntzOjEyOiJrZXl3b3JkX3R5cGUiO3M6MzoiYWxsIjt9&amp;bmode=view&amp;idx=12577409&amp;t=board" target="_blank">invaiz 블로그</a></p>]]></content><author><name>Oh</name></author><category term="Mac" /><category term="Mac" /><category term="단축키" /><summary type="html"><![CDATA[⌨ 일반 단축키 화면 잠금: Control + Command + Q 복제: Command + x 다시찾기: Command + G 윈도우 최소화: Command + M 프린트: Command + P 붙여넣기: Command + V 모두선택: Command + A 복사: Command + C 숨기기: Command + H 선택항목 열기: Command + O 문서 저장: Command + S 이전명령: Command + Z 항목찾기: Command + F 새 탭 열기: Command + T 창 닫기: Command + W 강제 종료: Option + Command + Esc Spotlight 표시/숨기기: Command + Spacebar 이모티콘 및 기타 기호: Ctrl + Command + Spacebar 전체화면: Ctrl + Command + F 스크린샷 및 화면 기록: Shift + Command + 5 새폴더 생성: Shift + Command + N 환경설정 열기: Command + , 최근 사용 앱으로 전환: Command + Tab 훑어보기: Spacebar]]></summary></entry></feed>