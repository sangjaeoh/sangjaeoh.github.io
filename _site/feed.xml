<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-14T21:25:47+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Stack O Flow</title><subtitle>조금씩 알아가는 것을 적는 개발 노트입니다.</subtitle><author><name>Oh</name></author><entry><title type="html">kubectl 기본 명령어</title><link href="http://localhost:4000/kubernetes/kubectl-%EA%B8%B0%EB%B3%B8%EB%AA%85%EB%A0%B9%EC%96%B4/" rel="alternate" type="text/html" title="kubectl 기본 명령어" /><published>2023-03-14T00:00:00+09:00</published><updated>2023-03-14T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/kubectl-%EA%B8%B0%EB%B3%B8%EB%AA%85%EB%A0%B9%EC%96%B4</id><content type="html" xml:base="http://localhost:4000/kubernetes/kubectl-%EA%B8%B0%EB%B3%B8%EB%AA%85%EB%A0%B9%EC%96%B4/"><![CDATA[<p>💾 kubectl 기본명령어를 정리한 내용입니다.</p>

<p><br /></p>

<h2 id="apply">apply</h2>
<p>원하는 리소스의 상태를 YAML로 작성하고 apply 명렁어로 선언합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> <span class="o">[</span>파일명 또는 URL]
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl apply <span class="nt">-f</span> ./my-manifest.yaml        <span class="c"># 리소스(들) 생성</span>
kubectl apply <span class="nt">-f</span> ./my1.yaml <span class="nt">-f</span> ./my2.yaml  <span class="c"># 여러 파일로 부터 생성</span>
kubectl apply <span class="nt">-f</span> ./dir                     <span class="c"># dir 내 모든 매니페스트 파일에서 리소스(들) 생성 </span>
kubectl apply <span class="nt">-f</span> https://git.io/vPieo      <span class="c"># url로부터 리소스(들) 생성</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="get">get</h2>
<p>리소스 목록 보기. 출력 형태를 변경할 수 있는 <code class="language-plaintext highlighter-rouge">-o</code>와 레이블을 확인할 수 있는 <code class="language-plaintext highlighter-rouge">--show-labels</code>를 함께 사용할 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get <span class="o">[</span>TYPE]
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 출력을 위한 Get 커맨드</span>
kubectl get services                      <span class="c"># 네임스페이스 내 모든 서비스의 목록 조회</span>
kubectl get pods <span class="nt">--all-namespaces</span>         <span class="c"># 모든 네임스페이스 내 모든 파드의 목록 조회</span>
kubectl get pods <span class="nt">-o</span> wide                  <span class="c"># 해당하는 네임스페이스 내 모든 파드의 상세 목록 조회</span>
kubectl get deployment my-dep             <span class="c"># 특정 디플로이먼트의 목록 조회</span>
kubectl get pods                          <span class="c"># 네임스페이스 내 모든 파드의 목록 조회</span>
kubectl get pod my-pod <span class="nt">-o</span> yaml            <span class="c"># 파드의 YAML 조회</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="describe">describe</h2>
<p>쿠버네티스에 선언된 리소스의 상세한 상태를 확인합니다. 특정 리소스의 상태가 궁금하거나 생성이 실패한 이유를 확인할 때 주로 사용합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl describe <span class="o">[</span>TYPE]/[NAME] 또는 <span class="o">[</span>TYPE] <span class="o">[</span>NAME]
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pod                                 <span class="c"># Pod 조회로 이름 검색</span>
kubectl describe pod/wordpress-5f59577d4d-8t2dg <span class="c"># 조회한 이름으로 상세 확인</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="delete">delete</h2>
<p>쿠버네티스에 선언된 리소스를 제거합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl delete <span class="o">[</span>TYPE]/[NAME] 또는 <span class="o">[</span>TYPE] <span class="o">[</span>NAME]
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pod                                <span class="c"># Pod 조회로 이름 검색</span>
kubectl delete pod/wordpress-5f59577d4d-8t2dg  <span class="c"># 조회한 Pod 제거</span>
kubectl delete deploy deploymentname <span class="nt">-n</span> namespacename
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="logs">logs</h2>
<p>컨테이너의 로그를 확인합니다. 실시간 로그를 보고 싶다면 <code class="language-plaintext highlighter-rouge">-f</code> 옵션을 이용합니다. 하나의 Pod에 여러 개의 컨테이너가 있는 경우는 <code class="language-plaintext highlighter-rouge">-c</code> 옵션으로 컨테이너를 지정해야 합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl logs <span class="o">[</span>POD_NAME]
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pod                              <span class="c"># Pod 조회로 이름 검색</span>
kubectl logs wordpress-5f59577d4d-8t2dg      <span class="c"># 조회한 Pod 로그조회</span>
kubectl logs <span class="nt">-f</span> wordpress-5f59577d4d-8t2dg   <span class="c"># 실시간 로그 보기</span>
kubectl logs my-pod <span class="nt">-c</span> my-container          <span class="c"># 멀티-컨테이너 경우</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="exec">exec</h2>
<p>컨테이너에 명령어를 전달합니다. 쉘로 접속하여 컨테이너 상태를 확인하는 경우에 <code class="language-plaintext highlighter-rouge">-it</code> 옵션을 사용합니다. 여러 개의 컨테이너가 있는 경우엔 <code class="language-plaintext highlighter-rouge">-c</code> 옵션으로 컨테이너를 지정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl <span class="nb">exec</span> <span class="o">[</span><span class="nt">-it</span><span class="o">]</span> <span class="o">[</span>POD_NAME] <span class="nt">--</span> <span class="o">[</span>COMMAND]
</code></pre></div></div>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl get pod                                        <span class="c"># Pod 조회로 이름 검색</span>
kubectl <span class="nb">exec</span> <span class="nt">-it</span> wordpress-5f59577d4d-8t2dg <span class="nt">--</span> bash    <span class="c"># 조회한 Pod의 컨테이너에 접속</span>
kubectl <span class="nb">exec </span>my-pod <span class="nt">-c</span> my-container <span class="nt">--</span> <span class="nb">ls</span> /            <span class="c"># 멀티-컨테이너 경우</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="config">config</h2>
<p><code class="language-plaintext highlighter-rouge">kubectl</code>이 통신하고 설정 정보를 수정하는 쿠버네티스 클러스터를 지정합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl config get-contexts             <span class="c"># 컨텍스트 리스트 출력</span>
kubectl config current-context          <span class="c"># 현재 컨텍스트 확인</span>
kubectl config use-context minikube     <span class="c"># 기본 컨텍스트로 설정</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="api-resources">api-resources</h2>
<p>API 리소스를 탐색합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl api-resources                        <span class="c"># 전체 오브젝트 종류 확인</span>
kubectl api-resources <span class="nt">--namespaced</span><span class="o">=</span><span class="nb">true</span>      <span class="c"># 네임스페이스를 가지는 모든 리소스</span>
kubectl api-resources <span class="nt">--namespaced</span><span class="o">=</span><span class="nb">false</span>     <span class="c"># 네임스페이스를 가지지 않는 모든 리소스</span>
kubectl api-resources <span class="nt">-o</span> name                <span class="c"># 모든 리소스의 단순한 (리소스 이름만) 출력</span>
kubectl api-resources <span class="nt">-o</span> wide                <span class="c"># 모든 리소스의 확장된 ("wide"로 알려진) 출력</span>
kubectl api-resources <span class="nt">--verbs</span><span class="o">=</span>list,get       <span class="c"># "list"와 "get"의 요청 동사를 지원하는 모든 리소스 출력</span>
kubectl api-resources <span class="nt">--api-group</span><span class="o">=</span>extensions <span class="c"># "extensions" API 그룹의 모든 리소스</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="explain">explain</h2>
<p>특정 오브젝트 설명을 확인합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl explain pods           <span class="c"># 파드 매니페스트 문서를 조회</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="cp">cp</h2>
<p>로컬에서 컨테이너로, 컨테이너에서 로컬로 파일과 디렉터리를 복사합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kubectl <span class="nb">cp</span> /tmp/foo_dir my-pod:/tmp/bar_dir            <span class="c"># 로컬 디렉토리 /tmp/foo_dir 를 현재 네임스페이스의 my-pod 파드 안의 /tmp/bar_dir 로 복사</span>
kubectl <span class="nb">cp</span> /tmp/foo my-pod:/tmp/bar <span class="nt">-c</span> my-container    <span class="c"># 로컬 파일 /tmp/foo 를 my-pod 파드의 my-container 컨테이너 안의 /tmp/bar 로 복사</span>
kubectl <span class="nb">cp</span> /tmp/foo my-namespace/my-pod:/tmp/bar       <span class="c"># 로컬 파일 /tmp/foo 를 my-namespace 네임스페이스의 my-pod 파드 안의 /tmp/bar 로 복사</span>
kubectl <span class="nb">cp </span>my-namespace/my-pod:/tmp/foo /tmp/bar       <span class="c"># my-namespace 네임스페이스의 my-pod 파드 안의 파일 /tmp/foo 를 로컬의 /tmp/bar 로 복사</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="출력-형식-지정">출력 형식 지정</h2>
<p>특정 형식으로 터미널 창에 세부사항을 출력하려면, <code class="language-plaintext highlighter-rouge">kubectl</code> 명령에 <code class="language-plaintext highlighter-rouge">-o</code> (또는 <code class="language-plaintext highlighter-rouge">--output</code>) 플래그를 추가합니다.</p>

<table>
  <thead>
    <tr>
      <th>출력 형식</th>
      <th>세부 사항</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-o=custom-columns=<명세></명세></td>
      <td>쉼표로 구분된 사용자 정의 열 목록을 사용하여 테이블 출력</td>
    </tr>
    <tr>
      <td>-o=custom-columns-file=<파일명></파일명></td>
      <td><파일명>파일에서 사용자 정의 열 템플릿을 사용하여 테이블 출력</파일명></td>
    </tr>
    <tr>
      <td>-o=json</td>
      <td>JSON 형식의 API 오브젝트 출력</td>
    </tr>
    <tr>
      <td>-o=jsonpath=<템플릿></템플릿></td>
      <td>https://kubernetes.io/ko/docs/reference/kubectl/jsonpath 표현식에 정의된 필드 출력</td>
    </tr>
    <tr>
      <td>-o=jsonpath-file=<파일명></파일명></td>
      <td><파일명> 파일에서 https://kubernetes.io/ko/docs/reference/kubectl/jsonpath 표현식에 정의된 필드 출력</파일명></td>
    </tr>
    <tr>
      <td>-o=name</td>
      <td>리소스 명만 출력하고 그 외에는 출력하지 않음</td>
    </tr>
    <tr>
      <td>-o=wide</td>
      <td>추가 정보가 포함된 일반-텍스트 형식으로 출력하고, 파드의 경우 노드 명이 포함</td>
    </tr>
    <tr>
      <td>-o=yaml</td>
      <td>YAML 형식의 API 오브젝트 출력</td>
    </tr>
  </tbody>
</table>

<div class="notice--info">
<p><strong>사용방법</strong></p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ kubectl get [(-o|--output=)json|yaml|name|go-template|go-template-file
|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file|custom-columns
|custom-columns-file|wide] (TYPE[.VERSION][.GROUP] [NAME | -l label] | TYPE[.VERSION][.GROUP]/NAME ...) [flags]
</code></pre></div></div>
</div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 클러스터에서 실행 중인 모든 이미지</span>
kubectl get pods <span class="nt">-A</span> <span class="nt">-o</span><span class="o">=</span>custom-columns<span class="o">=</span><span class="s1">'DATA:spec.containers[*].image'</span>

<span class="c"># `default` 네임스페이스의 모든 이미지를 파드별로 그룹지어 출력</span>
kubectl get pods <span class="nt">--namespace</span> default <span class="nt">--output</span><span class="o">=</span>custom-columns<span class="o">=</span><span class="s2">"NAME:.metadata.name,IMAGE:.spec.containers[*].image"</span>

 <span class="c"># "registry.k8s.io/coredns:1.6.2" 를 제외한 모든 이미지</span>
kubectl get pods <span class="nt">-A</span> <span class="nt">-o</span><span class="o">=</span>custom-columns<span class="o">=</span><span class="s1">'DATA:spec.containers[?(@.image!="registry.k8s.io/coredns:1.6.2")].image'</span>

<span class="c"># 이름에 관계없이 메타데이터 아래의 모든 필드</span>
kubectl get pods <span class="nt">-A</span> <span class="nt">-o</span><span class="o">=</span>custom-columns<span class="o">=</span><span class="s1">'DATA:metadata.*'</span>
</code></pre></div></div>

<div class="notice--info">
<p><strong>도커 사용자를 위한 kubectl</strong><br />
만약 도커 커맨드 라인 도구에 익숙하다면 <a href="https://kubernetes.io/ko/docs/reference/kubectl/docker-cli-to-kubectl/" target="_blank">링크</a>를 통해 간단히 비교할 수 있습니다.</p>
</div>
<p><br />
<br />
<br /></p>

<h2 id="참고사이트">참고사이트</h2>
<ul>
  <li><a href="https://kubernetes.io/ko/docs/reference/kubectl/" target="_blank">kubectl docs 1</a></li>
  <li><a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands" target="_blank">kubectl docs 2</a></li>
  <li><a href="https://kubernetes.io/ko/docs/reference/kubectl/cheatsheet/" target="_blank">kubectl cheatsheet</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Kubernetes" /><category term="Kubernetes" /><category term="k8s" /><category term="kubectl" /><summary type="html"><![CDATA[💾 kubectl 기본명령어를 정리한 내용입니다.]]></summary></entry><entry><title type="html">Kubernetes 살펴보기</title><link href="http://localhost:4000/kubernetes/kubernetes-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="Kubernetes 살펴보기" /><published>2023-03-06T00:00:00+09:00</published><updated>2023-03-06T00:00:00+09:00</updated><id>http://localhost:4000/kubernetes/kubernetes-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/kubernetes/kubernetes-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/"><![CDATA[<p>💾 쿠버네티스의 기본 개념을 정리한 내용입니다.</p>

<p><br /></p>

<h1 id="-쿠버네티스란">🎯 쿠버네티스란?</h1>
<p>쿠버네티스는 컨테이너화된 애플리케이션을 배포, 관리, 확장할 때 수반되는 다수의 수동 프로세스를 자동화하는 <span class="danger-color">오픈소스 컨테이너 오케스트레이션 플랫폼</span>입니다.</p>

<table>
  <thead>
    <tr>
      <th><strong>용어</strong></th>
      <th><strong>뜻</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>컨테이너</td>
      <td>앱이 구동되는 환경까지 감싸서 실행할 수 있도록 하는 격리 기술</td>
    </tr>
    <tr>
      <td>컨테이너 런타임</td>
      <td>컨테이너를 다루는 도구</td>
    </tr>
    <tr>
      <td>도커</td>
      <td>컨테이너를 다루는 도구 중 가장 유명한 것</td>
    </tr>
    <tr>
      <td>쿠버네티스</td>
      <td>컨이너 런타임을 통해 컨테이너를 오케스트레이션 하는 도구</td>
    </tr>
    <tr>
      <td>오케스트레이션</td>
      <td>여러 서버에 걸친 컨테이너 및 사용하는 환경 설정을 관리하는 행위</td>
    </tr>
  </tbody>
</table>

<p><br />
<br />
<br /></p>

<h1 id="-쿠버네티스가-할-수-있는-일은">🎯 쿠버네티스가 할 수 있는 일은?</h1>
<ul>
  <li><strong>서비스 디스커버리와 로드 밸런싱:</strong> 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있습니다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있습니다.</li>
  <li><strong>스토리지 오케스트레이션:</strong> 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있습니다.</li>
  <li><strong>자동화된 롤아웃과 롤백:</strong> 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있습니다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있습니다.</li>
  <li><strong>자동화된 빈 패킹(bin packing):</strong> 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공합니다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시합니다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해줍니다.</li>
  <li><strong>자동화된 복구(self-healing):</strong> 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, ‘사용자 정의 상태 검사’에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않습니다.</li>
  <li><strong>시크릿과 구성 관리:</strong> 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있습니다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 할 수 있습니다.
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="-쿠버네티스-구성-요소">🎯 쿠버네티스 구성 요소</h1>
<ul>
  <li><a href="https://kubernetes.io/ko/docs/concepts/overview/components/" target="_blank">쿠버네티스 컴포넌트 설명</a></li>
  <li><a href="https://www.redhat.com/ko/topics/containers/kubernetes-architecture" target="_blank">쿠버네티스 아키텍처 설명</a>
<img src="/assets/images/posts/kubernetes/20230306/589D640F-E2E0-4750-9B73-58187E0F7BB9.png" alt="kubernetes components" />
<img src="/assets/images/posts/kubernetes/20230306/5485F1CF-F476-4537-B8D8-3B2E15FECBD2.png" alt="kubernetes components" /></li>
</ul>

<h2 id="용어-정리">용어 정리</h2>
<p><a href="https://kubernetes.io/ko/docs/reference/glossary/?fundamental=true" target="_blank">용어 정리</a></p>

<ul>
  <li><strong>컨트롤 플레인:</strong> 쿠버네티스 노드를 제어하는 프로세스의 컬렉션입니다. 여기에서 모든 태스크 할당이 시작됩니다.</li>
  <li><strong>노드:</strong> 컨트롤 플레인에서 할당된 요청 태스크를 수행하는 머신입니다.</li>
  <li><strong>포드:</strong> 단일 노드에 배포된 하나 이상의 컨테이너 그룹입니다. 포드에 있는 모든 컨테이너는 IP 주소, IPC, 호스트 이름, 기타 리소스를 공유합니다. 포드는 기본 컨테이너에서 네트워크와 스토리지를 추상화합니다. 이렇게 하면 클러스터에서 컨테이너를 더 쉽게 이동할 수 있습니다.</li>
  <li><strong>복제 컨트롤러:</strong> 이 컨트롤러는 클러스터에서 실행되어야 하는 동일한 포드 복사본의 개수를 제어합니다.</li>
  <li><strong>서비스:</strong> 포드에서 작업 정의를 분리합니다. 쿠버네티스 서비스 프록시는 클러스터에서 다른 위치로 이동된 경우나 교체된 경우에 상관없이 서비스 요청을 적절한 포드로 자동 수신합니다.</li>
  <li><strong>Kubelet:</strong> 이 서비스는 노드에서 실행되며 컨테이너 매니페스트를 읽고, 정의된 컨테이너가 시작되어 실행 중인지 확인합니다.</li>
  <li><strong>kubectl:</strong> 쿠버네티스의 커맨드 라인 구성 툴입니다.<br />
<br />
<br /></li>
</ul>

<h2 id="컨트롤-플레인-컴포넌트">컨트롤 플레인 컴포넌트</h2>
<p>컨트롤 플레인 컴포넌트는 클러스터에 관한 전반적인 결정(예를 들어, 스케줄링)을 수행하고 클러스터 이벤트(예를 들어, 디플로이먼트의 <code class="language-plaintext highlighter-rouge">replicas</code> 필드에 대한 요구 조건이 충족되지 않을 경우 새로운 파드를 구동시키는 것)를 감지하고 반응합니다.</p>

<ul>
  <li><strong>kube-apiserver:</strong> API 서버는 쿠버네티스 API를 노출하는 컨트롤 플레인의 프론트 엔드</li>
  <li><strong>etcd:</strong> 모든 클러스터 데이터(구성 요소들의 상태 값 등)를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소</li>
  <li><strong>Kube-scheduler:</strong> 노드가 배정되지 않은 새로 생성된 파드를 감지하고, 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당</li>
  <li><strong>kube-controller-manager:</strong> 쿠버네티스 클러스터의 오브젝트 상태를 관리합니다.
    <ul>
      <li><strong>노드 컨트롤러:</strong> 노드가 다운되었을 때 통지와 대응에 관한 책임</li>
      <li><strong>잡 컨트롤러:</strong> 일회성 작업을 나타내는 잡 오브젝트를 감시한 다음, 해당 작업을 완료할 때까지 동작하는 파드를 생성</li>
      <li><strong>엔드포인트 컨트롤러:</strong> 서비스와 파드를 연결</li>
      <li><strong>서비스 어카운트 &amp; 토큰 컨트롤러:</strong> 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성<br />
<br />
<br /></li>
    </ul>
  </li>
</ul>

<h2 id="노드-컴포넌트">노드 컴포넌트</h2>
<p>노드 컴포넌트는 동작 중인 파드를 유지시키고 쿠버네티스 런타임 환경을 제공하며, 모든 노드 상에서 동작합니다.</p>

<ul>
  <li><strong>노드:</strong> 컨트롤 플레인에서 할당된 요청 태스크를 수행하는 머신입니다. (서버)</li>
  <li><strong>파드(pod):</strong> 한 개 이상의 컨테이너로 이루어진 최소 단위</li>
  <li><strong>컨테이너 런타임(CRI, Container Runtime Interface):</strong> 파드를 이루는 컨테이너의 실행을 담당. 표준 인터페이스</li>
  <li><strong>kubelet:</strong> 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링</li>
  <li><strong>kube-proxy:</strong> 클러스터의 각 노드에서 실행되는 네트워크 프록시로, 쿠버네티스의 서비스 개념의 구현부입니다. 노드의 네트워크 규칙을 유지 관리해줍니다. 이 네트워크 규칙이 내부 네트워크 세션이나 클러스터 바깥에서 파드로 네트워크 통신을 할 수 있도록 해줍니다.</li>
  <li><strong>CoreDNS:</strong> 클라우드 네이티브 컴퓨팅 재단에서 보증하는 프로젝트로, 빠르고 유연한 DNS 서버. 쿠버테티스 클러스터에서 도메인 이름을 이용해 통신하는 데 사용합니다.<br />
<br />
<br /></li>
</ul>

<h2 id="파드의-생명주기로-쿠버네티스-구성-요소-살펴보기">파드의 생명주기로 쿠버네티스 구성 요소 살펴보기</h2>
<p><img src="/assets/images/posts/kubernetes/20230306/86DFC708-B0C9-495C-BD60-402EC75D59AC.png" alt="kubernetes components" /></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">kubectl</code>을 통해 <code class="language-plaintext highlighter-rouge">API 서버</code>에 파드 생성을 요청</li>
  <li>(업데이트가 있을 때 마다) <code class="language-plaintext highlighter-rouge">API 서버</code>에 전달된 내용이 있으면 <code class="language-plaintext highlighter-rouge">API 서버</code>는 <code class="language-plaintext highlighter-rouge">etcd</code>에 전달된 내용을 모두 기록해 클러스터의 상태 값을 최신으로 유지합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">API 서버</code>에 파드 생성이 요청된 것을 <code class="language-plaintext highlighter-rouge">컨트롤러 매니저</code>가 인지하면 <code class="language-plaintext highlighter-rouge">컨트롤러 매니저는</code> <code class="language-plaintext highlighter-rouge">파드</code>를 생성하고, 이 상태를 <code class="language-plaintext highlighter-rouge">API서버</code>에 전달합니다. 참고로 아직 어떤 워커 노드에 파드를 적용할지는 결정되지 않은 상태로 파드만 생성된다.</li>
  <li><code class="language-plaintext highlighter-rouge">API 서버</code>에 <code class="language-plaintext highlighter-rouge">파드</code>가 생성됐다는 정보를 <code class="language-plaintext highlighter-rouge">스케줄러</code>가 인지합니다. <code class="language-plaintext highlighter-rouge">스케줄러</code>는 생성된 <code class="language-plaintext highlighter-rouge">파드</code>를 어떤 <code class="language-plaintext highlighter-rouge">워커 노드</code>에 적용할지 조건을 고려해 결정하고 해당 <code class="language-plaintext highlighter-rouge">워커 노드</code>에 <code class="language-plaintext highlighter-rouge">파드</code>를 띄우도록 요청합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">API서버</code>에 전달된 정보대로 지정한 <code class="language-plaintext highlighter-rouge">워커 노드</code>에 <code class="language-plaintext highlighter-rouge">파드</code>가 속해 있는지 <code class="language-plaintext highlighter-rouge">스케줄러</code>가 <code class="language-plaintext highlighter-rouge">kubelet</code>으로 확인합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">kubelet</code>에서 <code class="language-plaintext highlighter-rouge">컨테이너 런타임</code>으로 <code class="language-plaintext highlighter-rouge">파드</code> 생성 요청합니다.</li>
  <li><code class="language-plaintext highlighter-rouge">파드</code> 생성</li>
  <li><code class="language-plaintext highlighter-rouge">파드</code> 사용 가능한 상태가 됩니다.<br />
<br />
<br /></li>
</ol>

<div class="notice--info">
<p><strong>참고</strong><br />
쿠버네티스는 선언적인 시스템 구조를 가지고 있습니다. 즉, 각 요소가 추구하는 상태를 선언하면 현재 상태와 맞는지 점검하고 그것에 맞추려고 노력하는 구조입니다.</p>

<p><img src="/assets/images/posts/kubernetes/20230306/C43E9BFE-A4C2-4FC0-AB8C-56EBFAA99BE5.png" alt="선언적구조" /></p>
</div>
<p><br />
<br />
<br /></p>

<h1 id="-오브젝트">🎯 오브젝트</h1>
<p>쿠버네티스를 사용하는 관점에서 파드, 디플로이먼트 등은 스펙(spec)과 상태(status) 등의 값을 가지고 있습니다. 이러한 값을 가지고 있는 파드와 디플로이먼트 등을 개별 속성을 포함해 부르는 단위를 오브젝트(Object)라고 합니다.</p>

<p>쿠버네티스 오브젝트는 하나의 <strong>의도를 담은 레코드</strong>입니다. 오브젝트를 생성하게 되면, 쿠버네티스 시스템은 그 오브젝트 생성을 보장하기 위해 지속적으로 작동할 것입니다. 오브젝트를 생성함으로써, 클러스터의 워크로드를 어떤 형태로 보이고자 하는지에 대해 효과적으로 쿠버네티스 시스템에 전달합니다.
<br />
<br /></p>

<h2 id="기본-오브젝트">기본 오브젝트</h2>
<ul>
  <li><strong>파드(Pod):</strong> 쿠버네티스에 실행되는 최소 단위, 독립적인 공간과 사용 가능한 IP를 가지고 있습니다. 하나의 파드는 1개 이상의 컨테이너를 갖고 있습니다.</li>
  <li><strong>네임스페이스(Namespaces):</strong> 쿠버네티스 클러스터에서 사용되는 리소스들을 구분해 관리하는 그룹입니다.</li>
  <li><strong>볼륨(Volume):</strong> 파드가 생성될 때 파드에서 사용할 수 있는 디렉터리를 제공합니다. 기본적으로 파드는 영속되는 개념이 아니라 제공되는 디렉토리도 임시로 사용합니다. 하지만 파드가 사라지더라도 저장과 보존이 가능한 디렉터리를 볼륨 오브젝트를 통해 생성하고 사용할 수 있습니다.</li>
  <li><strong>서비스(Service):</strong> 파드는 클러스터 내에서 유동적이기 때문에 접속 정보가 고정일 수 없습니다. 따라서 파드 접속을 안정적으로 유지하도록 서비스를 통해 내/외부로 연결됩니다. 새로운 파드가 생성될 때 부여되는 새로운 IP를 기존에 제공하던 기능과 연결해 줍니다.<br />
<br />
<br /></li>
</ul>

<p>기본 오브젝트 말고도 <a href="https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/" target="_blank">여러가지 오브젝트</a>들이 존재합니다.</p>

<h2 id="디플로이먼트">디플로이먼트</h2>
<p>기본 오브젝트만으로도 쿠버네티스를 사용할 수 있지만 이를 좀 더 효율적으로 작동하도록 기능들을 조합하고 추가해 구현한 것이 디플로이먼트 입니다. 디플로이먼트 오브젝트는 파드에 기본을 두고 있으며, 레플리카셋 오브젝트를 합쳐 놓은 형태 입니다.<br />
<img src="/assets/images/posts/kubernetes/20230306/701F7E06-6E1B-4DEC-8522-53ED577F2AAE.png" alt="디플로이먼트" />
<br />
<br />
<br /></p>

<h2 id="레플리카셋">레플리카셋</h2>
<p>다수의 파드가 필요한데 이를 하나씩 생성한다면 매우 비효율적입니다. 그래서 쿠버네티스에서는 다수의 파드를 만드는 레플리카셋 오브젝트를 제공합니다.</p>

<p>예를 들어 파드를 3개 만들겠다고 레플리카셋에 선언하면 컨트롤러 매니저와 스케줄러가 워커 노드에 파드 3개를 만들도록 선언합니다. 그러나 레플리카셋은 파드 수를 보장하는 기능만 제공하기 때문에 롤링 업데이트 기능 등이 추가된 디플로이먼트를 사용해 파드 수를 관리하기를 권장합니다.
<img src="/assets/images/posts/kubernetes/20230306/19156B09-0770-4580-A1E8-47EE207F990E.png" alt="레플리카셋" />
<br />
<br />
<br /></p>

<h2 id="오브젝트-스펙">오브젝트 스펙</h2>
<p>여러가지 설정을 커맨드 명령으로만으로 실행할 수 없습니다. 이런 설정은 파일로 작성해야 합니다. 이때 작성하는 파일을 오브젝트 스펙이라고 합니다. 오브젝트 스펙은 일반적으로 야믈(YAML) 문법으로 작성합니다.</p>

<p>다음은 <a href="https://kubernetes.io/ko/docs/concepts/workloads/controllers/" target="_blank">오브젝트 스펙의 예시</a>입니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>   <span class="c1"># 종류</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-deployment</span>     <span class="c1"># 디플로이먼트의 이름</span>
  <span class="na">labels</span><span class="pi">:</span>                    <span class="c1"># 디플로이먼트의 레이블</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>       <span class="c1"># 레플리카 셋을 몇 개 생성할지 결정</span>
  <span class="na">selector</span><span class="pi">:</span>         <span class="c1"># 셀렉터의 레이블 지정</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>       <span class="c1"># 템플릿의 메타데이터 지정</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">spec</span><span class="pi">:</span>           <span class="c1"># 템플릿에서 사용할 컨테이너 이미지 지정</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:1.14.2</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
</code></pre></div></div>
<p><br />
<br />
<br />
<br />
<br />
<br /></p>

<h1 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h1>
<ul>
  <li><a href="https://product.kyobobook.co.kr/detail/S000001834629" target="_blank">컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커</a></li>
  <li><a href="https://kubernetes.io/ko/docs/home/" target="_blank">쿠버네티스 레퍼런스</a></li>
  <li><a href="https://subicura.com/k8s/guide/#%E1%84%80%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3" target="_blank">쿠버네티스 가이드</a></li>
  <li><a href="https://kimjingo.tistory.com/category/About/Kubernetes" target="_blank">김징어의 Devlog</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Kubernetes" /><category term="Kubernetes" /><category term="k8s" /><summary type="html"><![CDATA[💾 쿠버네티스의 기본 개념을 정리한 내용입니다.]]></summary></entry><entry><title type="html">🐳 Docker Compose 네트워크</title><link href="http://localhost:4000/docker/docker-compose-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/" rel="alternate" type="text/html" title="🐳 Docker Compose 네트워크" /><published>2023-02-28T00:00:00+09:00</published><updated>2023-02-28T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker-compose-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC</id><content type="html" xml:base="http://localhost:4000/docker/docker-compose-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/"><![CDATA[<p>💾 여러 개의 컨테이너로 구성된 Docker Compose 애플리케이션 내에서 컨테이너 간의 통신을 설명합니다.</p>

<p><br /></p>

<h2 id="디폴트-네트워크">디폴트 네트워크</h2>
<p>기본적으로 <code class="language-plaintext highlighter-rouge">Docker Compose</code>는 하나의 디폴트 네트워크에 모든 컨테이너를 연결합니다. 디폴트 네트워크의 이름은 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>가 위치한 디렉토리 이름 뒤에 <code class="language-plaintext highlighter-rouge">_default</code>가 붙습니다. 예를 들어, 디렉토리 이름이 <code class="language-plaintext highlighter-rouge">our_app</code>라면 디폴트 네트워크 이름은 <code class="language-plaintext highlighter-rouge">our_app_default</code>가 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## /path/our_app 경로</span>
<span class="nv">$ </span>docker-compose up <span class="nt">-d</span>

Creating network <span class="s2">"our_app_default"</span> with the default driver
Creating our_app_db_1 ... <span class="k">done
</span>Creating our_app_web_1 ... <span class="k">done</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Docker Compose</code>로 애플리케이션을 내릴 때는 반대 순서로 먼저 컨테이너를 종료/제거해놓고 제일 마지막에 네트워크를 제거합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose down
Stopping our_app_web_1 ... <span class="k">done
</span>Stopping our_app_db_1  ... <span class="k">done
</span>Removing our_app_web_1 ... <span class="k">done
</span>Removing our_app_db_1  ... <span class="k">done
</span>Removing network our_app_default
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="컨테이너-간-통신">컨테이너 간 통신</h2>

<p><strong>같은 네트워크 간 통신</strong><br />
같은 네트워크 안에서 컨테이너 간의 통신은 호스트명을 사용합니다. 만약 호스트명을 지정하지 않았다면 서비스의 이름이 호스트명이 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose <span class="nb">exec </span>web ping db

PING db <span class="o">(</span>192.168.48.2<span class="o">)</span> 56<span class="o">(</span>84<span class="o">)</span> bytes of data.
64 bytes from our_app_db_1.our_app_default <span class="o">(</span>192.168.48.2<span class="o">)</span>: <span class="nv">icmp_seq</span><span class="o">=</span>1 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.094 ms
64 bytes from our_app_db_1.our_app_default <span class="o">(</span>192.168.48.2<span class="o">)</span>: <span class="nv">icmp_seq</span><span class="o">=</span>2 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.162 ms
</code></pre></div></div>
<p><br /></p>

<p><strong>호출 위치에 따른 통신</strong><br />
컨테이넌 간 통신에서 주의할 점은 접속하는 위치가 디폴트 네트워크 내부냐 외부냐에 따라서 포트(port)가 달라질 수 있다는 것입니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>services:
  web:
    build: <span class="nb">.</span>
    ports:
      - <span class="s2">"8001:8000"</span>
</code></pre></div></div>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 호스트 컴퓨터에서 web 서비스 컨테이너 접속</span>
<span class="nv">$ </span>curl <span class="nt">-I</span> localhost:8001

HTTP/1.1 200 OK
Date: Fri, 05 Jun 2020 02:05:10 GMT
Server: WSGIServer/0.2 CPython/3.8.2
Content-Type: text/html
X-Frame-Options: DENY
Content-Length: 16351
X-Content-Type-Options: nosniff
</code></pre></div></div>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 같은 네트워크 내의 다른 컨테이너에서 web 서비스 컨테이너 접속</span>
<span class="nv">$ </span>docker-compose <span class="nb">exec </span>alpine curl <span class="nt">-I</span> web:8000

HTTP/1.1 200 OK
Date: Fri, 05 Jun 2020 02:13:46 GMT
Server: WSGIServer/0.2 CPython/3.8.2
Content-Type: text/html
X-Frame-Options: DENY
Content-Length: 16351
X-Content-Type-Options: nosniff
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="커스텀-네트워크-추가">커스텀 네트워크 추가</h2>
<p><code class="language-plaintext highlighter-rouge">Docker Compose</code>는 디폴트 네트워크 뿐만 아니라 다른 네트워크도 필요에 따라 추가할 수 있습니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8000:8000"</span>
    <span class="na">networks</span><span class="pi">:</span> <span class="c1"># 서비스에서 연결할 네트워크 작성</span>
      <span class="pi">-</span> <span class="s">default</span>
      <span class="pi">-</span> <span class="s">our_net</span>

  <span class="na">db</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">postgres</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">POSTGRES_USER=postgres</span>
      <span class="pi">-</span> <span class="s">POSTGRES_PASSWORD=postgres</span>

<span class="c1"># 네트워크 추가</span>
<span class="na">networks</span><span class="pi">:</span>
  <span class="na">our_net</span><span class="pi">:</span>
    <span class="na">driver</span><span class="pi">:</span> <span class="s">bridge</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Docker Compose</code>로 애플리케이션을 실행하면 두개의 네트워크가 생성되는걸 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose up <span class="nt">-d</span>
Creating network <span class="s2">"our_app_default"</span> with the default driver
Creating network <span class="s2">"our_app_our_net"</span> with driver <span class="s2">"bridge"</span>
...

<span class="nv">$ </span>our_app docker network <span class="nb">ls
</span>NETWORK ID          NAME                   DRIVER              SCOPE
f1859120a0c3        bridge                 bridge              <span class="nb">local
</span>95b00551745b        host                   host                <span class="nb">local
</span>1f7202baa40a        none                   null                <span class="nb">local
</span>2682634e6535        our_app_default        bridge              <span class="nb">local
</span>525403b38bbe        our_app_our_net        bridge              <span class="nb">local</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">our_net</code>은 <code class="language-plaintext highlighter-rouge">Docker Compose</code> 내부에서 정의된 네트워크 이므로 애플리케이션을 내릴 때 디폴트 네트워크와 함께 삭제됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose down

Stopping our_app_web_1 ... <span class="k">done
</span>Stopping our_app_db_1  ... <span class="k">done
</span>Removing our_app_web_1 ... <span class="k">done
</span>Removing our_app_db_1  ... <span class="k">done
</span>Removing network our_app_default
Removing network our_app_our_net
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="외부-네트워크-사용">외부 네트워크 사용</h2>
<p><code class="language-plaintext highlighter-rouge">Docker Compose</code>가 제공하는 디폴트 네트워크 대신에 외부에서 미리 생성해놓은 다른 네트워크를 사용할 수도 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">our_net</code>이라는 네트워크 생성합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network create our_net
6d791b927c8c151c45a10ac13c62f3571ecf38a90756fd2ca1c62b7d3de804e8
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">docker-compose.yml</code>에서 네트워크의 옵션에 <code class="language-plaintext highlighter-rouge">our_net</code>네트워크에 <code class="language-plaintext highlighter-rouge">external</code>을 설정합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1번 방벙</span>
version: <span class="s1">'3.7'</span>

services:
  web:
    build: <span class="nb">.</span>
    ports:
      - <span class="s2">"8000:8000"</span>
    networks:
      - our_net

networks:
  our_net:
    driver: bridge
    external: <span class="nb">true</span>
</code></pre></div></div>

<div class="notice--warning">
<p><strong>경고</strong><br />
외부에서 생성된 네트워크이므로 <code class="language-plaintext highlighter-rouge">Docker Compose</code> 애플리케이션을 내릴 때 해당 네트워크가 함께 삭제되지 않습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose down

Stopping our_app_web_1 ... <span class="k">done
</span>Stopping our_app_db_1  ... <span class="k">done
</span>Removing our_app_web_1 ... <span class="k">done
</span>Removing our_app_db_1  ... <span class="k">done
</span>Network our_net is external, skipping
</code></pre></div></div>

</div>

<h2 id="레퍼런스-참고">레퍼런스 참고</h2>
<ul>
  <li><a href="https://docs.docker.com/compose/networking/" target="_blank">docker-compose 네트워크</a></li>
  <li><a href="https://docs.docker.com/compose/compose-file/#network_mode" target="_blank">docker-compose 네트워크 설정</a>
<br />
<br /></li>
</ul>

<h2 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h2>
<ul>
  <li><a href="https://www.daleseo.com/?tag=Docker" target="_blank">https://www.daleseo.com</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Docker" /><category term="Docker" /><category term="Docker Compose" /><category term="Container" /><summary type="html"><![CDATA[💾 여러 개의 컨테이너로 구성된 Docker Compose 애플리케이션 내에서 컨테이너 간의 통신을 설명합니다.]]></summary></entry><entry><title type="html">🐳 Docker Compose 명령어</title><link href="http://localhost:4000/docker/docker-compose-%EB%AA%85%EB%A0%B9%EC%96%B4/" rel="alternate" type="text/html" title="🐳 Docker Compose 명령어" /><published>2023-02-27T00:00:00+09:00</published><updated>2023-02-27T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker-compose-%EB%AA%85%EB%A0%B9%EC%96%B4</id><content type="html" xml:base="http://localhost:4000/docker/docker-compose-%EB%AA%85%EB%A0%B9%EC%96%B4/"><![CDATA[<p>💾 Docker Compose 애플리케이션을 제어하기 위해 사용되는 명령어를 설명합니다.
<br /></p>

<h2 id="파일-지정">파일 지정</h2>
<p><code class="language-plaintext highlighter-rouge">Docker Compose</code>는 기본적으로 커맨드가 실행하는 디렉토리에 있는 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 또는 <code class="language-plaintext highlighter-rouge">docker-compose.yaml</code>를 설정 파일로 사용합니다. 다른 이름이나 경로의 파일을 Docker Compose 설정 파일로 사용하고 싶다면 <code class="language-plaintext highlighter-rouge">-f</code> 옵션으로 명시를 해줍니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># -f 옵션으로 파일일 지정할 수 있습니다.</span>
<span class="nv">$ </span>docker-compose <span class="nt">-f</span> docker-compose-local.yml up

<span class="c"># -f 옵션은 여러 개의 설정 파일을 사용할 때도 사용할 수 있습니다.</span>
<span class="c"># 이 때는 나중에 나오는 설정이 앞에 나오는 설정보다 우선하게 됩니다.</span>
<span class="nv">$ </span>docker-compose <span class="nt">-f</span> docker-compose.yml <span class="nt">-f</span> docker-compose-test.yml up
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-생성실행">컨테이너 생성/실행</h2>
<p><code class="language-plaintext highlighter-rouge">docker-compose up</code> 커맨드는 <code class="language-plaintext highlighter-rouge">Docker Compose</code>에 정의되어 있는 모든 서비스 컨테이너를 한 번에 생성하고 실행하기 위해서 사용합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># -d 옵션을 사용하여 백그라운드에서 컨테이너를 띄웁니다.</span>
<span class="c"># -d 옵션을 사용하지 않으면 현재 터미널에 로그가 출력되고, Ctrl+c를 사용하여 종료할 수 있습니다.</span>
<span class="nv">$ </span>docker-compose up <span class="nt">-d</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-정지삭제">컨테이너 정지/삭제</h2>
<p><code class="language-plaintext highlighter-rouge">docker-compose down</code> 커맨드는 <code class="language-plaintext highlighter-rouge">Docker Compose</code>에 정의되어 있는 모든 서비스 컨테이너를 한 번에 정지시키고 삭제합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># -v 옵션을 주면 docker-compose.yml에 정의된 볼륨을 삭제하며 down 합니다.</span>
<span class="nv">$ </span>docker-compose down <span class="nt">-v</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-시작">컨테이너 시작</h2>
<p><code class="language-plaintext highlighter-rouge">docker-compose start</code> 커맨드는 내려가 있는 있는 특정 서비스 컨테이너를 올리기 위해서 사용합니다. <code class="language-plaintext highlighter-rouge">docker-compose up</code> 커맨드를 사용해도 내려간 서비스를 알아서 올려줍니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose start web
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-정지">컨테이너 정지</h2>
<p><code class="language-plaintext highlighter-rouge">docker-compose stop</code> 커맨드는 돌아기고 있는 특정 서비스 컨테이너를 정지시키기 위해서 사용합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose stop web
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-조회">컨테이너 조회</h2>
<p><code class="language-plaintext highlighter-rouge">docker-compose ps</code> 커맨드는 <code class="language-plaintext highlighter-rouge">Docker Compose</code>에 정의되어 있는 모든 서비스 컨테이너 목록을 조회할 때 사용합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose ps

      Name                    Command               State           Ports
<span class="nt">----------------------------------------------------------------------------------</span>
django-app_db_1    docker-entrypoint.sh postgres    Up      5432/tcp
django-app_web_1   python manage.py runserver ...   Up      0.0.0.0:8000-&gt;8000/tcp
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-로그">컨테이너 로그</h2>
<p><code class="language-plaintext highlighter-rouge">docker-compose logs</code> 커맨드는 서비스 컨테이너의 로그를 확인하고 싶을 때 사용하며, 보통 <code class="language-plaintext highlighter-rouge">-f</code> 옵션을 붙여서 실시간 로그를 확인합니다. <code class="language-plaintext highlighter-rouge">-f</code> 다음에 서비스명을 입력하면 해당 서비스의 로그만 볼 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose logs <span class="nt">-f</span> web

web_1  | May 30, 2020 - 22:16:29
web_1  | Django version 3.0.6, using settings <span class="s1">'our_project.settings'</span>
web_1  | Starting development server at http://0:8000/
web_1  | Quit the server with CONTROL-C.
</code></pre></div></div>
<p><br /></p>

<h2 id="명령어-전달">명령어 전달</h2>
<p><code class="language-plaintext highlighter-rouge">docker-compose exec</code> 커맨드는 실행 중인 서비스 컨테이너를 대상으로 어떤 명령어를 날릴 때 사용합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker-compose <span class="nb">exec</span> <span class="nt">-it</span> web /bin/bash
</code></pre></div></div>
<p><br /></p>

<h2 id="일회성-명령어">일회성 명령어</h2>
<p><code class="language-plaintext highlighter-rouge">docker-compose run</code> 커맨드는 서비스 컨테이너의 특정 명령어를 일회성으로 실행할 때 사용합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker compose run web bash
</code></pre></div></div>
<p><br /></p>

<h2 id="설정-확인">설정 확인</h2>
<p><code class="language-plaintext highlighter-rouge">docker-compose config</code> 커맨드는 <code class="language-plaintext highlighter-rouge">Docker Compose</code> 설정을 확인할 때 사용합니다. <code class="language-plaintext highlighter-rouge">-f</code> 옵션으로 여러 개의 설정 파일을 사용할 때, 최종적으로 어떻게 설정이 적용되는지 확인해볼 때 유용합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker compose config
</code></pre></div></div>
<p><br /></p>

<h2 id="레퍼런스-참고">레퍼런스 참고</h2>
<p><a href="https://docs.docker.com/compose/reference/" target="_blank">docker-compose</a>
<br />
<br /></p>

<h2 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h2>
<ul>
  <li><a href="https://www.daleseo.com/?tag=Docker" target="_blank">https://www.daleseo.com</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Docker" /><category term="Docker" /><category term="Docker Compose" /><category term="Container" /><summary type="html"><![CDATA[💾 Docker Compose 애플리케이션을 제어하기 위해 사용되는 명령어를 설명합니다.]]></summary></entry><entry><title type="html">🐳 Docker Compose 파일 구성 요소</title><link href="http://localhost:4000/docker/docker-compose-%ED%8C%8C%EC%9D%BC-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C/" rel="alternate" type="text/html" title="🐳 Docker Compose 파일 구성 요소" /><published>2023-02-22T00:00:00+09:00</published><updated>2023-02-22T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker-compose-%ED%8C%8C%EC%9D%BC-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C</id><content type="html" xml:base="http://localhost:4000/docker/docker-compose-%ED%8C%8C%EC%9D%BC-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C/"><![CDATA[<p>💾 도커 컴포즈의 기본 구성 요소룰 정리한 내용입니다. 자주 사용하는 항목만 정리하였고, 다른 항목들을 확인하시려면 <a href="https://docs.docker.com/compose/compose-file" target="_blank">docker-compose</a>를 확인하세요.</p>

<p><br /></p>

<h1 id="docker-compose란">Docker compose란?</h1>
<p>Docker Compose를 이용하면 여러 개의 컨테이너(container)로 구성된 애플리케이션을 하나의 파일(YAML)에 정의해놓고 명령어를 사용해 한 번에 올리거나 내릴 수 있습니다. Docker Compose는 기본적으로 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 파일을 설정 파일로 사용합니다.
<br />
<br /></p>

<h2 id="기본-구조">기본 구조</h2>
<p><code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 파일은 대략적으로 다음과 같은 구조를 갖습니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.7"</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="c1"># 컨테이너 서비스, 웹 애플리케이션 설정</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="c1"># 컨테이너 서비스, 데이터베이스 설정</span>
<span class="na">networks</span><span class="pi">:</span>
  <span class="c1"># 네트워크 설정</span>
<span class="na">volumes</span><span class="pi">:</span>
  <span class="c1"># 볼륨 설정</span>
</code></pre></div></div>
<p>Docker Compose에서 서비스는 독립된 컨테이너에서 돌아가는 애플리케이션의 구성 요소라고 생각하면 됩니다. 가장 먼저 프로젝트에서 개발하고 있는 애플리케이션 자체가 서비스가 될 것이고, 그 밖에 해당 애플리케이션이 의존하는 데이터베이스 등도 서비스가 될 수 있습니다. 즉, 메인 애플리케이션 뿐만 아니라 정상적으로 구동되기 위해서 필요한 기반 시스템까지 Docker Compose로 설정한다고 보시면 됩니다. 
<br />
<br /></p>

<h2 id="env-파일">.env 파일</h2>
<p><code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 파일과 같은 경로에 <code class="language-plaintext highlighter-rouge">.env</code> 파일을 정의할 수 있습니다. <code class="language-plaintext highlighter-rouge">.env </code>파일에 환경변수를 정의 하면 <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> 에서 사용할 수 있습니다.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># .env

MY_ENV="prod"
</code></pre></div></div>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># docker-compose.yml</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">web/</span>
      <span class="na">args</span><span class="pi">:</span>
        <span class="na">PROFILE</span><span class="pi">:</span> <span class="s">${MY_ENV}</span>
</code></pre></div></div>
<p><br />
<br />
<br />
<br /></p>

<h1 id="구성-요소">구성 요소</h1>
<p><code class="language-plaintext highlighter-rouge">docker-compose.yml</code>작성시 자주 사용하는 항목을 정리한 내용입니다.
<br /></p>

<h2 id="build">build</h2>
<p><code class="language-plaintext highlighter-rouge">build</code> 항목은 해당 서비스의 이미지를 빌드하기 위한 용도로, <code class="language-plaintext highlighter-rouge">Dockerfile</code>이 위치하는 경로를 지정하기 위해 사용됩니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## docker-compose.yml 파일과 동일한 디렉토리에 위치한 Dockerfile 을 사용해서 web 서비스의 이미지를 빌드</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
</code></pre></div></div>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">## Dockerfile이 아닌 다른 이름의 파일로 빌드를 하고 싶거나, 빌드 인자를 넘겨야 하는 경우</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">./app</span>
      <span class="na">dockerfile</span><span class="pi">:</span> <span class="s">Dockerfile-dev</span>
      <span class="na">args</span><span class="pi">:</span>
        <span class="na">arg1</span><span class="pi">:</span> <span class="s2">"</span><span class="s">development"</span>
<span class="err">	</span>    <span class="na">arg2</span><span class="pi">:</span> <span class="s2">"</span><span class="s">docker"</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="image">image</h2>
<p>프로젝트에서 직접 개발하지 않는 데이터베이스와 같은 경우에는, 이미지를 직접 빌드하는 대신에 이미지 저장소(repository)로 부터 이미지를 내려받아서 사용하는 것이 일반적입니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># image 항목은 이미지 저장소로 부터 내려받을 이미지의 이름과 태그를 명시하는데 사용됩</span>
<span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3.7'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">postgres:13</span>
  <span class="na">cache</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="ports">ports</h2>
<p><code class="language-plaintext highlighter-rouge">ports</code> 항목은 외부로 노출시킬 포트의 맵핑을 명시합니다. 바인드(bind)가 필요한 호스트 외부 포트와 컨테이너 내부 포트를 지정합니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">8000:8000"</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5432:5432"</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="volumes">volumes</h2>
<p><code class="language-plaintext highlighter-rouge">volumes</code> 항목은 볼륨 설정을 위해 쓰입니다. 마운트(mount)가 필요한 호스트의 경로와 컨테이너의 경로를 명시합니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 호스트의 경로로 볼륨 설정</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">.:/web</span>
</code></pre></div></div>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 미리 생성한 docker volume으로 볼륨 설정</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">frontend</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">node:lts</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">myapp:/home/node/app</span>

<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">myapp</span><span class="pi">:</span>
    <span class="na">external</span><span class="pi">:</span> <span class="no">true</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="depends_on">depends_on</h2>
<p><code class="language-plaintext highlighter-rouge">depends_on</code> 항목은 서비스 간 의존 관계를 지정하기 위해서 사용됩니다. 예를 들어, 웹 애플리케이션이 올라오기 전에 데이터베이스, 레디스 서비스가 먼저 올라와야 한다면 다음과 같이 설정합니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3.7"</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db</span>
      <span class="pi">-</span> <span class="s">redis</span>
  <span class="na">redis</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">postgres</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="command">command</h2>
<p><code class="language-plaintext highlighter-rouge">command</code> 항목은 해당 서비스가 올라올 때 <code class="language-plaintext highlighter-rouge">Dockerfile</code> 의 <code class="language-plaintext highlighter-rouge">CMD</code> 명령문을 무시하고 실행할 명령어를 설정하기 위해서 사용됩니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">node .</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="environment">environment</h2>
<p><code class="language-plaintext highlighter-rouge">environment</code> 항목은 환경 변수를 설정하기 위해서 사용됩니다.</p>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
   <span class="na">db</span><span class="pi">:</span>
     <span class="na">image</span><span class="pi">:</span> <span class="s">mysql:5.7</span>
     <span class="na">volumes</span><span class="pi">:</span>
       <span class="pi">-</span> <span class="s">db_data:/var/lib/mysql</span>
     <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
     <span class="na">environment</span><span class="pi">:</span>
       <span class="na">MYSQL_ROOT_PASSWORD</span><span class="pi">:</span> <span class="s">wordpress</span>
       <span class="na">MYSQL_DATABASE</span><span class="pi">:</span> <span class="s">wordpress</span>
       <span class="na">MYSQL_USER</span><span class="pi">:</span> <span class="s">wordpress</span>
       <span class="na">MYSQL_PASSWORD</span><span class="pi">:</span> <span class="s">wordpress</span>
</code></pre></div></div>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 아래와 같은 형식으로도 사용할 수 있습니다.</span>
<span class="na">environment</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">RACK_ENV=development</span>
  <span class="pi">-</span> <span class="s">SHOW=true</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="레퍼런스-참고">레퍼런스 참고</h2>
<p><a href="https://docs.docker.com/compose/compose-file" target="_blank">docker-compose</a>
<br />
<br />
<br />
<br />
<br /></p>

<h1 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h1>
<ul>
  <li><a href="https://www.daleseo.com/?tag=Docker" target="_blank">https://www.daleseo.com</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Docker" /><category term="Docker" /><category term="Docker Compose" /><category term="Container" /><summary type="html"><![CDATA[💾 도커 컴포즈의 기본 구성 요소룰 정리한 내용입니다. 자주 사용하는 항목만 정리하였고, 다른 항목들을 확인하시려면 docker-compose를 확인하세요.]]></summary></entry><entry><title type="html">🐳 Docker 이미지 만들기</title><link href="http://localhost:4000/docker/docker-%EC%9D%B4%EB%AF%B8%EC%A7%80%EB%A7%8C%EB%93%A4%EA%B8%B0/" rel="alternate" type="text/html" title="🐳 Docker 이미지 만들기" /><published>2023-02-21T00:00:00+09:00</published><updated>2023-02-21T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker-%EC%9D%B4%EB%AF%B8%EC%A7%80%EB%A7%8C%EB%93%A4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/docker/docker-%EC%9D%B4%EB%AF%B8%EC%A7%80%EB%A7%8C%EB%93%A4%EA%B8%B0/"><![CDATA[<p>💾 도커 이미지를 만들기 위해 Dockerfile 이라는 이미지 빌드용 파일을 사용합니다.</p>

<p><br /></p>

<p><img src="/assets/images/posts/docker/20230221/d1969bd2-2ec2-41d2-924e-38202359d741.png" alt="docker_image_build" />
<br />
<br /></p>

<h1 id="-dockerfile-구조">🎯 Dockerfile 구조</h1>
<p>Ruby 웹 애플리케이션을 ubuntu에 배포하는 과정을 통해 구조를 살펴봅니다.</p>

<h2 id="dockerfile-생성">Dockerfile 생성</h2>
<p>아래 과정을 쉘 스크립트, Dockerfile로 만들어 비교합니다.</p>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>순서  |  작업
---------------------
1    |  ubuntu 설치
2    |  ruby 설치
3    |  소스 복사
4    |  Gem 패키지 설치
5    |  Sinatra 서버 실행
</code></pre></div></div>
<p><br /></p>

<p><strong>쉘 스크립트</strong></p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. ubuntu 설치 (패키지 업데이트)</span>
apt-get update

<span class="c"># 2. ruby 설치</span>
apt-get <span class="nb">install </span>ruby
gem <span class="nb">install </span>bundler

<span class="c"># 3. 소스 복사</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /usr/src/app
scp Gemfile app.rb root@ubuntu:/usr/src/app  <span class="c"># From host</span>

<span class="c"># 4. Gem 패키지 설치</span>
bundle <span class="nb">install</span>

<span class="c"># 5. Sinatra 서버 실행</span>
bundle <span class="nb">exec </span>ruby app.rb
</code></pre></div></div>
<p><br /></p>

<p><strong>Dockerfile</strong></p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## 핵심 명령어는 파일을 복사하는 COPY와 실행하는 RUN 입니다.</span>
<span class="c"># 1. ubuntu 설치 (패키지 업데이트 + 만든사람 표시)</span>
<span class="k">FROM</span><span class="s">       ubuntu:16.04</span>
<span class="k">MAINTAINER</span><span class="s"> subicura@subicura.com</span>
<span class="k">RUN        </span>apt-get <span class="nt">-y</span> update

<span class="c"># 2. ruby 설치</span>
<span class="k">RUN </span>apt-get <span class="nt">-y</span> <span class="nb">install </span>ruby
<span class="k">RUN </span>gem <span class="nb">install </span>bundler

<span class="c"># 3. 소스 복사</span>
<span class="k">COPY</span><span class="s"> . /usr/src/app</span>

<span class="c"># 4. Gem 패키지 설치 (실행 디렉토리 설정)</span>
<span class="k">WORKDIR</span><span class="s"> /usr/src/app</span>
<span class="k">RUN     </span>bundle <span class="nb">install</span>

<span class="c"># 5. Sinatra 서버 실행 (Listen 포트 정의)</span>
<span class="k">EXPOSE</span><span class="s"> 4567</span>
<span class="k">CMD</span><span class="s">    bundle exec ruby app.rb -o 0.0.0.0</span>
</code></pre></div></div>
<p>쉘 스크립트의 내용을 거의 그대로 Dockerfile로 옮겼습니다. 차이점은 도커 빌드 중엔 키보드를 입력할 수 없기 때문에 (y/n) 을 물어보는 걸 방지하기 위해 -y 옵션을 추가한 것 정도입니다.
<br /></p>

<h2 id="이미지-생성">이미지 생성</h2>
<p>생성한 Dockerfile을 기반으로 이미지를 생성합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Dockerfile을 만든 디렉토리로 이동하여 다음 명령어를 입력합니다.</span>
<span class="c"># docker build -t [새로 생성할 이미지 이름] [Dockerfile 디렉토리 경로]</span>
<span class="nv">$ </span>docker build <span class="nt">-t</span> app <span class="nb">.</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="확인">확인</h2>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
app                 latest              54d239c00f11        4 minutes ago       209 MB
ubuntu              16.04               f49eec89601e        2 weeks ago         129 MB
</code></pre></div></div>
<p><br />
<br />
<br />
<br />
<br /></p>

<h1 id="-dockerfile-기본-명령어">🎯 Dockerfile 기본 명령어</h1>
<p>Dockerfile의 기본적인 명령어를 살펴봅니다.</p>

<h2 id="from">FROM</h2>
<p>하나의 Docker 이미지는 base 이미지부터 시작해서 기존 이미지위에 새로운 이미지를 중첩해서 여러 단계의 이미지 층(layer)을 쌓아가며 만들어집니다.</p>

<p><code class="language-plaintext highlighter-rouge">FROM</code> 명령문은 이 base 이미지를 지정해주기 위해서 사용되는데, 보통 Dockerfile 내에서 최상단에 위치합니다. base 이미지는 일반적으로 Docker Hub와 같은 Docker repository에 올려놓은 잘 알려진 공개 이미지인 경우가 많습니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># FROM &lt;이미지&gt;</span>
<span class="c"># FROM &lt;이미지&gt;:&lt;태그&gt;</span>

<span class="c"># Ubuntu 최신 버전을 base 이미지로 사용</span>
<span class="k">FROM</span><span class="s"> ubuntu:latest</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="maintainer-deprecated">MAINTAINER (deprecated)</h2>
<p>Dockerfile을 관리하는 사람의 이름 또는 이메일 정보를 적습니다. 빌드에 영향을 주지는 않습니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># MAINTAINER &lt;name&gt;</span>

<span class="k">MAINTAINER</span><span class="s"> name@gmail.com</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="copy">COPY</h2>
<p>파일이나 디렉토리를 이미지로 복사합니다. 일반적으로 소스를 복사하는 데 사용합니다. target 디렉토리가 없다면 자동으로 생성합니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span>
<span class="c"># COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;",... "&lt;dest&gt;"]</span>

<span class="k">COPY</span><span class="s"> . /usr/src/app</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="add">ADD</h2>
<p><code class="language-plaintext highlighter-rouge">COPY</code> 명령어와 매우 유사하나 몇가지 추가 기능이 있습니다. src 에 파일 대신 URL을 입력할 수 있고 src
에 압축 파일을 입력하는 경우 자동으로 압축을 해제하면서 복사됩니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ADD [--chown=&lt;user&gt;:&lt;group&gt;] [--checksum=&lt;checksum&gt;] &lt;src&gt;... &lt;dest&gt;</span>
<span class="c"># ADD [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;src&gt;",... "&lt;dest&gt;"]</span>

<span class="k">ADD</span><span class="s"> . /usr/src/app</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="run">RUN</h2>
<p>명령어를 그대로 실행합니다. 내부적으로 /bin/sh -c 뒤에 명령어를 실행하는 방식입니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># RUN &lt;command&gt;</span>
<span class="k">RUN </span>npm <span class="nb">install</span> <span class="nt">--silent</span>

<span class="c"># RUN ["executable", "param1", "param2"]</span>
<span class="k">RUN </span><span class="o">[</span><span class="s2">"/bin/bash"</span>, <span class="s2">"-c"</span>, <span class="s2">"echo hello"</span><span class="o">]</span>

<span class="c"># 멀티라인</span>
<span class="k">RUN </span>/bin/bash <span class="nt">-c</span> <span class="s1">'source $HOME/.bashrc &amp;&amp; </span><span class="se">\
</span><span class="s1">echo $HOME'</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="entrypoint">ENTRYPOINT</h2>
<p><code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> 명령문은 이미지를 컨테이너로 띄울 때 항상 실행되야 하는 커맨드를 지정할 때 사용합니다. <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> 명령문은 Docker 이미지를 마치 하나의 실행 파일처럼 사용할 때 유용합니다. 왜냐하면 컨테이너가 뜰 때 <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> 명령문으로 지정된 커맨드가 실행되고, 이 커맨드로 실행된 프로세스가 죽을 때, 컨테이너로 따라서 종료되기 때문입니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ENTRYPOINT ["&lt;커맨드&gt;", "&lt;파라미터1&gt;", "&lt;파라미터2&gt;"]</span>
<span class="c"># ENTRYPOINT &lt;전체 커맨드&gt;</span>
<span class="k">ENTRYPOINT</span><span class="s"> ["npm", "start"]</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="cmd">CMD</h2>
<p>Dockerfile에는 하나의 <code class="language-plaintext highlighter-rouge">CMD</code> 명령어만 있을 수 있습니다. 둘 이상의 <code class="language-plaintext highlighter-rouge">CMD</code>를 나열하면 마지막 <code class="language-plaintext highlighter-rouge">CMD</code>만 적용됩니다.</p>

<p><code class="language-plaintext highlighter-rouge">CMD</code>의 주요 목적은 실행 컨테이너에 대한 기본값을 제공하는 것입니다. <code class="language-plaintext highlighter-rouge">CMD</code> 명령문은 많은경우 <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> 명령문과 함께 사용하게 되는데, <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> 명령문으로는 커맨드를 지정하고, <code class="language-plaintext highlighter-rouge">CMD</code> 명령문으로 디폴트 파리미터를 지정해주면 매우 유연하게 이미지를 실행할 수 있게 됩니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CMD</span><span class="s"> ["executable","param1","param2"]</span>
<span class="k">CMD</span><span class="s"> command param1 param2</span>
<span class="k">CMD</span><span class="s"> bundle exec ruby app.rb</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="workdir">WORKDIR</h2>
<p><code class="language-plaintext highlighter-rouge">RUN</code>, <code class="language-plaintext highlighter-rouge">CMD</code>, <code class="language-plaintext highlighter-rouge">ADD</code>, <code class="language-plaintext highlighter-rouge">COPY</code>등이 이루어질 기본 디렉토리를 설정합니다. 각 명령어의 현재 디렉토리는 한 줄 한 줄마다 초기화되기 때문에 RUN cd /path 를 하더라도 다음 명령어에선 다시 위치가 초기화 됩니다. 같은 디렉토리에서 계속 작업하기 위해서 <code class="language-plaintext highlighter-rouge">WORKDIR</code> 을 사용합니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WORKDIR</span><span class="s"> /path/to/workdir</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="expose">EXPOSE</h2>
<p>도커 컨테이너가 실행되었을 때 요청을 기다리고 있는(Listen) 포트를 지정합니다. 여러개의 포트를 지정할 수 있습니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># EXPOSE &lt;port&gt; [&lt;port&gt;...]</span>
<span class="c"># EXPOSE &lt;포트&gt;/&lt;프로토콜&gt;</span>

<span class="k">EXPOSE</span><span class="s"> 4567</span>
<span class="k">EXPOSE</span><span class="s"> 9999/udp</span>
</code></pre></div></div>

<div class="notice--info">
<p><strong>참고</strong></p>

<p><code class="language-plaintext highlighter-rouge">EXPOSE</code> 명령문으로 지정된 포트는 해당 컨테이너의 내부에서만 유효하며, 호스트(host) 컴퓨터에서는 이 포트를 바로 접근을 할 수 있는 것은 아니라는 겁니다. 호스트 컴퓨터로부터 해당 포트로의 접근을 허용하려면, <code class="language-plaintext highlighter-rouge">docker run</code> 커맨드를 <code class="language-plaintext highlighter-rouge">-p</code> 옵션을 통해 호스트 컴퓨터의 특정 포트를 포워딩(forwarding)시켜줘야 합니다.</p>
</div>
<p><br /></p>

<h2 id="volume">VOLUME</h2>
<p>컨테이너 외부에 파일시스템을 마운트 할 때 사용합니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">VOLUME</span><span class="s"> ["/data"]</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="env">ENV</h2>
<p>컨테이너에서 사용할 환경변수를 지정합니다. 컨테이너를 실행할 때 <code class="language-plaintext highlighter-rouge">-e</code> 옵션을 사용하면 기존 값을 오버라이딩 하게 됩니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># ENV &lt;key&gt; &lt;value&gt;</span>
<span class="c"># ENV &lt;key&gt;=&lt;value&gt; ...</span>
<span class="k">ENV</span><span class="s"> DB_URL mysql</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="arg">ARG</h2>
<p><code class="language-plaintext highlighter-rouge">ARG</code> 명령문은 <code class="language-plaintext highlighter-rouge">docker build</code> 커맨드로 이미지를 빌드 시, <code class="language-plaintext highlighter-rouge">--build-arg</code> 옵션을 통해 넘길 수 있는 인자를 정의하기 위해 사용합니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 예를 들어, Dockerfile에 다음과 같이 ARG 명령문으로 port를 인자로 선언해주면</span>
<span class="k">ARG</span><span class="s"> port</span>

<span class="c"># 다음과 같이 docker build 커맨드에 --build-arg 옵션에 port 값을 넘길 수가 있습니다.</span>
$ docker build --build-arg port=8080 .



# 인자의 디폴트값을 지정해주면, --build-arg 옵션으로 해당 인자가 넘어오지 않았을 때 사용됩니다.
<span class="k">ARG</span><span class="s"> port=8080</span>

<span class="c"># 설정된 인자 값은 다음과 같이 ${인자명} 형태로 읽어서 사용할 수 있습니다.</span>
<span class="k">CMD</span><span class="s"> start.sh -h 127.0.0.1 -p ${port}</span>
</code></pre></div></div>

<div class="notice--info">
<p><strong>참고</strong></p>

<p><code class="language-plaintext highlighter-rouge">ENV</code> 와 달리 <code class="language-plaintext highlighter-rouge">ARG</code> 로 설정한 값은 이미지가 빌드되는 동안에만 유효</p>
</div>
<p><br /></p>

<h2 id="dockerignore-파일">.dockerignore 파일</h2>
<p>Docker 이미지를 빌드할 때 제외 시키고 싶은 파일이 있다면, <code class="language-plaintext highlighter-rouge">.dockerignore</code> 파일에 추가해주면 됩니다.</p>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># .dockerignore\</span>
<span class="c"># 제외 할 파일을 작성</span>
.git
*.md
</code></pre></div></div>
<p><br /></p>

<h2 id="정리">정리</h2>

<table>
  <thead>
    <tr>
      <th>명령어</th>
      <th>용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>FROM</td>
      <td>base 이미지 설정</td>
    </tr>
    <tr>
      <td>WORKDIR</td>
      <td>작업 디렉터리 설정</td>
    </tr>
    <tr>
      <td>RUN</td>
      <td>이미지 빌드 시 커맨드 실행</td>
    </tr>
    <tr>
      <td>ENTRYPOINT</td>
      <td>이미지 실행 시 항상 실행되야 하는 커맨드 설정</td>
    </tr>
    <tr>
      <td>CMD</td>
      <td>이미지 실행 시 디폴트 커맨드 또는 파라미터 설정</td>
    </tr>
    <tr>
      <td>EXPOSE</td>
      <td>컨테이너가 리스닝할 포트 및 프로토콜 설정</td>
    </tr>
    <tr>
      <td>COPY/ADD</td>
      <td>이미지의 파일 시스템으로 파일 또는 디렉터리 복사</td>
    </tr>
    <tr>
      <td>ENV</td>
      <td>환경 변수 설정</td>
    </tr>
    <tr>
      <td>ARG</td>
      <td>빌드 시 넘어올 수 있는 인자 설정</td>
    </tr>
    <tr>
      <td>VOLUME</td>
      <td>컨테이너 외부에 파일시스템을 마운트 할 때 사용합니다.</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h2 id="레퍼런스-참고">레퍼런스 참고</h2>
<ul>
  <li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank">Dockerfile</a>
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h1>
<ul>
  <li><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank">https://subicura.com</a></li>
  <li><a href="https://www.daleseo.com/?tag=Docker" target="_blank">https://www.daleseo.com</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Docker" /><category term="Docker" /><category term="Container" /><summary type="html"><![CDATA[💾 도커 이미지를 만들기 위해 Dockerfile 이라는 이미지 빌드용 파일을 사용합니다.]]></summary></entry><entry><title type="html">🐳 Docker 기본 명령어</title><link href="http://localhost:4000/docker/docker-%EA%B8%B0%EB%B3%B8%EB%AA%85%EB%A0%B9%EC%96%B4/" rel="alternate" type="text/html" title="🐳 Docker 기본 명령어" /><published>2023-02-20T00:00:00+09:00</published><updated>2023-02-20T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker-%EA%B8%B0%EB%B3%B8%EB%AA%85%EB%A0%B9%EC%96%B4</id><content type="html" xml:base="http://localhost:4000/docker/docker-%EA%B8%B0%EB%B3%B8%EB%AA%85%EB%A0%B9%EC%96%B4/"><![CDATA[<p>💾 도커에서 자주 사용하는 명령어를 정리한 내용입니다.</p>

<p><br /></p>

<h1 id="-컨테이너-관련-명령어">🎯 컨테이너 관련 명령어</h1>
<p>Docker CLI 도구는 Docker 컨테이너(container)의 효과적인 관리를 위해서 다양한 커맨드(command)를 제공합니다.</p>

<h2 id="컨테이너-조회">컨테이너 조회</h2>
<p><code class="language-plaintext highlighter-rouge">docker ps</code> 커맨드는 Docker 컨테이너를 조회를 위해 사용되며 기본적으로 실행 중인 컨테이너 목록이 출력됩니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 조회</span>
<span class="nv">$ </span>docker ps

<span class="c"># -a 옵션</span>
<span class="c"># 현재 중지되어 있는 컨테이너까지 함께 출력됩니다.</span>
<span class="nv">$ </span>docker ps <span class="nt">-a</span>

<span class="c"># -s 옵션</span>
<span class="c"># 각 컨테이너의 디스크 사용량까지 볼 수 있습니다.</span>
<span class="nv">$ </span>docker ps <span class="nt">-s</span>

<span class="c"># -f 옵션</span>
<span class="c"># 조회 결과를 특정 조건에 따라 필터링해서 볼 수 있습니다.</span>
<span class="c"># 예를 들어, 특정 이미지로 부터 만들어진 컨테이어만 보고 싶다면 ancestor 필터를 사용하면 됩니다.</span>
<span class="nv">$ </span>docker ps <span class="nt">-af</span> <span class="s2">"ancestor=python:alpine"</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS               NAMES
b1bae952f7a6        python:alpine       <span class="s2">"python -m http.serv…"</span>   About an hour ago   Exited <span class="o">(</span>137<span class="o">)</span> 3 minutes ago                         amazing_chatelet
518d8bb6afaf        python:alpine       <span class="s2">"python3"</span>                About an hour ago   Exited <span class="o">(</span>0<span class="o">)</span> About an hour ago                       focused_gauss
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-실행">컨테이너 실행</h2>
<p><code class="language-plaintext highlighter-rouge">docker run</code> 커맨드는 상당히 여러가지 옵션을 통해 다양한 방식으로 컨테이너를 실행할 수 있도록 해줍니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 기본 실행</span>
<span class="c"># $ docker run (&lt;옵션&gt;) &lt;이미지 식별자&gt; (&lt;명령어&gt;) (&lt;인자&gt;)</span>
<span class="nv">$ </span>docker run hello-world

<span class="c"># -d 옵션</span>
<span class="c"># 컨테이너를 백그라운드에서 실행</span>
<span class="c"># -d 옵션없이 실행했다면, 해당 터미널에서 Ctrl + C를 눌러서 빠져나오는 순간 해당 컨테이너는 종료될 것입니다.</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> python:3.8-alpine python <span class="nt">-m</span> http.server

<span class="c"># -it 옵션</span>
<span class="c"># -i와 -t를 동시에 사용한 것으로 터미널 입력을 위한 옵션</span>
<span class="nv">$ </span>docker run <span class="nt">-it</span> python:3.8-alpine
<span class="nv">$ </span>docker run <span class="nt">-it</span> python:3.8-alpine /bin/sh

<span class="c"># -name 옵션</span>
<span class="c"># 컨테이너 이름 설정</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">--name</span> my-server python:3.8-alpine python <span class="nt">-m</span> http.server

<span class="c"># -e 옵션</span>
<span class="c"># 컨테이너 내에서 사용할 환경변수 설정</span>
<span class="c">## Docker 컨테이너의 환경변수를 설정하기 위해서는 -e 옵션을 사용합니다.</span>
<span class="c">## 또한, -e 옵션을 사용하면 Dockerfile의 ENV 설정도 덮어써지게 됩니다.</span>
<span class="nv">$ </span>docker run <span class="nt">-e</span> <span class="nv">FOO</span><span class="o">=</span>bar python:3.8-alpine <span class="nb">env</span>

<span class="c"># -p 옵션</span>
<span class="c"># 호스트와 컨테이너의 포트를 연결 (포워딩)</span>
<span class="nv">$ </span>docker run <span class="nt">-d</span> <span class="nt">-p</span> 80:8000 python:3.8-alpine python <span class="nt">-m</span> http.server

<span class="c"># -v 옵션</span>
<span class="c"># 호스트와 컨테이너의 디렉토리를 연결 (마운트)</span>
<span class="nv">$ </span><span class="nb">echo </span>Hi <span class="o">&gt;</span> test.txt
<span class="nv">$ </span>docker run <span class="nt">-v</span> <span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>:/etc python:3.8-alpine <span class="nb">cat</span> /etc/test.txt
Hi

<span class="c"># -rm 옵션</span>
<span class="c"># 컨테이너가 종료될 때 컨테이너와 관련된 리소스(파일 시스템, 볼륨)까지 깨끗이 제거해줍니다.</span>
<span class="nv">$ </span>docker run <span class="nt">--rm</span> <span class="nt">-it</span> ubuntu:16.04 /bin/bash
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-중지">컨테이너 중지</h2>
<p>실행 중인 Docker 컨테이너를 중지하려면 <code class="language-plaintext highlighter-rouge">docker stop</code> 커맨드를 사용합니다. 중지하고 싶은 컨테이너의 아이디나 이름을 인자로 넘깁니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 아이디나 이름을 인자로 컨테이너 중지</span>
<span class="nv">$ </span>docker stop container_name
container_name

<span class="c"># 조회</span>
<span class="nv">$ </span>docker ps <span class="nt">-af</span> <span class="s2">"name=container_name"</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMES
b1bae952f7a6        python:alpine       <span class="s2">"python -m http.serv…"</span>   About an hour ago   Exited <span class="o">(</span>137<span class="o">)</span> 32 seconds ago                       container_name

<span class="c"># 컨테이너 전체 중지</span>
<span class="nv">$ </span>docker stop <span class="si">$(</span>docker ps <span class="nt">-a</span> <span class="nt">-q</span><span class="si">)</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-시작">컨테이너 시작</h2>
<p>중지된 Docker 컨테이너를 다시 시작하려면 <code class="language-plaintext highlighter-rouge">docker start</code> 커맨드를 사용합니다. 마찬가지로 재시작하고 싶은 컨테이너의 아이디나 이름을 인자로 넘기면 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 아이디나 이름을 인자로 컨테이너 시작</span>
<span class="nv">$ </span>docker start b1bae952f7m1
b1bae952f7m1

<span class="nv">$ </span>docker ps <span class="nt">-af</span> <span class="s2">"id=b1bae952f7m1"</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
b1bae952f7m1        python:alpine       <span class="s2">"python -m http.serv…"</span>   About an hour ago   Up About a minute                       amazing_chatelet
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-상대로-명령어-실행">컨테이너 상대로 명령어 실행</h2>
<p>실행 중인 컨테이너 상대로 명령어를 날리고 싶다면 <code class="language-plaintext highlighter-rouge">docker exec</code> 커맨드를 사용합니다. 예를 들어, 어떤 컨테이너를 상대로 <code class="language-plaintext highlighter-rouge">ls</code> 커맨드를 실행하고 싶다면 다음과 같이 하면 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">exec </span>b1bae952f7a6 <span class="nb">ls
</span>bin dev etc home lib media mnt ...생략...
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">-it</code> 옵션을 사용하면 해당 컨테이너의 쉘(shell)과 작접 상호작용하면서 연속으로 명령어를 실행할 수 있습니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">exec</span> <span class="nt">-it</span> container_name /bin/sh

<span class="nv">$ </span><span class="nb">ls
</span>bin    etc    lib    mnt    proc   run    srv    tmp    var
dev    home   media  opt    root   sbin   sys    usr
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-로그-확인">컨테이너 로그 확인</h2>
<p>컨테이너의 로그를 확인하려면 <code class="language-plaintext highlighter-rouge">docker logs</code> 커맨드를 사용하면 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker logs b1bae952f7a6

<span class="c"># -f 옵션을 사용하면 실시간 로그를 확인할 수 있습니다.</span>
<span class="nv">$ </span>docker logs <span class="nt">-f</span> container_name

<span class="c"># 마지막 10줄만 출력</span>
<span class="nv">$ </span>docker logs <span class="nt">--tail</span> 10 container_name
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-상세-정보">컨테이너 상세 정보</h2>
<p>특정 컨테이너의 상세 정보를 확인하고 싶다면, <code class="language-plaintext highlighter-rouge">docker inspect</code> 커맨드를 사용합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker inspect 8c27a672e23c
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"Id"</span>: <span class="s2">"8c27a672e23c1c48aaaa0d2e65325aefb36db2934f724634dd4f5684397014ba"</span>,
        <span class="s2">"Created"</span>: <span class="s2">"2020-04-25T18:23:24.651490253Z"</span>,
        <span class="s2">"Path"</span>: <span class="s2">"/bin/sh"</span>,
        <span class="s2">"Args"</span>: <span class="o">[]</span>,
        <span class="s2">"State"</span>: <span class="o">{</span>
            <span class="s2">"Status"</span>: <span class="s2">"exited"</span>,
            <span class="s2">"Running"</span>: <span class="nb">false</span>,
            <span class="s2">"Paused"</span>: <span class="nb">false</span>,
            <span class="s2">"Restarting"</span>: <span class="nb">false</span>,
            <span class="s2">"OOMKilled"</span>: <span class="nb">false</span>,
            <span class="s2">"Dead"</span>: <span class="nb">false</span>,
            <span class="s2">"Pid"</span>: 0,
            <span class="s2">"ExitCode"</span>: 0,
            <span class="s2">"Error"</span>: <span class="s2">""</span>,
            <span class="s2">"StartedAt"</span>: <span class="s2">"2020-04-25T18:23:25.300618082Z"</span>,
            <span class="s2">"FinishedAt"</span>: <span class="s2">"2020-04-25T18:23:25.347690066Z"</span>
        <span class="o">}</span>,
        <span class="s2">"Image"</span>: <span class="s2">"sha256:f70734b6a266dcb5f44c383274821207885b549b75c8e119404917a61335981a"</span>,
        ...생략...
    <span class="o">}</span>
<span class="o">]</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-제거">컨테이너 제거</h2>
<p>컨테이너를 제거하고 싶을 때는 <code class="language-plaintext highlighter-rouge">docker rm</code> 커맨드를 사용합니다. 중지되어 있는 컨테이너는 아무 옵션없이 제거할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 제거</span>
<span class="nv">$ </span>docker <span class="nb">rm </span>3722f14f4d2a
3722f14f4d2a

<span class="c"># 실행 중인 컨테이너는 다음과 같이 바로 제거가 허용되지 않습니다.</span>
<span class="c"># 이 때는, -f 옵션을 사용하면 해당 컨테이너를 먼저 정지시킨 다음에 제거해줍니다.</span>
<span class="nv">$ </span>docker <span class="nb">rm </span>d2f83048485e
Error response from daemon: You cannot remove a running container d2f83048485e4fe694dac374be152906e4e20da400305e5095bbb476bcaf718d. Stop the container before attempting removal or force remove
<span class="nv">$ </span>docker <span class="nb">rm</span> <span class="nt">-f</span> d2f83048485e

<span class="c"># 실행 중인 컨테이너는 건들지 않고 중지되어 있는 모든 컨테이너를 제거하고 싶다면 다음과 같이 하면 됩니다.</span>
<span class="nv">$ </span>docker <span class="nb">rm</span> <span class="si">$(</span>docker ps <span class="nt">-a</span> <span class="nt">-q</span><span class="si">)</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-레퍼런스-참고">컨테이너 레퍼런스 참고</h2>
<ul>
  <li><a href="https://docs.docker.com/engine/reference/run/" target="_blank">Docker run reference</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/run/" target="_blank">docker run</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/ps/" target="_blank">docker ps</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/stop/" target="_blank">docker stop</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/start/" target="_blank">docker start</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/exec/" target="_blank">docker exec</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/logs/" target="_blank">docker logs</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/attach/" target="_blank">docker attach</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/inspect/" target="_blank">docker inspect</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/rm/" target="_blank">docker rm</a>
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="-볼륨바인드-마운트-관련-명령어">🎯 볼륨/바인드 마운트 관련 명령어</h1>
<p>Docker 컨테이너(container)에 쓰여진 데이터는 기본적으로 컨테이너가 삭제될 때 함께 사라지게 됩니다. Docker에서 돌아가는 많은 애플리케이션이 컨테이너의 생명 주기와 관계없이 데이터를 영속적으로 저장을 해야하는 경우가 있습니다. 또한 여러 개의 Docker 컨테이너가 하나의 저장 공간을 공유해서 데이터를 읽거나 써야하는 경우도 있습니다.</p>

<p>이렇게 Docker 컨테이너의 생명 주기와 관계없이 데이터를 영속적으로 저장할 수 있도록 Docker는 두가지 옵션을 제공합니다. 첫번째는 Docker 볼륨(volume), 두번째는 바인드 마운트(bind mount)입니다.</p>

<p><img src="/assets/images/posts/docker/20230220/d1969bd2-2ec2-41d2-924e-38202359d740.png" alt="docker bind volume" />
<br /></p>

<h2 id="볼륨-생성">볼륨 생성</h2>
<p><code class="language-plaintext highlighter-rouge">docker volume create</code> 커맨드를 이용해서 볼륨을 생성할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume create our-vol
our-vol
</code></pre></div></div>
<p><br /></p>

<h2 id="볼륨-조회">볼륨 조회</h2>
<p><code class="language-plaintext highlighter-rouge">docker volume ls</code> 커맨드를 실행하면 볼륨을 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume <span class="nb">ls
</span>DRIVER              VOLUME NAME
<span class="nb">local               </span>our-vol
</code></pre></div></div>
<p><br /></p>

<h2 id="볼륨-상세-정보">볼륨 상세 정보</h2>
<p><code class="language-plaintext highlighter-rouge">docker volume inspect</code> 커맨드를 통해 해당 볼륨을 좀 더 상세한 정보를 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume inspect our-vol
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"CreatedAt"</span>: <span class="s2">"2020-05-09T17:03:46Z"</span>,
        <span class="s2">"Driver"</span>: <span class="s2">"local"</span>,
        <span class="s2">"Labels"</span>: <span class="o">{}</span>,
        <span class="s2">"Mountpoint"</span>: <span class="s2">"/var/lib/docker/volumes/our-vol/_data"</span>,
        <span class="s2">"Name"</span>: <span class="s2">"our-vol"</span>,
        <span class="s2">"Options"</span>: <span class="o">{}</span>,
        <span class="s2">"Scope"</span>: <span class="s2">"local"</span>
    <span class="o">}</span>
<span class="o">]</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">Mountpoint</code> 항목을 보면 해당 볼륨이 컴퓨터의 어느 경로에 생성되었는지를 알 수 있습니다.
<br /></p>

<h2 id="컨테이너에-볼륨-마운트">컨테이너에 볼륨 마운트</h2>
<p>컨테이너가 볼륨을 사용하기 위해서는 볼륨을 컨테이너에 마운트(mount)해줘야 합니다. <code class="language-plaintext highlighter-rouge">docker run</code> 커맨드로 컨테이너를 실행할 때 <code class="language-plaintext highlighter-rouge">-v</code> 옵션을 사용하여 마운트합니다. 콜론(<code class="language-plaintext highlighter-rouge">:</code>)을 구분자로 해서 앞에는 마운트할 볼륨명 뒤에는 컨테이너 내의 경로를 명시해주면 됩니다.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># `our-vol` 볼륨을 `one` 컨테이너의 `/app` 경로에 마운트, touch 명령어로 파일 생성</span>
<span class="nv">$ </span>docker run <span class="nt">-v</span> our-vol:/app <span class="nt">--name</span> one busybox <span class="nb">touch</span> /app/test.txt
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">touch /app/test.txt</code> 커맨드를 실행하였기 때문에, test.txt 파일이 our-vol 볼륨의 경로에도 남아있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> /var/lib/docker/volumes/our-vol/_data
test.txt
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">docker inspect</code> 커맨드로 컨테이너의 상세 정보를 확인해보면 our-vol 볼륨이 volume 타입으로 마운트되어 있는 것을 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker inspect one
...생략...
    <span class="s2">"Mounts"</span>: <span class="o">[</span>
        <span class="o">{</span>
            <span class="s2">"Type"</span>: <span class="s2">"volume"</span>,
            <span class="s2">"Name"</span>: <span class="s2">"our-vol"</span>,
            <span class="s2">"Source"</span>: <span class="s2">"/var/lib/docker/volumes/our-vol/_data"</span>,
            <span class="s2">"Destination"</span>: <span class="s2">"/app"</span>,
            <span class="s2">"Driver"</span>: <span class="s2">"local"</span>,
            <span class="s2">"Mode"</span>: <span class="s2">"z"</span>,
            <span class="s2">"RW"</span>: <span class="nb">true</span>,
            <span class="s2">"Propagation"</span>: <span class="s2">""</span>
        <span class="o">}</span>
    <span class="o">]</span>,
...생략...
</code></pre></div></div>
<p><br /></p>

<h2 id="다른-컨테이너에도-볼륨-마운트">다른 컨테이너에도 볼륨 마운트</h2>
<p>같은 our-vol 볼륨을 two 컨테이너의 /app 경로에 마운트를 해보겠습니다. ls /app 커맨드를 실행해보니, one 컨테이너가 볼륨에 생성해놓은 파일이 그대로 보이는 것을 알 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-v</span> our-vol:/app <span class="nt">--name</span> two busybox <span class="nb">ls</span> /app
test.txt
</code></pre></div></div>
<p>이렇게 <strong>여러 개의 컨테이너가 하나의 볼륨에 접근할 수 있기 때문에 컨테이너 간 데이터 공유가 가능</strong>합니다.
<br /></p>

<h2 id="볼륨-삭제">볼륨 삭제</h2>
<p><code class="language-plaintext highlighter-rouge">docker volume rm</code> 커맨드를 사용해서 볼륨을 제거할 수 있습니다. 만약 제거하려는 볼륨이 마운트되어 있는 컨테이너가 있을 때는 해당 볼륨이 제거가 되지가 않습니다. 그럴 때는 해당 볼륨이 마운트되어 있는 모든 컨테이너를 먼저 삭제하고, 볼륨을 삭제해야 합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 삭제</span>
<span class="nv">$ </span>docker <span class="nb">rm</span> <span class="nt">-f</span> one two
one
two

<span class="c"># 볼륨 삭제</span>
<span class="nv">$ </span>docker volume <span class="nb">rm </span>our-vol
our-vol
</code></pre></div></div>
<p><br /></p>

<h2 id="볼륨-청소">볼륨 청소</h2>
<p><code class="language-plaintext highlighter-rouge">docker volume prune</code> 커맨드를 이용해서 마운트되어 있지 않은 모든 볼륨을 한번에 제거할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker volume prune
WARNING! This will remove all <span class="nb">local </span>volumes not used by at least one container.
Are you sure you want to <span class="k">continue</span>? <span class="o">[</span>y/N] y
</code></pre></div></div>
<p><br /></p>

<h2 id="바인드-마운트">바인드 마운트</h2>
<p>Docker 컨테이너에 데이터를 저장하기 위한 다른 방법으로 바인드 마운트(bind mount)라는 것도 있습니다. 바인드 마운트를 사용하면 호스트 파일 시스템의 특정 경로를 컨테이너로 바로 마운트할 수 있습니다.</p>

<p>바인드 마운트를 사용하는 방법은 <code class="language-plaintext highlighter-rouge">docker run</code> 커맨드를 실행할 때, <code class="language-plaintext highlighter-rouge">-v</code> 옵션의 콜론(<code class="language-plaintext highlighter-rouge">:</code>) 앞 부분에 마운트명 대신에 호스트의 경로를 지정해주는 것입니다.</p>

<p>예를 들어, 현재 경로에 <code class="language-plaintext highlighter-rouge">test.txt</code> 파일을 생성하고, 해당 호스트 경로를 컨테이너의 <code class="language-plaintext highlighter-rouge">/app</code> 경로에 마운트합니다. 컨테이너에 터미널에 접속하여 <code class="language-plaintext highlighter-rouge">ls /app</code> 커맨드를 실행해보면 <code class="language-plaintext highlighter-rouge">test.txt</code> 파일이 존재하는 것을 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 파일 생성</span>
<span class="nv">$ </span><span class="nb">touch </span>test.txt

<span class="c"># 바인드 마운트, 컨테이너 쉘 접속</span>
<span class="nv">$ </span>docker run <span class="nt">-v</span> <span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>:/app <span class="nt">-it</span> <span class="nt">--name</span> one busybox /bin/bash

<span class="c"># 조회</span>
<span class="nv">$ </span><span class="nb">ls</span> /app
test.txt
</code></pre></div></div>
<p>반대로 컨테이너의 /app 경로 상에서 test2.txt 파일을 실행해보면 호스트의 현재 경로에서도 해당 파일을 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 내에서 파일 생성</span>
<span class="nv">$ </span><span class="nb">touch</span> /app/test2.txt

<span class="c"># 컨테이너 쉘 종료</span>
<span class="nv">$ </span><span class="nb">exit</span>

<span class="c"># 호스트에서 조회</span>
<span class="nv">$ </span><span class="nb">ls
</span>test.txt   test2.txt
</code></pre></div></div>
<p><br /></p>

<h2 id="볼륨-vs-바인드-마운트">볼륨 VS 바인드 마운트</h2>
<p>볼륨(volume)과 바인드 마운트(bind mount)의 가장 큰 차이점은 Docker의 해당 마운트 포인트 관리 여부입니다.</p>

<p>볼륨을 사용할 때는 우리가 스스로 볼륨을 생성하거나 삭제해야하는 불편함이 있지만, 해당 볼륨은 Docker 상에서 이미지(image)나 컨테이너(container), 네트워크(network)와 비슷한 방식으로 관리가 되는 이점이 있습니다. 그래서 대부분의 상황에서는 볼륨을 사용하는 것이 권장되지만 컨테이너화된 로컬 개발 환경을 구성할 때는 바인드 마운트가 더 유리할 수 있습니다.</p>

<p>로컬에서 개발을 할 때는 일반적으로 현재 작업 디렉터리에 프로젝트 저장소를 <code class="language-plaintext highlighter-rouge">git clone</code> 받아놓고 코드를 변경합니다. 따라서 바인드 마운트를 이용해서 해당 디렉터리를 컨테이너의 특정 경로에 마운트해주면 코드를 변경할 때 마다 변경 사항을 실시간으로 컨테이너를 통해 확인할 수 있습니다. 또한 컨테이너를 통해 변경된 부분도 현재 작업 디렉터리에서 바로 확인할 수 있기 때문에 편리합니다.
<br /></p>

<h2 id="볼륨-레퍼런스-참고">볼륨 레퍼런스 참고</h2>
<ul>
  <li><a href="https://docs.docker.com/engine/reference/commandline/volume_create/" target="_blank">docker volume create</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/" target="_blank">docker volume ls</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/" target="_blank">docker volume inspect</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/volume_rm/" target="_blank">docker volume rm</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/" target="_blank">docker volume prune</a>
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="-네트워크-관련-명령어">🎯 네트워크 관련 명령어</h1>
<p>Docker 컨테이너(container)는 격리된 환경에서 돌아가기 때문에 기본적으로 다른 컨테이너와의 통신이 불가능합니다. 하지만 여러 개의 컨테이너를 하나의 Docker 네트워크(network)에 연결시키면 서로 통신이 가능해집니다.</p>

<h2 id="네트워크-종류">네트워크 종류</h2>
<p>Docker 네트워크는 <code class="language-plaintext highlighter-rouge">bridge</code>, <code class="language-plaintext highlighter-rouge">host</code>, <code class="language-plaintext highlighter-rouge">overlay</code> 등 목적에 따라 다양한 종류의 네트워크 드라이버(driver)를 지원합니다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">bridge</code> 네트워크는 하나의 호스트 컴퓨터 내에서 여러 컨테이너들이 서로 소통할 수 있도록 해줍니다.</li>
  <li><code class="language-plaintext highlighter-rouge">host</code> 네트워크는 컨테이너를 호스트 컴퓨터와 동일한 네트워크에서 컨테이너를 돌리기 위해서 사용됩니다.</li>
  <li><code class="language-plaintext highlighter-rouge">overlay</code> 네트워크는 여러 호스트에 분산되어 돌아가는 컨테이너들 간에 네트워킹을 위해서 사용됩니다.<br />
<br /></li>
</ul>

<h2 id="네트워크-생성">네트워크 생성</h2>
<p><code class="language-plaintext highlighter-rouge">docker network create</code> 커맨드를 사용해서 Docker 네트워크를 생성할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network create our-net
e6dfe4a9a5ec85abcb484662c30a3a0fc76df217dde76d52fac39fae8412ca68
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크-조회">네트워크 조회</h2>
<p><code class="language-plaintext highlighter-rouge">docker network ls</code> 커맨드를 사용하면 현재 생성되어 있는 Docker 네트워크 목록을 조회할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network <span class="nb">ls
</span>NETWORK ID          NAME                DRIVER              SCOPE
143496b94e57        bridge              bridge              <span class="nb">local
</span>311d6534f79f        host                host                <span class="nb">local
</span>aa89f58200a6        none                null                <span class="nb">local</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크-상세-정보">네트워크 상세 정보</h2>
<p><code class="language-plaintext highlighter-rouge">docker network inspect</code> 커맨드로 네트워크의 상세 정보를 확인할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network inspect our-net
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크에-컨테이너-연결">네트워크에 컨테이너 연결</h2>
<p>먼저 컨테이너 하나를 <code class="language-plaintext highlighter-rouge">one</code> 라는 이름으로 실행해보도록 하겠습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-itd</span> <span class="nt">--name</span> one busybox
660bafdce2996378cde070dfd894731bb90745e46d2ab10d6504c0cc9f4bdea9
</code></pre></div></div>
<p>컨테이너를 실행할 때 <code class="language-plaintext highlighter-rouge">--network</code> 옵션을 명시해주지 않으면, 기본적으로 <code class="language-plaintext highlighter-rouge">bride</code> 라는 이름의 디폴트 네트워크에 붙게 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network inspect bridge
... 생략 ...
        <span class="s2">"Containers"</span>: <span class="o">{</span>
            <span class="s2">"660bafdce2996378cde070dfd894731bb90745e46d2ab10d6504c0cc9f4bdea9"</span>: <span class="o">{</span>
                <span class="s2">"Name"</span>: <span class="s2">"one"</span>,
                <span class="s2">"EndpointID"</span>: <span class="s2">"40b4bbd8385debf86eef2fc2136315e1a82fa1ef72877bfae25477d6e8e46726"</span>,
                <span class="s2">"MacAddress"</span>: <span class="s2">"02:42:ac:11:00:04"</span>,
                <span class="s2">"IPv4Address"</span>: <span class="s2">"172.17.0.4/16"</span>,
                <span class="s2">"IPv6Address"</span>: <span class="s2">""</span>
            <span class="o">}</span>,
        <span class="o">}</span>,
... 생략 ...
</code></pre></div></div>
<p><br /></p>

<p>이제 <code class="language-plaintext highlighter-rouge">one</code> 컨테이너와 <code class="language-plaintext highlighter-rouge">our-net</code> 네트워크를 연결해보도록 하겠습니다.<br />
Docker 네트워크에 컨테이너를 연결할 때는 <code class="language-plaintext highlighter-rouge">docker network connect</code> 커맨드를 사용합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network connect our-net one
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">our-net</code> 네트워크의 상세 정보를 다시 확인해보면 <code class="language-plaintext highlighter-rouge">Containers</code> 항목에 <code class="language-plaintext highlighter-rouge">one</code> 컨테이너가 추가된 것을 볼 수 있습니다. <code class="language-plaintext highlighter-rouge">one</code> 컨테이너에 IP <code class="language-plaintext highlighter-rouge">172.19.0.2</code>가 할당된 것도 확인할 수 있습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network inspect our-net
<span class="o">[</span>
    <span class="o">{</span>
        <span class="s2">"Name"</span>: <span class="s2">"our-net"</span>,
        <span class="s2">"Id"</span>: <span class="s2">"e6dfe4a9a5ec85abcb484662c30a3a0fc76df217dde76d52fac39fae8412ca68"</span>,
        <span class="s2">"Created"</span>: <span class="s2">"2020-04-26T19:23:04.563643516Z"</span>,
        <span class="s2">"Scope"</span>: <span class="s2">"local"</span>,
        <span class="s2">"Driver"</span>: <span class="s2">"bridge"</span>,
        <span class="s2">"EnableIPv6"</span>: <span class="nb">false</span>,
        <span class="s2">"IPAM"</span>: <span class="o">{</span>
            <span class="s2">"Driver"</span>: <span class="s2">"default"</span>,
            <span class="s2">"Options"</span>: <span class="o">{}</span>,
            <span class="s2">"Config"</span>: <span class="o">[</span>
                <span class="o">{</span>
                    <span class="s2">"Subnet"</span>: <span class="s2">"172.19.0.0/16"</span>,
                    <span class="s2">"Gateway"</span>: <span class="s2">"172.19.0.1"</span>
                <span class="o">}</span>
            <span class="o">]</span>
        <span class="o">}</span>,
        <span class="s2">"Internal"</span>: <span class="nb">false</span>,
        <span class="s2">"Attachable"</span>: <span class="nb">false</span>,
        <span class="s2">"Ingress"</span>: <span class="nb">false</span>,
        <span class="s2">"ConfigFrom"</span>: <span class="o">{</span>
            <span class="s2">"Network"</span>: <span class="s2">""</span>
        <span class="o">}</span>,
        <span class="s2">"ConfigOnly"</span>: <span class="nb">false</span>,
        <span class="s2">"Containers"</span>: <span class="o">{</span>
            <span class="s2">"660bafdce2996378cde070dfd894731bb90745e46d2ab10d6504c0cc9f4bdea9"</span>: <span class="o">{</span>
                <span class="s2">"Name"</span>: <span class="s2">"one"</span>,
                <span class="s2">"EndpointID"</span>: <span class="s2">"cc490148a533d40b3aff33a421cc9a01c731c75a8deb70ab729a5358f2fd381c"</span>,
                <span class="s2">"MacAddress"</span>: <span class="s2">"02:42:ac:13:00:02"</span>,
                <span class="s2">"IPv4Address"</span>: <span class="s2">"172.19.0.2/16"</span>,
                <span class="s2">"IPv6Address"</span>: <span class="s2">""</span>
            <span class="o">}</span>
        <span class="o">}</span>,
        <span class="s2">"Options"</span>: <span class="o">{}</span>,
        <span class="s2">"Labels"</span>: <span class="o">{}</span>
    <span class="o">}</span>
<span class="o">]</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크로부터-컨테이너-연결-해제">네트워크로부터 컨테이너 연결 해제</h2>
<p>하나의 컨테이너는 여러 개의 네트워크에 동시에 연결할 수 있습니다. 최초에 <code class="language-plaintext highlighter-rouge">one</code> 컨테이너를 생성할 때 <code class="language-plaintext highlighter-rouge">bridge</code> 네트워크 붙었기 때문에, 현재 <code class="language-plaintext highlighter-rouge">one</code> 컨테이너는 <code class="language-plaintext highlighter-rouge">our-net</code> 네트워크와 <code class="language-plaintext highlighter-rouge">bridge</code> 네트워크에 동시에 붙어있게 됩니다.</p>

<p><code class="language-plaintext highlighter-rouge">one</code> 컨테이너를 <code class="language-plaintext highlighter-rouge">bridge</code> 네트워크로부터 해제 하겠습니다. Docker 네트워크로부터 컨테이너의 연결을 끊을 때는 <code class="language-plaintext highlighter-rouge">docker network disconnect</code> 커맨드를 사용합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network disconnect bridge one
</code></pre></div></div>
<p><br /></p>

<h2 id="두번째-컨테이너-연결">두번째 컨테이너 연결</h2>
<p>하나의 컨테이너를 더 <code class="language-plaintext highlighter-rouge">our-net</code> 네트워크에 연결합니다. 이번에는 <code class="language-plaintext highlighter-rouge">--network</code> 옵션을 사용해서 컨테이너를 실행하면서 바로 연결할 네트워크를 지정해주도록 하겠습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker run <span class="nt">-itd</span> <span class="nt">--name</span> two <span class="nt">--network</span> our-net busybox
0e7fe8a59f9d3f8bd545d3e557ffd34100a09b8ebe92ae5a375f37a5d072873d
</code></pre></div></div>
<p><br /></p>

<h2 id="컨테이너-간-네트워킹">컨테이너 간 네트워킹</h2>
<p>컨테이너 이름을 호스트네임(hostname)처럼 사용할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker <span class="nb">exec </span>one ping two
PING two <span class="o">(</span>172.19.0.3<span class="o">)</span>: 56 data bytes
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>0 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.119 ms
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>1 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.105 ms
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>2 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.116 ms
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>3 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.883 ms
64 bytes from 172.19.0.3: <span class="nb">seq</span><span class="o">=</span>4 <span class="nv">ttl</span><span class="o">=</span>64 <span class="nb">time</span><span class="o">=</span>0.127 ms
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크-제거">네트워크 제거</h2>
<p><code class="language-plaintext highlighter-rouge">docker network rm</code> 커맨드를 사용해서 our-net 네트워크를 제거할 수 있습니다.</p>

<p>네트워크 상에서 실행중인 컨테이너가 있을 때는 제거가 되지 않습니다. 먼저 해당 네트워크에 연결되어 실행 중인 모든 컨테이너를 중지시키고, 네트워크를 삭제해야 합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 컨테이너 중지</span>
<span class="nv">$ </span>docker stop one two
one
two

<span class="c"># 네트워크 삭제</span>
<span class="nv">$ </span>docker network <span class="nb">rm </span>our-net
our-net
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크-청소">네트워크 청소</h2>
<p><code class="language-plaintext highlighter-rouge">docker network prune</code> 커맨드를 이용해서 불필요한 네트워크를 한번에 모두 제거할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker network prune
WARNING! This will remove all networks not used by at least one container.
Are you sure you want to <span class="k">continue</span>? <span class="o">[</span>y/N] y
</code></pre></div></div>
<p><br /></p>

<h2 id="네트워크-레퍼런스-참고">네트워크 레퍼런스 참고</h2>
<ul>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_ls/" target="_blank">docker network ls</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_create/" target="_blank">docker network create</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/" target="_blank">docker network inspect</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_connect/" target="_blank">docker network connect</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/" target="_blank">docker network disconnect</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_rm/" target="_blank">docker network rm</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/network_prune/" target="_blank">docker network prune</a>
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="-이미지-관련-명령어">🎯 이미지 관련 명령어</h1>
<p>Docker CLI 도구는 Docker 이미지(image)의 효과적인 관리를 위해서 다양한 커맨드(command)를 제공합니다.
<br /></p>

<h2 id="이미지-조회">이미지 조회</h2>
<p><code class="language-plaintext highlighter-rouge">docker images</code> 커맨드로 이미지를 조회할 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 이미지 조회</span>
<span class="nv">$ </span>docker images

<span class="c">## 특정 리파지토리(repository)에 해당하는 이미지만 필터링해서 보고 싶을 때는</span>
<span class="c">## 리파지토리를 인자로 넘겨주면 됩니다.</span>
<span class="nv">$ </span>docker images node
node                10-alpine           34a10d47f150        2 weeks ago         83.5MB
node                12-alpine           f77abbe89ac1        2 weeks ago         88.1MB

<span class="c"># 태그까지 인자로 넘기면 특정 이미지가 조회됩니다.</span>
<span class="nv">$ </span>docker images node:12-alpine
node                12-alpine           f77abbe89ac1        2 weeks ago         88.1MB
</code></pre></div></div>
<p><br /></p>

<h2 id="이미지-다운로드">이미지 다운로드</h2>
<p><code class="language-plaintext highlighter-rouge">docker pull</code> 커맨드를 이용하여 이미지를 다운로드 할 수 있습니다.</p>

<p><code class="language-plaintext highlighter-rouge">run</code> 명령어를 입력하면 이미지가 없을 때 자동으로 다운받으니 <code class="language-plaintext highlighter-rouge">pull</code> 명령어를 언제 쓰는지 궁금할 수 있는데 <code class="language-plaintext highlighter-rouge">pull</code>은 이미지를 최신버전으로 다시 다운 받습니다. 같은 태그지만 이미지가 업데이트 된 경우는 <code class="language-plaintext highlighter-rouge">pull</code> 명령어를 통해 이미지를 새로 다운받을 수 있습니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 이미지 다운</span>
<span class="nv">$ </span>docker pull ubuntu:14.04
</code></pre></div></div>
<p><br /></p>

<h2 id="이미지-빌드">이미지 빌드</h2>
<p><code class="language-plaintext highlighter-rouge">docker build</code> 커맨드는 Docker 이미지를 빌드(build)할 때 사용됩니다.</p>

<p>Docker 데몬이 이미지를 빌드하려면 소위 컨텍스트(context)라고도 불리는 Dockerfile을 담고 있는 디렉터리가 필요합니다. Dockerfile은 보통 같은 디렉터리 안에 있는 설정 파일이나 소스 코드를 이용해서 이미지의 빌드 절차를 정의합니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 현재 작업 디렉터리 기준 이미지 빌드</span>
<span class="nv">$ </span>docker build <span class="nb">.</span>

<span class="c"># 네트워크 상의 Git repository 주소나 압축 파일 빌드</span>
<span class="nv">$ </span>docker build github.com/creack/docker-firefox

<span class="c"># -t 옵션을 사용하여 Docker 이미지에 태그(tag)를 설정</span>
<span class="c">## 태그는 리파지토리(repository):태그(tag) 형태로 지정이 가능하며</span>
<span class="c">## 태그 부분을 생략하면 latest가 태그가 됩니다.</span>
<span class="nv">$ </span>docker build <span class="nt">-t</span> <span class="nb">test</span>:1.0 <span class="nb">.</span>

<span class="c"># -f 옵션을 사용하면 디폴트인 Dockerfile 대신에 다른 파일로 부터 Docker 이미지를 빌드</span>
<span class="nv">$ </span>docker build <span class="nt">-f</span> Dockerfile.dev <span class="nb">.</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="이미지-태깅">이미지 태깅</h2>
<p>이미지 태깅은 이미지를 빌드 한 후에 별도로 해줄 수도 있는데, 이 때 <code class="language-plaintext highlighter-rouge">docker tag</code> 커맨드를 사용합니다. 첫번째 인자로 이미지ID, 두번째 인자로 리파지토리 또는 태그까지 넘겨주면 됩니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>docker tag 8bae72379b48 <span class="nb">test</span>:2.0
</code></pre></div></div>
<p><br /></p>

<h2 id="이미지-삭제">이미지 삭제</h2>
<p><code class="language-plaintext highlighter-rouge">docker rmi</code> 커맨드로 Docker 이미지를 삭제할 수 있습니다. 삭제하려는 이미지의 ID나 태그를 인자로 넘겨주면 해당 이미지가 삭제가 됩니다.</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 이미지 삭제</span>
<span class="nv">$ </span>docker rmi f77abbe89ac1
<span class="nv">$ </span>docker rmi node:12-alpine

<span class="c"># 이미지 조회</span>
<span class="nv">$ </span>docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
test2               latest              8bae72379b48        56 minutes ago      5.6MB
<span class="nb">test                </span>latest              8bae72379b48        56 minutes ago      5.6MB

<span class="c"># -f 옵션을 주고 이미지 ID를 인자로 넘기면 이미지 삭제</span>
<span class="nv">$ </span>docker rmi <span class="nt">-f</span> 8bae72379b48
Untagged: test2:latest
Untagged: <span class="nb">test</span>:latest
Deleted: sha256:8bae72379b4

<span class="c"># 사용하지 않는 이미지 전체 삭제</span>
<span class="nv">$ </span>docker rmi <span class="si">$(</span>docker images <span class="nt">-q</span><span class="si">)</span> <span class="nt">-f</span>
</code></pre></div></div>
<p><br /></p>

<h2 id="이미지-레퍼런스-참고">이미지 레퍼런스 참고</h2>
<ul>
  <li><a href="https://docs.docker.com/engine/reference/commandline/images/" target="_blank">docker images</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank">docker build</a></li>
  <li><a href="https://docs.docker.com/engine/reference/commandline/rmi/" target="_blank">docker rmi</a>
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h1>
<ul>
  <li><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank">https://subicura.com</a></li>
  <li><a href="https://www.daleseo.com/?tag=Docker" target="_blank">https://www.daleseo.com</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Docker" /><category term="Docker" /><category term="Container" /><summary type="html"><![CDATA[💾 도커에서 자주 사용하는 명령어를 정리한 내용입니다.]]></summary></entry><entry><title type="html">🐳 Docker 살펴보기</title><link href="http://localhost:4000/docker/docker-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/" rel="alternate" type="text/html" title="🐳 Docker 살펴보기" /><published>2023-02-16T00:00:00+09:00</published><updated>2023-02-16T00:00:00+09:00</updated><id>http://localhost:4000/docker/docker-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/docker/docker-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/"><![CDATA[<p>💾 도커 기본 개념을 정리한 내용입니다.</p>

<p><br /></p>

<h1 id="-도커란">🤔 도커란?</h1>
<p>도커는 <span class="danger-color">컨테이너 기반의 오픈소스 가상화 플랫폼</span>입니다.</p>

<h2 id="컨테이너container">컨테이너(Container)</h2>
<p>컨테이너는 격리된 공간에서 프로세스가 동작하는 기술입니다. 가상화 기술의 하나지만 기존방식과는 차이가 있습니다.</p>

<p>기존의 가상화 방식은 주로 <strong>OS를 가상화</strong> 하였습니다. <strong>VMware나 VirtualBox같은 가상머신은 호스트 OS위에 게스트 OS 전체를 가상화하여 사용하는 방식</strong>입니다. 이 방식은 여러가지 OS를 가상화(리눅스에서 윈도우를 돌린다던가) 할 수 있고 비교적 사용법이 간단하지만 <strong>무겁고 느려서</strong> 운영환경에선 사용할 수 없었습니다.</p>

<p><img src="/assets/images/posts/docker/20230216/d1969bd2-2ec2-41d2-924e-38202359d727.png" alt="vm_docker" /></p>

<p>OS 가상화는 성능문제가 있었고 이를 개선하기 위해 <strong>프로세스를 격리</strong> 하는 방식이 등장합니다.</p>

<p><strong>리눅스에서는 이 방식을 리눅스 컨테이너라고 하고 단순히 프로세스를 격리시키기 때문에 가볍고 빠르게 동작합니다. CPU나 메모리는 딱 프로세스가 필요한 만큼만 추가로 사용하고 성능적으로도 거의 손실이 없습니다.</strong></p>

<p>하나의 서버에 여러개의 컨테이너를 실행하면 서로 영향을 미치지 않고 독립적으로 실행되어 마치 가벼운 Virtual Machine을 사용하는 느낌을 줍니다.
<br />
<br />
<br /></p>

<h2 id="이미지image">이미지(Image)</h2>
<p>도커에서 가장 중요한 개념은 컨테이너와 함께 이미지라는 개념입니다.</p>

<p><img src="/assets/images/posts/docker/20230216/d1969bd2-2ec2-41d2-924e-38202359d722.png" alt="docker image" /></p>

<p><strong>이미지는 컨테이너 실행에 필요한 파일과 설정값등을 포함하고 있는 것</strong>으로 상태값을 가지지 않고 변하지 않습니다.(Immutable)</p>

<p>컨테이너는 이미지를 실행한 상태라고 볼 수 있고 추가되거나 변하는 값은 컨테이너에 저장됩니다. 같은 이미지에서 여러개의 컨테이너를 생성할 수 있고 컨테이너의 상태가 바뀌거나 컨테이너가 삭제되더라도 이미지는 변하지 않고 그대로 남아있습니다.</p>

<p>ubuntu 이미지는 ubuntu를 실행하기 위한 모든 파일을 가지고 있고 MySQL 이미지는 debian을 기반으로 MySQL을 실행하는데 필요한 파일과 실행 명령어, 포트 정보등을 가지고 있습니다.</p>

<p>말그대로 <strong>이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 더 이상 의존성 파일을 컴파일하고 이것저것 설치할 필요가 없습니다.</strong> 이제 새로운 서버가 추가되면 미리 만들어 놓은 이미지를 다운받고 컨테이너를 생성만 하면 됩니다.</p>

<p><strong>도커 이미지는 <a href="https://hub.docker.com/search?q=" target="_blank">Docker hub</a>에 등록하거나 Docker Registry 저장소를 직접 만들어 관리할 수 있습니다.</strong>
<br />
<br />
<br />
<br />
<br /></p>

<h1 id="-특징">🎯 특징</h1>
<h2 id="레이어layer-저장방식">레이어(Layer) 저장방식</h2>
<p>도커 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 보통 용량이 수백MB에 이릅니다. 처음 이미지를 다운받을 땐 크게 부담이 안되지만 기존 이미지에 파일 하나 추가했다고 수백MB를 다시 다운받는다면 매우 비효율적일 수 밖에 없습니다.</p>

<p><img src="/assets/images/posts/docker/20230216/d1969bd2-2ec2-41d2-924e-38202359d728.png" alt="docker layer" /></p>

<p>도커는 이런 문제를 해결하기 위해 레이어라는 개념을 사용하고 유니온 파일 시스템을 이용하여 여러개의 레이어를 하나의 파일시스템으로 사용할 수 있게 해줍니다. 이미지는 여러개의 읽기 전용 레이어로 구성되고 파일이 추가되거나 수정되면 새로운 레이어가 생성됩니다.</p>

<p>ubuntu 이미지가 A + B + C의 집합이라면, ubuntu 이미지를 베이스로 만든 nginx 이미지는 A + B + C + nginx가 됩니다.</p>

<p>webapp 이미지를 nginx 이미지 기반으로 만들었다면 A + B + C + nginx + source 레이어로 구성됩니다.</p>

<p>webapp 소스를 수정하면 A, B, C, nginx 레이어를 제외한 새로운 source(v2) 레이어만 다운받으면 되기 때문에 굉장히 효율적으로 이미지를 관리할 수 있습니다.
<br />
<br />
<br /></p>

<h2 id="이미지-경로">이미지 경로</h2>
<p><img src="/assets/images/posts/docker/20230216/d1969bd2-2ec2-41d2-924e-38202359d729.png" alt="docker layer" /></p>

<p>이미지는 url 방식으로 관리하며 태그를 붙일 수 있습니다.</p>

<p>ubuntu 14.04 이미지는 <strong>docker.io/library/ubuntu:14.04</strong> 또는 <strong>docker.io/libray/ubuntu:trusty</strong> 이고 <strong>docker.io/library</strong> 는 <strong>생략 가능</strong>하며 <strong>ubuntu:14.04</strong>로 사용할 수 있습니다.</p>

<p>이러한 방식은 이해하기 쉽고 편리하게 사용할 수 있으며 태그 기능을 잘 이용하면 테스트나 롤백도 쉽게 할 수 있습니다.
<br />
<br />
<br /></p>

<h2 id="dockerfile">Dockerfile</h2>
<div class="language-dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> subicura/vertx3:3.3.1</span>
<span class="k">MAINTAINER</span><span class="s"> chungsub.kim@purpleworks.co.kr</span>

<span class="k">ADD</span><span class="s"> build/distributions/app-3.3.1.tar /</span>
<span class="k">ADD</span><span class="s"> config.template.json /app-3.3.1/bin/config.json</span>
<span class="k">ADD</span><span class="s"> docker/script/start.sh /usr/local/bin/</span>
<span class="k">RUN </span><span class="nb">ln</span> <span class="nt">-s</span> /usr/local/bin/start.sh /start.sh

<span class="k">EXPOSE</span><span class="s"> 8080</span>
<span class="k">EXPOSE</span><span class="s"> 7000</span>

<span class="k">CMD</span><span class="s"> ["start.sh"]</span>
</code></pre></div></div>
<p>도커는 이미지를 만들기 <code class="language-plaintext highlighter-rouge">위해 Dockerfile</code> 이라는 파일에 자체 <code class="language-plaintext highlighter-rouge">DSLDomain-specific language</code> 언어를 이용하여 이미지 생성 과정을 작성합니다.
<br />
<br />
<br /></p>

<h2 id="docker-hub">Docker Hub</h2>
<p>도커 이미지의 용량은 보통 수백 MB이고, 수 GB가 넘는 경우도 흔합니다. 이렇게 큰 용량의 이미지를 서버에 저장하고 관리하는 것은 쉽지 않은데 도커는 <a href="https://hub.docker.com/search?q=" target="_blank">Docker hub</a>를 통해 공개 이미지를 무료로 관리해 줍니다. 
<br />
<br />
<br /></p>

<h2 id="command와-api">Command와 API</h2>
<p>도커 클라이언트의 커맨드 명령어는 직관적이고 사용하기 쉬우며 컨테이너의 복잡한 시스템 구성을 이해하지 못하더라도 편하게 사용할 수 있습니다. 또한 http기반의 Rest API도 지원하여 확장성이 굉장히 좋습니다.
<br />
<br />
<br /></p>

<h2 id="훌륭한-생태계">훌륭한 생태계</h2>
<p>도커는 굉장히 큰 생태계를 가지고 있고 커다란 기업과 협력하여 사실상 클라우드 컨테이너 세계의 기준이 되었습니다. 로깅, 모니터링, 스토리지, 네트워크, 컨테이너 관리, 배포등 다양한 분야에서 다양한 툴들이 존재합니다.
<br />
<br />
<br /></p>

<h2 id="커뮤니티-지원">커뮤니티 지원</h2>
<p>도커는 홍보와 커뮤니티 관리에 굉장히 신경쓰고 있습니다. 홈페이지에서는 전세계에서 열리는 밋업 상황을 볼 수 있고 일주일마다 발송되는 뉴스레터에는 다양한 개발자들의 글이 실려있습니다.
<br />
<br />
<br />
<br />
<br /></p>

<h1 id="-도커-구조">🎯 도커 구조</h1>
<p>도커는 클라이언트-서버 구조를 사용합니다.
<img src="/assets/images/posts/docker/20230216/d1969bd2-2ec2-41d2-924e-38202359d730.png" alt="도커 구조" /></p>

<h2 id="docker-daemon">Docker Daemon</h2>
<p>도커 데몬(<code class="language-plaintext highlighter-rouge">dockerd</code>)은 도커 REST API 요청을 듣고 도커 오브젝트들(이미지, 컨테이너, 네트워크, 볼륨)을 관리합니다. 또한 도커 데몬은 도커 서비스를 관리하는 다른 도커 데몬과 커뮤니케이션할 수 있습니다.
<br />
<br /></p>

<h2 id="docker-client">Docker Client</h2>
<p>도커 클라이언트(<code class="language-plaintext highlighter-rouge">docker</code>)는 도커 호스트와 통신하기 위한 기능을 수행합니다. 예를 들어, docker run 명령어를 실행하면 도커 클라이언트는 해당 명령어를 REST API Call으로 변환하여 도커 데몬(<code class="language-plaintext highlighter-rouge">dockerd</code>)으로 전송합니다.</p>

<p>도커 클라이언트의 주요 목적은 직접 레지스트리에서 이미지를 받아 호스트에서 실행할 수 있게 하는 것입니다.
<br />
<br /></p>

<h2 id="docker-registries">Docker Registries</h2>
<p>Docker Registries는 도커 이미지 저장소 역할을 수행합니다.
<br />
<br /></p>

<h2 id="docker-objects">Docker Objects</h2>
<p>Docker Object는 Docker Daemon에 의해, 생성 및 관리되는 이미지, 컨테이너, 네트워크, 볼륨 등의 개체를 말합니다.
<br />
<br />
<br />
<br />
<br /></p>

<h1 id="-도커-설치">🐳 도커 설치</h1>
<p>각 OS별 설치 방법은 다음 링크에서 확인 가능합니다.</p>
<ul>
  <li><a href="https://docs.docker.com/desktop/mac/install/" target="_blank">MacOS에서 도커 설치</a></li>
  <li><a href="https://docs.docker.com/desktop/linux/install/" target="_blank">Linux에서 도커 설치</a></li>
  <li><a href="https://docs.docker.com/desktop/windows/install/" target="_blank">Windows에서 도커 설치</a>
<br />
<br />
<br />
<br />
<br /></li>
</ul>

<h1 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h1>
<ul>
  <li><a href="https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html" target="_blank">https://subicura.com</a></li>
  <li><a href="https://www.daleseo.com/?tag=Docker" target="_blank">https://www.daleseo.com</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Docker" /><category term="Docker" /><category term="Container" /><summary type="html"><![CDATA[💾 도커 기본 개념을 정리한 내용입니다.]]></summary></entry><entry><title type="html">Spring Boot Test Cheat Sheet</title><link href="http://localhost:4000/spring/spring-boot-test-cheat-sheet/" rel="alternate" type="text/html" title="Spring Boot Test Cheat Sheet" /><published>2023-02-13T00:00:00+09:00</published><updated>2023-02-13T00:00:00+09:00</updated><id>http://localhost:4000/spring/spring-boot-test-cheat-sheet</id><content type="html" xml:base="http://localhost:4000/spring/spring-boot-test-cheat-sheet/"><![CDATA[<p>📝 Spring Boot Test Cheat Sheet 입니다. 설명은 없고 자주 사용하는 테스트 코드 참고용 입니다.</p>
<ul>
  <li><a href="/java/TDD(Test-Driven-Development)-테스트-주도-개발" target="_blank">JUnit 5, AssertJ Cheat Sheet</a></li>
</ul>

<p><br /></p>

<h2 id="buildgradle">build.gradle</h2>
<div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dependencies</span> <span class="o">{</span>
    <span class="n">runtimeOnly</span> <span class="s1">'com.h2database:h2'</span>
    <span class="n">implementation</span> <span class="s1">'com.google.guava:guava:31.1-jre'</span>
    <span class="n">testImplementation</span> <span class="s1">'org.springframework.boot:spring-boot-starter-test'</span>
    <span class="n">testImplementation</span> <span class="s1">'io.rest-assured:rest-assured'</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="application-testyml">application-test.yml</h2>
<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">spring</span><span class="pi">:</span>
  <span class="na">datasource</span><span class="pi">:</span>
    <span class="na">url</span><span class="pi">:</span> <span class="s">jdbc:h2:mem:test</span>
    <span class="na">username</span><span class="pi">:</span> <span class="s">sa</span>
    <span class="na">password</span><span class="pi">:</span>
    <span class="na">driver-class-name</span><span class="pi">:</span> <span class="s">org.h2.Driver</span>
  <span class="na">jpa</span><span class="pi">:</span>
    <span class="na">hibernate</span><span class="pi">:</span>
      <span class="na">ddl-auto</span><span class="pi">:</span> <span class="s1">'</span><span class="s">create-drop'</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="import">import</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">hamcrest</span><span class="o">.</span><span class="na">Matchers</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">junit</span><span class="o">.</span><span class="na">jupiter</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">assertj</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">api</span><span class="o">.</span><span class="na">Assertions</span><span class="o">.*;</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="databasecleanup">DatabaseCleanup</h2>
<p>JPA용, 애플리케이션 내 모든 엔티티 테이블 초기화 클래스</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="nd">@ActiveProfiles</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DatabaseCleanup</span> <span class="kd">implements</span> <span class="nc">InitializingBean</span> <span class="o">{</span>
    <span class="nd">@PersistenceContext</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">entityManager</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">tableNames</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">tableNames</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">getMetamodel</span><span class="o">().</span><span class="na">getEntities</span><span class="o">().</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="o">.</span><span class="na">getJavaType</span><span class="o">().</span><span class="na">getAnnotation</span><span class="o">(</span><span class="nc">Entity</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="nc">CaseFormat</span><span class="o">.</span><span class="na">UPPER_CAMEL</span><span class="o">.</span><span class="na">to</span><span class="o">(</span><span class="nc">CaseFormat</span><span class="o">.</span><span class="na">LOWER_UNDERSCORE</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">entityManager</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">entityManager</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="s">"SET REFERENTIAL_INTEGRITY FALSE"</span><span class="o">).</span><span class="na">executeUpdate</span><span class="o">();</span>

        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">tableName</span> <span class="o">:</span> <span class="n">tableNames</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">entityManager</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="s">"TRUNCATE TABLE "</span> <span class="o">+</span> <span class="n">tableName</span><span class="o">).</span><span class="na">executeUpdate</span><span class="o">();</span>
            <span class="n">entityManager</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="s">"ALTER TABLE "</span> <span class="o">+</span> <span class="n">tableName</span> <span class="o">+</span> <span class="s">" ALTER COLUMN ID RESTART WITH 1"</span><span class="o">).</span><span class="na">executeUpdate</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="n">entityManager</span><span class="o">.</span><span class="na">createNativeQuery</span><span class="o">(</span><span class="s">"SET REFERENTIAL_INTEGRITY TRUE"</span><span class="o">).</span><span class="na">executeUpdate</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="acceptance-abstract">Acceptance Abstract</h2>
<p>RestAssured 사용시 공통 부모 클래스. 랜덤포트와 테이블 초기화</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span><span class="o">(</span><span class="n">webEnvironment</span> <span class="o">=</span> <span class="nc">SpringBootTest</span><span class="o">.</span><span class="na">WebEnvironment</span><span class="o">.</span><span class="na">RANDOM_PORT</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AcceptanceTest</span> <span class="o">{</span>

    <span class="nd">@LocalServerPort</span>
    <span class="kt">int</span> <span class="n">port</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">DatabaseCleanup</span> <span class="n">databaseCleanup</span><span class="o">;</span>

    <span class="nd">@BeforeEach</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">RestAssured</span><span class="o">.</span><span class="na">port</span> <span class="o">=</span> <span class="n">port</span><span class="o">;</span>
        <span class="n">databaseCleanup</span><span class="o">.</span><span class="na">execute</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="restassured">RestAssured</h2>
<ul>
  <li><a href="https://github.com/rest-assured/rest-assured/wiki/Usage" target="_blank">RestAssured 가이드</a></li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExtractableResponse</span><span class="o">&lt;</span><span class="nc">Response</span><span class="o">&gt;</span> <span class="n">자동차_등록_요청</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">params</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">params</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"name"</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>

    <span class="k">return</span> <span class="nc">RestAssured</span>
            <span class="o">.</span><span class="na">given</span><span class="o">().</span><span class="na">log</span><span class="o">().</span><span class="na">all</span><span class="o">()</span>
            <span class="o">.</span><span class="na">body</span><span class="o">(</span><span class="n">params</span><span class="o">)</span>
            <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON_VALUE</span><span class="o">)</span>
            <span class="o">.</span><span class="na">when</span><span class="o">().</span><span class="na">post</span><span class="o">(</span><span class="s">"/api/cars"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">then</span><span class="o">().</span><span class="na">log</span><span class="o">().</span><span class="na">all</span><span class="o">()</span>
            <span class="o">.</span><span class="na">extract</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">자동차_등록됨</span><span class="o">(</span><span class="nc">ExtractableResponse</span><span class="o">&lt;</span><span class="nc">Response</span><span class="o">&gt;</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">statusCode</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="nc">HttpStatus</span><span class="o">.</span><span class="na">CREATED</span><span class="o">.</span><span class="na">value</span><span class="o">());</span>
    <span class="n">assertThat</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="s">"Location"</span><span class="o">)).</span><span class="na">isNotBlank</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExtractableResponse</span><span class="o">&lt;</span><span class="nc">Response</span><span class="o">&gt;</span> <span class="n">정보_조회_요청</span><span class="o">(</span><span class="nc">String</span> <span class="n">accessToken</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">RestAssured</span>
            <span class="o">.</span><span class="na">given</span><span class="o">().</span><span class="na">log</span><span class="o">().</span><span class="na">all</span><span class="o">()</span>
            <span class="o">.</span><span class="na">auth</span><span class="o">().</span><span class="na">oauth2</span><span class="o">(</span><span class="n">accessToken</span><span class="o">)</span>
            <span class="o">.</span><span class="na">when</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="s">"/members/me"</span><span class="o">)</span>
            <span class="o">.</span><span class="na">then</span><span class="o">().</span><span class="na">log</span><span class="o">().</span><span class="na">all</span><span class="o">()</span>
            <span class="o">.</span><span class="na">extract</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="extendwithspringextensionclass-mockbean">@ExtendWith(SpringExtension.class), @MockBean</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">SpringExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringExtensionTest</span> <span class="o">{</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">LineRepository</span> <span class="n">lineRepository</span><span class="o">;</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">StationService</span> <span class="n">stationService</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kt">void</span> <span class="nf">findAllLines</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// given</span>
        <span class="n">when</span><span class="o">(</span><span class="n">lineRepository</span><span class="o">.</span><span class="na">findAll</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Lists</span><span class="o">.</span><span class="na">newArrayList</span><span class="o">(</span><span class="k">new</span> <span class="nc">Line</span><span class="o">()));</span>
        <span class="nc">LineService</span> <span class="n">lineService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LineService</span><span class="o">(</span><span class="n">lineRepository</span><span class="o">,</span> <span class="n">stationService</span><span class="o">);</span>

        <span class="c1">// when</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">LineResponse</span><span class="o">&gt;</span> <span class="n">responses</span> <span class="o">=</span> <span class="n">lineService</span><span class="o">.</span><span class="na">findLineResponses</span><span class="o">();</span>

        <span class="c1">// then</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">responses</span><span class="o">).</span><span class="na">hasSize</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="extendwithmockitoextensionclass-mock-injectmocks">@ExtendWith(MockitoExtension.class), @Mock, @InjectMocks</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MockitoExtensionTest</span> <span class="o">{</span>

    <span class="nd">@Mock</span>
    <span class="kd">private</span> <span class="nc">CarRepository</span> <span class="n">carRepository</span><span class="o">;</span>

    <span class="nd">@InjectMocks</span>
    <span class="kd">private</span> <span class="nc">CarService</span> <span class="n">carService</span><span class="o">;</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"이름을 받아 자동차를 저장한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(){</span>
        <span class="c1">// given</span>
        <span class="kd">final</span> <span class="nc">String</span> <span class="no">NAME</span> <span class="o">=</span> <span class="s">"Boong-Boong"</span><span class="o">;</span>
        <span class="n">when</span><span class="o">(</span><span class="n">carRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">any</span><span class="o">())).</span><span class="na">thenReturn</span><span class="o">(</span><span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="no">NAME</span><span class="o">)));</span>
        
        <span class="c1">// when</span>
        <span class="nc">CarResponse</span> <span class="n">carResponse</span> <span class="o">=</span> <span class="n">carService</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="no">NAME</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">carResponse</span><span class="o">.</span><span class="na">getName</span><span class="o">()).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="no">NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="webmvctest-mockbean-mockmvc">@WebMvcTest, @MockBean, MockMvc</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@WebMvcTest</span><span class="o">(</span><span class="nc">CarController</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CarControllerTest</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">API_BASE_PATH</span> <span class="o">=</span> <span class="s">"/api/cars"</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@MockBean</span>
    <span class="kd">private</span> <span class="nc">CarService</span> <span class="n">carService</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"자동차를 생성한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createCar</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">//given</span>
        <span class="nc">CarRequest</span> <span class="n">carRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">carRequest</span><span class="o">(</span><span class="s">"Boong-Boong"</span><span class="o">);</span>
        <span class="nc">CarResponse</span> <span class="n">carResponse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CarResponse</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">carRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="n">given</span><span class="o">(</span><span class="n">carService</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">any</span><span class="o">())).</span><span class="na">willReturn</span><span class="o">(</span><span class="n">carResponse</span><span class="o">);</span>

        <span class="c1">//when, then</span>
        <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">post</span><span class="o">(</span><span class="no">API_BASE_PATH</span><span class="o">)</span>
                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">carRequest</span><span class="o">))</span>
                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isCreated</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.id"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">carResponse</span><span class="o">.</span><span class="na">getId</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="springboottest-autoconfiguremockmvc-mockmvc">@SpringBootTest, @AutoConfigureMockMvc, MockMvc</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@SpringBootTest</span>
<span class="nd">@AutoConfigureMockMvc</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CarControllerMockTest</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">API_BASE_PATH</span> <span class="o">=</span> <span class="s">"/api/cars"</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">MockMvc</span> <span class="n">mockMvc</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>

    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"자동차를 생성한다."</span><span class="o">)</span>
    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createCar</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="c1">//given</span>
        <span class="nc">CarRequest</span> <span class="n">carRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">carRequest</span><span class="o">(</span><span class="s">"Boong-Boong"</span><span class="o">);</span>
        <span class="nc">CarResponse</span> <span class="n">carResponse</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CarResponse</span><span class="o">(</span><span class="mi">1L</span><span class="o">,</span> <span class="n">carRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>

        <span class="c1">//when, then</span>
        <span class="n">mockMvc</span><span class="o">.</span><span class="na">perform</span><span class="o">(</span><span class="n">post</span><span class="o">(</span><span class="no">API_BASE_PATH</span><span class="o">)</span>
                <span class="o">.</span><span class="na">content</span><span class="o">(</span><span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">carRequest</span><span class="o">))</span>
                <span class="o">.</span><span class="na">contentType</span><span class="o">(</span><span class="nc">MediaType</span><span class="o">.</span><span class="na">APPLICATION_JSON</span><span class="o">))</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">status</span><span class="o">().</span><span class="na">isCreated</span><span class="o">())</span>
                <span class="o">.</span><span class="na">andExpect</span><span class="o">(</span><span class="n">jsonPath</span><span class="o">(</span><span class="s">"$.id"</span><span class="o">).</span><span class="na">value</span><span class="o">(</span><span class="n">carResponse</span><span class="o">.</span><span class="na">getId</span><span class="o">()));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="datajpatest-persistencecontext">@DataJpaTest, @PersistenceContext</h2>
<ul>
  <li>JPA 관련 설정만 로드</li>
  <li>데이터 소스, 엔티티 매니저 등 생성</li>
  <li>@Entity 어노테이션이 붙은 클래스 및 Spring Data JPA 에 대한 설정들 적용</li>
  <li>기본으로 in-memory database 사용</li>
  <li>@AutoConfigureTestDatabase를 사용하여 어떤 database를 연결할지 선택할 수 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@DataJpaTest</span>
<span class="nd">@ActiveProfiles</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
<span class="nd">@AutoConfigureTestDatabase</span><span class="o">(</span><span class="n">replace</span> <span class="o">=</span> <span class="nc">AutoConfigureTestDatabase</span><span class="o">.</span><span class="na">Replace</span><span class="o">.</span><span class="na">NONE</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">CarRepositoryTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">CarRepository</span> <span class="n">carRepository</span><span class="o">;</span>

    <span class="nd">@PersistenceContext</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">entityManager</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="nd">@DisplayName</span><span class="o">(</span><span class="s">"자동차를 저장한다."</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">()</span> <span class="o">{</span>
        
        <span class="o">...</span>

        <span class="nc">Car</span> <span class="n">savedCar</span> <span class="o">=</span> <span class="n">carRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="s">"Boong-Boong"</span><span class="o">));</span>

        <span class="n">entityManager</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">entityManager</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
        
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="mybatistest">@MybatisTest</h2>
<ul>
  <li><a href="http://mybatis.org/spring-boot-starter/mybatis-spring-boot-test-autoconfigure/index.html" target="_blank">Mybatis 테스트 가이드</a></li>
  <li>기본으로 in-memory database 사용</li>
  <li>@AutoConfigureTestDatabase를 사용하여 어떤 database를 연결할지 선택할 수 있다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">SpringExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@MybatisTest</span>
<span class="nd">@ActiveProfiles</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
<span class="nd">@AutoConfigureTestDatabase</span><span class="o">(</span><span class="n">replace</span> <span class="o">=</span> <span class="nc">AutoConfigureTestDatabase</span><span class="o">.</span><span class="na">Replace</span><span class="o">.</span><span class="na">NONE</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderTest</span> <span class="o">{</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">OrderMapper</span> <span class="n">orderMapper</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">mybatis_test</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>

        <span class="c1">// given</span>
        <span class="nc">String</span> <span class="n">seq</span> <span class="o">=</span> <span class="s">"1"</span><span class="o">;</span>

        <span class="c1">// when</span>
        <span class="nc">OrderVO</span> <span class="n">vo</span> <span class="o">=</span> <span class="n">orderMapper</span><span class="o">.</span><span class="na">getOrder</span><span class="o">(</span><span class="n">seq</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="n">assertThat</span><span class="o">(</span><span class="n">vo</span><span class="o">.</span><span class="na">getSeq</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="s">"1"</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="mock-mockbean-차이점">@Mock, @MockBean 차이점</h2>

<table>
  <thead>
    <tr>
      <th>Mock 종류</th>
      <th>의존성 주입 대상</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>@Mock</td>
      <td>@InjectMocks</td>
    </tr>
    <tr>
      <td>@MockBean</td>
      <td>Spring Context</td>
    </tr>
  </tbody>
</table>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@Mock</code>은 <code class="language-plaintext highlighter-rouge">@InjectMocks</code>에 대해서만 해당 클래스안에서 정의된 객체를 찾아서 의존성을 해결</li>
  <li><code class="language-plaintext highlighter-rouge">@MockBean</code>은 <code class="language-plaintext highlighter-rouge">mock</code> 객체를 스프링 컨텍스트에 등록<br />
<br />
<br /></li>
</ul>

<h2 id="mockmvc-주입방법">MockMVC 주입방법</h2>
<ol>
  <li><code class="language-plaintext highlighter-rouge">@SpringBootTest</code> + <code class="language-plaintext highlighter-rouge">@AutoConfigureMockMvc</code> : MockMVC를 이용하여 통합테스트 할 때 사용</li>
  <li><code class="language-plaintext highlighter-rouge">@WebMvcTest</code> : MVC만 슬라이스(slice) 테스트 할 때 사용</li>
</ol>]]></content><author><name>Oh</name></author><category term="Spring" /><category term="Spring" /><category term="Java" /><category term="Test" /><category term="CheatSheet" /><summary type="html"><![CDATA[📝 Spring Boot Test Cheat Sheet 입니다. 설명은 없고 자주 사용하는 테스트 코드 참고용 입니다. JUnit 5, AssertJ Cheat Sheet]]></summary></entry><entry><title type="html">Test Double</title><link href="http://localhost:4000/insight/Test-Double/" rel="alternate" type="text/html" title="Test Double" /><published>2023-02-12T00:00:00+09:00</published><updated>2023-02-12T00:00:00+09:00</updated><id>http://localhost:4000/insight/Test-Double</id><content type="html" xml:base="http://localhost:4000/insight/Test-Double/"><![CDATA[<p>테스트 더블(Test Dobule)에 대해 설명합니다.</p>

<p><br /></p>

<h1 id="-테스트-더블이란">🤔 테스트 더블이란?</h1>
<ul>
  <li>Test Dobule이라 한다.</li>
  <li>테스트를 진행하기 어려운 경우 이를 <strong>대신해 테스트를 진행할 수 있도록 만들어주는 객체를 말한다.</strong></li>
  <li>제라드 메스자로스(Gerard Meszaros)가 만든 용어로,  스턴트 더블(영화 촬영에서 말하는 스턴트 대역 배우)에서 아이디어를 얻어서 만든 용어이다.</li>
</ul>

<div class="notice--info">
<p>예를 들어 우리가 데이터베이스로부터 조회한 값을 연산하는 로직을 구현했다고 하자. 해당 로직을 테스트하기 위해선 항상 데이터베이스의 영향을 받을 것이고, 이는 데이터베이스의 상태에 따라 다른 결과를 유발할 수도 있다.</p>

<p>이때 <strong>테스트하려는 객체와 연관된 객체를 사용하기가 어렵고 모호할 때 대신해 줄 수 있는 객체를 테스트 더블이라 한다.</strong></p>
</div>
<p><br /></p>

<h1 id="-테스트-더블-종류">📖 테스트 더블 종류</h1>
<p><img src="/assets/images/posts/insight/20230212/e7604428-37a2-4e06-9dd4-35e3dc4e7d77.png" alt="TestDouble" />
테스트 더블은 크게 <code class="language-plaintext highlighter-rouge">Dummy</code>, <code class="language-plaintext highlighter-rouge">Fake</code>, <code class="language-plaintext highlighter-rouge">Stub</code>, <code class="language-plaintext highlighter-rouge">Spy</code>, <code class="language-plaintext highlighter-rouge">Mock</code>으로 나눈다.</p>

<h2 id="-dummy">🎯 Dummy</h2>
<ul>
  <li>가장 기본적인 테스트 더블이다.</li>
  <li>인스턴스화 된 객체가 필요하지만 기능은 필요하지 않은 경우에 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Dummy</code> 객체의 메서드가 호출되었을 때 정상 동작은 보장하지 않는다.</li>
  <li>객체는 전달되지만 사용되지 않는 객체이다.<br />
<br /></li>
</ul>

<p><strong>Dummy 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">PringWarning</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrintWarningDummy</span> <span class="kd">implements</span> <span class="nc">PrintWarning</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 아무런 동작을 하지 않는다.</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>실제 객체는 PrintWarning 인터페이스의 구현체를 필요하지만, 특정 테스트에서는 해당 구현체의 동작이 전혀 필요하지 않을 수 있다. 실제 객체가 로그용 경고만 출력한다면 테스트 환경에서는 전혀 필요 없기 때문이다.</p>

<p>이처럼 동작하지 않아도 테스트에는 영향을 미치지 않는 객체를 <code class="language-plaintext highlighter-rouge">Dummy</code> 객체라고 한다.
<br />
<br /></p>

<h2 id="-fake">🎯 Fake</h2>
<ul>
  <li>복잡한 로직이나 객체 내부에서 필요로 하는 다른 외부 객체들의 동작을 단순화하여 구현한 객체이다.</li>
  <li>동작의 구현을 가지고 있지만 실제 프로덕션에는 적합하지 않은 객체이다.</li>
  <li>즉, <strong>동작은 하지만 실제 사용되는 객체처럼 정교하게 동작하지는 않는 객체를 말한다.</strong><br />
<br /></li>
</ul>

<p><strong>Fake 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">);</span>
    <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FakeUserRepository</span> <span class="kd">implements</span> <span class="nc">UserRepository</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="nc">User</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">findById</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">user</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">findById</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">User</span> <span class="n">user</span> <span class="o">:</span> <span class="n">users</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getId</span><span class="o">()</span> <span class="o">==</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>실제 데이터베이스를 연결해서 테스트해야 하지만, 실제 데이터베이스 대신 가짜 데이터베이스 역할을 하는 FakeUserRepository를 만들어 테스트 객체에 주입한다. 이렇게 하면 테스트 객체는 데이터베이스에 의존하지 않으면서도 동일하게 동작을 하는 가짜 데이터베이스를 가지게 된다.</p>

<p>이처럼 실제 객체와 동일한 역할을 하도록 만들어 사용하는 객체가 <code class="language-plaintext highlighter-rouge">Fake</code>이다.<br />
<br />
<br /></p>

<h2 id="-stub">🎯 Stub</h2>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Dummy</code> 객체가 실제로 동작하는 것 처럼 보이게 만들어 놓은 객체이다.</li>
  <li>테스트에서 호출된 요청에 대해 미리 준비해둔 결과를 제공한다.</li>
  <li><strong>상태를 검증한다.</strong></li>
  <li>즉, <strong>테스트를 위해 프로그래밍된 내용에 대해서만 준비된 결과를 제공하는 객체이다.</strong></li>
</ul>

<p><strong>Stub 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">GradeServiceTest</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">Student</span> <span class="n">student</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">Gradebook</span> <span class="n">gradebook</span><span class="o">;</span>

    <span class="nd">@Before</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">gradebook</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="nc">Gradebook</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">student</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Student</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">calculates_grades_average_for_student</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">when</span><span class="o">(</span><span class="n">gradebook</span><span class="o">.</span><span class="na">gradesFor</span><span class="o">(</span><span class="n">student</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">grades</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">10</span><span class="o">));</span> <span class="c1">//stubbing gradebook</span>

        <span class="kt">double</span> <span class="n">averageGrades</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">GradesService</span><span class="o">(</span><span class="n">gradebook</span><span class="o">).</span><span class="na">averageGrades</span><span class="o">(</span><span class="n">student</span><span class="o">);</span>

        <span class="n">assertThat</span><span class="o">(</span><span class="n">averageGrades</span><span class="o">).</span><span class="na">isEqualTo</span><span class="o">(</span><span class="mf">8.0</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>우리가 테스트에서 자주 사용하는 <code class="language-plaintext highlighter-rouge">Mockito</code> 프레임워크도 <code class="language-plaintext highlighter-rouge">Stub</code>와 같은 역할을 해준다.</p>

<p>이처럼 테스트를 위해 의도한 결과만 반환되도록 하기 위한 객체가 <code class="language-plaintext highlighter-rouge">Stub</code>이다.<br />
<br />
<br /></p>

<h2 id="-spy">🎯 Spy</h2>
<ul>
  <li>Stub의 역할을 가지면서 호출된 내용에 대해 약간의 정보를 기록한다.</li>
  <li>실제 객체처럼 동작시킬 수도 있고, 필요한 부분에 대해서는 Stub로 만들어서 동작을 지정할 수도 있다.</li>
  <li>즉, <strong>실제 기능을 사용하면서 선택적으로 Stub하는 객체이다.</strong></li>
</ul>

<p><strong>Spy 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">MockitoExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpyTests</span> <span class="o">{</span>

    <span class="nd">@Spy</span>
    <span class="kd">private</span> <span class="nc">OrderRepository</span> <span class="n">orderRepository</span><span class="o">;</span>
    <span class="nd">@Spy</span>
    <span class="kd">private</span> <span class="nc">NotificationClient</span> <span class="n">notificationClient</span><span class="o">;</span>
    <span class="nd">@InjectMocks</span>
    <span class="kd">private</span> <span class="nc">OrderService</span> <span class="n">orderService</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createOrderTest_basic</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// given</span>
        <span class="c1">// Spy 객체의 orderRepository의 createOrder()만 Stub하고 나머지 기능은 그대로 사용</span>
        <span class="nc">Mockito</span><span class="o">.</span><span class="na">doAnswer</span><span class="o">(</span><span class="n">invocation</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"I'm spy orderRepository createOrder"</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}).</span><span class="na">when</span><span class="o">(</span><span class="n">orderRepository</span><span class="o">).</span><span class="na">createOrder</span><span class="o">();</span>
        <span class="nc">Mockito</span><span class="o">.</span><span class="na">doAnswer</span><span class="o">(</span><span class="n">invocation</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"I'm spy notificationclient"</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}).</span><span class="na">when</span><span class="o">(</span><span class="n">notificationClient</span><span class="o">).</span><span class="na">notifyToMobile</span><span class="o">();</span>


        <span class="c1">// when</span>
        <span class="n">orderService</span><span class="o">.</span><span class="na">createOrder</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

        <span class="c1">// then</span>
        <span class="nc">Mockito</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">orderRepository</span><span class="o">,</span> <span class="nc">Mockito</span><span class="o">.</span><span class="na">times</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">createOrder</span><span class="o">();</span>
        <span class="nc">Mockito</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">notificationClient</span><span class="o">,</span> <span class="nc">Mockito</span><span class="o">.</span><span class="na">times</span><span class="o">(</span><span class="mi">1</span><span class="o">)).</span><span class="na">notifyToMobile</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br /></p>

<h2 id="-mock">🎯 Mock</h2>
<ul>
  <li>Mock은 행위를 검증하기 위해 가짜 객체를 만들고 테스트하는 방법이다.</li>
  <li>테스트가 정상적으로 호출되었는지, <strong>행위를 검증한다.</strong><br />
<br /></li>
</ul>

<p><strong>Mock 예</strong></p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityCentral</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Window</span> <span class="n">window</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Door</span> <span class="n">door</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">SecurityCentral</span><span class="o">(</span><span class="nc">Window</span> <span class="n">window</span><span class="o">,</span> <span class="nc">Door</span> <span class="n">door</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">window</span> <span class="o">=</span> <span class="n">window</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">door</span> <span class="o">=</span> <span class="n">door</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">securityOn</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">window</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">door</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SecurityCentralTest</span> <span class="o">{</span>
    <span class="nc">Window</span> <span class="n">windowMock</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="nc">Window</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="nc">Door</span> <span class="n">doorMock</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="nc">Door</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enabling_security_locks_windows_ans_doors</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">SecurityCentral</span> <span class="n">securityCentral</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SecurityCentral</span><span class="o">(</span><span class="n">windowMock</span><span class="o">,</span> <span class="n">doorMock</span><span class="o">);</span>

        <span class="n">securityCentral</span><span class="o">.</span><span class="na">securityOn</span><span class="o">();</span>

        <span class="c1">// 행위 검증</span>
        <span class="n">verify</span><span class="o">(</span><span class="n">windowMock</span><span class="o">).</span><span class="na">close</span><span class="o">();</span>
        <span class="n">verify</span><span class="o">(</span><span class="n">doorMock</span><span class="o">).</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><br />
<br />
<br /></p>

<h1 id="️-참고사이트">🙇🏻‍♂️ 참고사이트</h1>
<ul>
  <li><a href="https://tecoble.techcourse.co.kr/post/2020-09-19-what-is-test-double/" target="_blank">https://tecoble.techcourse.co.kr</a></li>
  <li><a href="https://cobbybb.tistory.com/16" target="_blank">https://cobbybb.tistory.com/16</a></li>
</ul>]]></content><author><name>Oh</name></author><category term="Insight" /><category term="Insight" /><category term="Test" /><category term="TestDobule" /><summary type="html"><![CDATA[테스트 더블(Test Dobule)에 대해 설명합니다.]]></summary></entry></feed>