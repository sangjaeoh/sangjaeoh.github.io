---
layout: single
title: "📖 자바 ORM 표준 JPA 프로그래밍"
categories: [etc, books]
tag: [books, JPA, ORM]
author_profile: true
toc: true
toc_sticky: true
---

[자바 ORM 표준 JPA 프로그래밍](https://product.kyobobook.co.kr/detail/S000000935744){:target="_blank"} 책을 읽고 내용을 아주 간단하게 정리한 글입니다. 책에는 자세한 설명과 예제가 많으니 **꼭 구입해서 읽는것을 추천**합니다~👍

---

# 1. JPA 소개
## 1.1 SQL을 직접 다룰 때 발생하는 문제점
- 자바로 개발하는 애플리케이션은 대부분 관계형 데이터베이스를 데이터 저장소로 사용한다.
- JDBC API를 사용해 SQL을 전달한다.

### 1.1.1 반복, 반복 그리고 반복
객체를 데이터 베이스에 CURD 하려먼 너무많은 SQL과 JDBC API를 코드로 작성해야 한다. 테이블이 여러개라면 무수히 많은 SQL을 작성해야 한다.

### 1.1.2 SQL에 의존적인 개발
애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점
- 진정한 의미의 계층 분할이 어렵다.
- 엔티티를 신뢰할 수 없다.
- SQL에 의존적인 개발을 피하기 어렵다.

### 1.1.3 JPA와 문제 해결
JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 SQL을 작성하는 것이 아니라 JPA가 제공하는 API를 사용하면 된다.

```java
// 저장
jpa.persist(member);

// 조회
String memberId = "helloId"
Member member = jpa.find(Member.class, memberId);

// 수정
Member member = jpa.find(Member.class, memberId);
member.setName("이름변경"); // jpa는 update 메소드가 따로 없다.

// 연관된 객체 조회
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam();
```


## 1.2 패러다임 불일치
- 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르다.
- 기능과 표현 방법도 다르다.
- 객체 구조를 테이블 구조에 저장하는 데는 한계가 있다.

### 1.2.1 상속
객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다.(일부 데이터베이스는 상속 기능을 지원하지만 객체의 상속과는 약간 다르다.)

<center><img src="/assets/images/posts/books/2/1_2_객체상속모델.png" alt="객체상속모델" width="90%" height="90%"></center>

<br/>

데이터 베이스 모델링에서는 슈퍼타입 서브타입 관계를 사용하면 유사하게 만들 수 있다.

<center><img src="/assets/images/posts/books/2/1_2_테이블모델.png" alt="테이블모델" width="90%" height="90%"></center>

<br/>

위의 구조를 JDBC API를 사용해서 구현하려면 작성해야 할 코드량이 만만치 않다. 
- INSERT INTO ITEM...
- INSERT INTO ALBUM...

<br/>

**JPA와 상속**  
JPA는 상속과 관련된 패러다임 불일치 문제를 개발자 대신 해결해 준다.

```java
// 저장
jpa.persist(album);

// JPA에서 실행 해주는 SQL
INSERT INTO ITEM...
INSERT INTO ALBUM...
```

<br/>

### 1.2.2 연관관계
- **객체는 참조를 사용해 다른 객체와 연관관계**를 가진다. 참조에 접근해서 연관된 객체를 조회한다.
- **테이블은 외래 키를 사용해 다른 테이블과 연관관계**를 가진다. 조인을 사용해서 연관된 테이블을 조회한다. 
- **객체는 참조가 있는 방향으로만 조회할 수 있다.**
<center><img src="/assets/images/posts/books/2/1_2_연관관계.png" alt="연관관계" width="90%" height="90%"></center>

<br/>

**객체를 테이블에 맞추어 모델링**  
```java
// 관계형 데이터베이스가 사용하는 방식에 맞추면 객체 참조를 통해 조회할 수 없다.
class Member {
    String id;   // MEMBER_ID 컬럼 사용
    Long teamId; // TEAM_ID FK 컬럼 사용
}
```

<br/>

**객체지향 모델링**  
```java
// 패러다임 불일치를 해결하려고 소모하는 코드가 많다.
class Member {
    String id;   // MEMBER_ID 컬럼 사용
    Team team; // 참조로 연관관계를 맺는다.
}

// 데이터베이스에 저장
member.getId();
member.getTeam.getId(); // TEAM_ID FK를 직접 구해야 함
...생략...

// 조회
SQL 실행
Member member = new Member ();
Team team = new Team();
...생략...
member.setTeam(team); // 직접 회원과 팀 관계 설정
```

<br/>

**JPA와 연관관계**  
```java
// JPA는 연관관계와 관련된 패러다임 불일치 문제를 해결해준다.

// 저장
member.setTeam(team);
jpa.persist(member); // TEAM_ID FK를 직접 지정할 필요 없음

// 조회
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam(); // 바로 사용 가능
```

<br/>

### 1.2.3 객체 그래프 탐색
객체에서 회원에 소속된 팀을 조회할 때는 다음처럼 참조를 사용해서 연관된 팀을 찾으면 되는데, 이것을 객체 그래프 탐색이라 한다.

<center><img src="/assets/images/posts/books/2/1_2_객체그래프탐색.png" alt="객체그래프탐색" width="90%" height="90%"></center>

<br/>

```java
// 객체 그래프 탐색
member.getOrder().getOrderItem()...

// 문제 발생
member.getOrder(); // 만약 null이라면?
```

**SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.** 이는 객체 그래프가 언제 끊어질지 모르기 때문에 함부로 탐색할 수 없다.

**JPA와 객체 그래프 탐색**  
JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다(**지연로딩**). 따라서 JPA를 사용하면 연관된 객체를 신뢰하고 조회할 수 있다.


### 1.2.4 비교
- 데이터베이스는 기본 키의 값으로 각 row를 구분
- 객체는 동일성, 동등성 비교.
  - 동일성은 == 비교. 객체 인스턴스의 주소 값을 비교한다.
  - 동등성은 equals() 비교. 객체 내부의 값을 비교한다.

**JDBC API 비교**  
```java
String memberId = "100";
Member member1 = memberDAO.getMember(memberID);
Member member2 = memberDAO.getMember(memberID);

// false
member1 == member2;
```

**JPA 비교**  
```java
String memberId = "100";
Member member1 = jpa.find(memberID);
Member member2 = jpa.find(memberID);

// true
member1 == member2;
```

<br/>

### 1.2.5 정리
**객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다르다.** 이 패러다임 차이를 극복하려고 개발자가 너무 많은 시간과 코드를 소비한다. 결국, 객체 모델링은 힘을 잃고 점점 데이터 중심의 모델로 변해간다.

**JPA는 패러다임 불일치 문제를 해결하고, 정교한 객체 모델링을 유지하게 도와준다.**

<br/>
<br/>

## 1.3 JPA란 무엇인가?
**JPA(java persistence API)는 자바진영 ORM 기술 표준**이다. 애플리케이션과 JDBC 사이에서 동작한다.

<center><img src="/assets/images/posts/books/2/1_3_JPA.png" alt="JPA" width="90%" height="90%"></center>

<br/>

**ORM이란?**  
ORM(Object-Relational Mapping)은 **객체와 관계형 데이터 베이스를 매핑한다는 뜻**이다. 다양한 ORM 프레임워크들이 있는데 자바 진영에서는 **하이버네이트 프레임워크가 가장 많이 사용**된다.

<center><img src="/assets/images/posts/books/2/1_3_JPA조회.png" alt="JPA조회" width="80%" height="80%"></center>

<br/>
<br/>

### 1.3.1 JPA 소개
<center><img src="/assets/images/posts/books/2/1_3_JPA표준인터페이스와구현체.png" alt="JPA표준인터페이스와구현체" width="80%" height="80%"></center>

<br/>

**JPA는 자바 ORM 기술에 대한 API 표준 명세다.** 쉽게 이야기해서 인터페이스를 모아둔 것이다. 따라서 JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 한다. ORM 프레임워크 중 **하이버네이트가 가장 대중적**이다.

<br/>

### 1.3.2 왜 JPA를 사용해야 하는가?
- 생산성
- 유지보수
- 패러다임 불일치 해결
- 성능 (캐시)
- 데이터 접근 추상화와 벤더 독립성
  - 데이터베이스마다 사용법이 다르다 (예: 페이징 쿼리)
  - JPA에게 데이터베이스만 알려주면 자동으로 해결된다
- 표준
  - 자바 진영 ORM 기술 표준
  - 표준을 사용하면 다른 구현 기술로 손쉽게 변경 가능

<center><img src="/assets/images/posts/books/2/1_3_벤더독립성.png" alt="벤더독립성" width="80%" height="80%"></center>

<br/>
<br/>

## 1.4 정리
- SQL을 직접 다룰 때 발생하는 다양한 문제
- 객체지향 언어와 관계형 데이터베이스 사이의 패러다임 불일치 문제
- JPA가 각 문제를 어떻게 해결하는지
- JPA가 무엇인지
- JPA 장점


# 2. JPA 시작
## 2.1 이클립스 설치와 프로젝트 불러오기
## 2.2 H2 데이터베이스 설치
## 2.3 라이브러리와 프로젝트 구조
## 2.4 객체 매핑 시작
```java
@Entity
@Table(name="MEMBER")
public class Member {

    @Id
    @Column(name = "ID")
    private String id;

    @Column(name = "NAME")
    private String username;

    private Integer age;
    ...
}
```

| **어노테이션**    | **설명**                                                                             |
| ------------ | ---------------------------------------------------------------------------------- |
| @Entity      | 이 클래스를 테이블과 매핑한다고 JPA에게 알려준다. @Entity가 사용된 클래스를 엔티티 클래스라 한다.                       |
| @Table       | 엔티티 클래스에 매핑할 테이블 정보를 알려준다. 이 어노테이션을 생략하면 클래스 이름을 테이블 이름으로 매핑한다. (정확히는 엔티티 이름을 사용함) |
| @Id          | 엔티티 클래스의 필드를 테이블 기본키(primary key)에 매핑한다. @Id가 사용된 필드를 식별자 필드라 한다.                  |
| @Column      | 필드를 컬럼에 매핑한다.                                                                      |
| 매핑 정보가 없는 필드 | 필드명을 사용해서 컬럼명으로 매핑한다. 대소문자를 구분하는 데이터베이스를 사용하면 @Column(name="AGE")처럼 명시적으로 매핑해야 한다. |

<br>
<br>

## 2.5 객체 매핑 시작
### 2.5.1 데이터베이스 방언
데이터베이스마다 SQL 문법과 함수가 조금씩 다르다는 문제점이 있다.
- 데이터 타입: 가변 문자 타입으로 MySQL은 VARCHAR, 오라클은 VARCHAR2 사용
- 다른 함수명: 문자열을 자르는 함수로 SQL 표준은 SUBSTRING(), 오라클은 SUBSTR()
- 페이징 처리: MySQL은 LIMIT, 오라클은 ROWNUM

데이터베이스만의 고유한 기능을 JPA에서는 방언(Dialect)이라 한다. 특정 데이터베이스에 종속되는 기능을 많이 사용하면 나중에 데이터베이스를 교체하기가 어렵다. 하이버네이트를 포함한 대부분의 JPA 구현체들은 이런 문제점을 해결하려고 다양한 데이터베이스 방언 클래스를 제공한다.

<center><img src="/assets/images/posts/books/2/2_5_방언.png" alt="방언" width="80%" height="80%"></center>


```xml
<!-- 필수 속성 -->
<property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>
<property name="javax.persistence.jdbc.user" value="sa"/>
<property name="javax.persistence.jdbc.password" value=""/>
<property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>
<property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect" /> <!-- 방언 설정 -->

<!-- 옵션 -->
<property name="hibernate.show_sql" value="true" /> <!-- 하이버네이트가 실행한 SQL을 출력한다 -->
<property name="hibernate.format_sql" value="true" /> <!-- 하이버네이트가 실행한 SQL을 보기 쉽게 정렬한다 -->
<property name="hibernate.use_sql_comments" value="true" /> <!-- 쿼리를 출력할 때 주석도 함께 출력한다 -->
<property name="hibernate.id.new_generator_mappings" value="true" /> <!-- JPA 표준에 맞춘 새로운 키 생성 전략을 사용한다. -->
```

<br/>
<br/>

## 2.6 애플리케이션 개발
```java
public class JpaMain {

    public static void main(String[] args) {

        //엔티티 매니저 팩토리 생성
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
        EntityManager em = emf.createEntityManager(); //엔티티 매니저 생성

        EntityTransaction tx = em.getTransaction(); //트랜잭션 기능 획득

        try {
            tx.begin(); //트랜잭션 시작
            logic(em);  //비즈니스 로직
            tx.commit();//트랜잭션 커밋

        } catch (Exception e) {
            e.printStackTrace();
            tx.rollback(); //트랜잭션 롤백
        } finally {
            em.close(); //엔티티 매니저 종료
        }

        emf.close(); //엔티티 매니저 팩토리 종료
    }

    // 비즈니스 로직
    public static void logic(EntityManager em) {...}
}
```
코드는 크게 3부분으로 나뉘어 있다
- 엔티티 매니저 생성
- 트랜잭션 관리
- 비즈니스 로직


### 2.6.1 엔티티 매니저 설정
**엔티티 매니저 팩토리 생성**  
```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
```
JPA를 동작시키기 위한 기반 객체를 만들고 데이터베이스 커넥션 풀도 생성하므로 엔티티 매니저 팩토리를 생성하는 비용은 아주 크다. 따라서 **엔티티 매니저 팩토리는 애플리케이션 전체에 딱 한 번만 생성하고 공유해서 사용해야 한다.**

**엔티티 매니저 생성**  
```java
EntityManager em = emf.createEntityManager();
```
JPA의 기능 대부분은 엔티티 매니저가 제공한다. 대표적으로 엔티티를 데이터베이스에 등록,수정,삭제,조회할 수 있다. **엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안된다.**

**종료**  
사용이 끝난 엔티티 매니저, 엔티티 매니저 팩토리는 반드시 종료해야한다.
```java
em.close(); // 엔티티 매니저 종료
emf.close() // 엔티티 매니저 팩토리 종료
```

<br/>

### 2.6.2 트랜잭션 관리
JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션 없이 데이터를 변경하면 예외가 발생한다.

```java
EntityTransaction tx = em.getTransaction(); //트랜잭션 기능 획득
try {
    tx.begin(); //트랜잭션 시작
    logic(em);  //비즈니스 로직
    tx.commit();//트랜잭션 커밋

} catch (Exception e) {
    e.printStackTrace();
    tx.rollback(); //트랜잭션 롤백
} finally {
    em.close(); //엔티티 매니저 종료
}

emf.close(); //엔티티 매니저 팩토리 종료
```

<br/>

### 2.6.3 비즈니스 로직
```java
public static void logic(EntityManager em) {

        String id = "id1";
        Member member = new Member();
        member.setId(id);
        member.setUsername("지한");
        member.setAge(2);

        //등록
        // INSERT INTO MEMBER ...
        em.persist(member);

        //수정
        // JPA는 엔티티 변경 추적 기능이 있어 엔티티의 값만 변경하면 수정됨
        // UPDATE MEMBER SET AGE=20, NAME='지한' WHERE ID = 'id1';
        member.setAge(20);

        //한 건 조회
        // SELECT * FROM MEMBER WHERE ID = 'id1';
        Member findMember = em.find(Member.class, id);
        System.out.println("findMember=" + findMember.getUsername() + ", age=" + findMember.getAge());

        //목록 조회
        List<Member> members = em.createQuery("select m from Member m", Member.class).getResultList();
        System.out.println("members.size=" + members.size());

        //삭제
        // DELETE FROM MEMBER WHERE ID = 'id1';
        em.remove(member);
    }
```

<br/>

### 2.6.4 JPQL
목록 조회 코드를 살펴보자.
```java
//목록 조회
List<Member> members = em.createQuery("select m from Member m", Member.class).getResultList();
System.out.println("members.size=" + members.size());
```

JPA는 엔티티 객체를 중심으로 개발하므로 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색해야 한다. JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어를 제공한다. 

**JPQL과 SQL의 가장 큰 차이점**  
- JPQL은 엔티티 객체를 대상으로 쿼리한다.
- SQL은 데이터베이스 테이블을 대상으로 쿼리한다.

**JPQL은 데이터베이스 테이블을 전혀 알지 못한다.** JPA는 JPQL을 분석해서 다음과 같은 적절한 SQL을 만들어 데이터베이스에서 데이터를 조회한다.

<br/>
<br/>

## 2.7 정리
- JPA를 사용하기 위한 개발 환경 설정
- JPA를 사용
- JPQL 설명


<br/>
<br/>
<br/>

# 3. 영속성 관리
## 3.1 엔티티 매니저 팩토리와 엔티티 매니저
- 엔티티 매니저 팩토리를 만드는 비용은 상당히 크다.
- 따라서 애플리케이션 전체에서 공유하도록 설계되어 있다. (그래서 일반적으로 하나만 생성 한다)
- **엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전**하다.
- **엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생**한다.
<center><img src="/assets/images/posts/books/2/3_1_일반적인웹애플리케이션.png" alt="일반적인웹애플리케이션" width="80%" height="80%"></center>

<br/>
<br/>

## 3.2 영속성 컨텍스트란?
영속성 컨텍스트(persistence context)란 해석하자면 **엔티티를 영구 저장하는 환경**이란 뜻이다.

```java
em.persist(memeber);
```
이 메소드는 정확히 표현하자면 **엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다** 이다.

영속성 컨텍스트는 
- 엔티티 매니저를 생성할 때 하나 만들어진다.
- 엔티티 매니저를 통해서 접근할 수 있다.
- 엔티티 매니저를 통해 관리받는다.
- 여러 엔티티 매니저가 접근할 수도 있다.

<br/>
<br/>

## 3.3 엔티티의 생명주기
엔티티에는 4가지 상태가 존재한다.
- 비영속(new / transient): 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(managed): 영속성 컨텍스트에 저장된 상태
- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed): 삭제된 상태
<center><img src="/assets/images/posts/books/2/3_3_생명주기.png" alt="생명주기" width="90%" height="90%"></center>

<br/>
<br/>

## 3.4 영속성 컨텍스트의 특징
영속성 컨텍스트의 특징은 다음과 같다

**영속성 컨텍스트와 식별자 값**  
영속성 컨텍스트는 엔티티를 식별자값(@Id)으로 구분한다. 영속 상태는 식별자 값이 반드시 있어야 한다.

**영속성 컨텍스트와 데이터베이스 저장**  
JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 플러시(flush)라 한다.

**영속성 컨텍스트가 엔티티를 관리할 때 장점**
- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연로딩

<br/>

### 3.4.1 엔티티 조회
영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다. 영속 상태의 엔티티는 모두 이곳에 저장된다.

**1차 캐시에서 조회**  
<center><img src="/assets/images/posts/books/2/3_4_1차캐시에서조회.png" alt="1차캐시에서조회" width="90%" height="90%"></center>

- 1차 캐시의 키는 식별자(@Id) 값.
- 식별자 값은 데이터베이스 기본 키와 매핑.
- 1차 캐시에서 엔티티를 찾고 엔티티가 없으면 데이터베이스에서 조회한다.

```java
// 비영속 상태
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

// 영속 상태 (1차 캐시에 저장됨)
em.persist(member);

// 1차 캐시에서 조회
Member findMember = em.find(Member.class, "member1");
```

<br/>

**데이터베이스에서 조회**  
- 조회시 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성.
- 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.

<center><img src="/assets/images/posts/books/2/3_4_1차캐시에없으면데이터베이스서조회.png" alt="1차캐시에없으면데이터베이스서조회" width="90%" height="90%"></center>

<br/>

**영속 엔티티의 동일성 보장**  
영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.
```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b);
```

**동일성과 동등성**  
- 동일성(identity): 실제 인스턴스가 같다. 따라서 참조 값을 비교하는 == 비교의 값이 같다.
- 동등성(equality): 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다.

<br/>

### 3.4.2 엔티티 등록
```java
EntityManager em = emf.createEntityManager(); 
EntityTransaction tx = em.getTransaction();
// 엔티티 매니저는 데이터 변경 시 트랜잭션을 시작해야 한다.
tx.begin(); //트랜잭션 시작

em.persist(memberA);
em.persist(memberB);
// 여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.

// 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
tx.commit();
```
- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아둔다.
- 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보낸다
- 이를 트랜잭션을 지원하는 쓰기 지연이라 한다.

<center><img src="/assets/images/posts/books/2/3_4_쓰기지연1.png" alt="쓰기지연" width="90%" height="90%"></center>
<br/>
<center><img src="/assets/images/posts/books/2/3_4_쓰기지연2.png" alt="쓰기지연" width="90%" height="90%"></center>
<br/>
<center><img src="/assets/images/posts/books/2/3_4_쓰기지연3.png" alt="쓰기지연" width="90%" height="90%"></center>

**트랜잭션 커밋의 동작**  
1. `tx.commit();` 실행
2. 엔티티 매니저가 영속성 컨텍스트를 플러시
   - 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는 작업
   - 구체적으로 이야기하면 쓰기 지연 SQL을 데이터베이스에 보냄
3. 데이터베이스 트랜잭션 커밋

<br/>

**트랜잭션을 지원하는 쓰기 지연이 가능한 이유**  
- 등록 쿼리를 그때 그때 데이터베이스에 전달해도 트랜잭션을 커밋하지 않으면 아무 소용 없다.
- 결국 데이터베이스에 SQL을 그때 그때 전달하나, 커밋 직전에만 전달하나 결과는 같다.

<br/>


### 3.4.3 엔티티 수정
**SQL 수정 쿼리의 문제점**  
```sql
UPDATE MEMBER
SET
    NAME=?,
    AGE=?,
    GRADE=?
WHERE
    ID=?
```
- 수정 쿼리가 많아진다.
- 비즈니스 로직을 분석하기 위해 SQL을 계속 확인해야한다.
- 결국 직간접적으로 비즈니스 로직이 SQL에 의존한다.

<br/>

**변경감지**  
- **JPA에서 엔티티 수정은 단순히 엔티티를 조회해서 데이터만 변경**하면 된다.
- 이렇게 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 **변경 감지**라 한다.
- **변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.**

```java
EntityManager em = emf.createEntityManager(); 
EntityTransaction tx = em.getTransaction();

// 트랜잭션 시작
tx.begin();

// 영속 엔티티 조회
Member memberA = em.find(Member.class, "memberA");

// 영속 엔티티 데이터 수정
memberA.setUserName("hi");
memberA.setAge(10);

// 트랜잭션 커밋
tx.commit();
```

<center><img src="/assets/images/posts/books/2/3_4_변경감지.png" alt="변경감지" width="100%" height="100%"></center>

<br/>

변경 감지로 UPDATE SQL이 실행된다. 
```sql
UPDATE MEMBER
SET
    NAME=?,
    AGE=?,
    GRADE=?
WHERE
    ID=?
```

**JPA의 기본전략은 엔티티의 모든 필드를 업데이트** 한다. 필드가 너무 많거나 저장되는 내용이 너무 크면 수정된 데이터만 사용해서 **동적으로 UPDATE SQL을 생성하는 전략을 선택할 수 있다.**
```java
@Entity
@org.hibernate.annotations.DynamicUpdate
public class Member{...}
```
다만 상황에 따라 다르겠지만 컬럼이 대략 30개 정도가 아니라면 기본 전략의 수정 쿼리가 빠르다.  
추가로 **INSERT SQL을 동적으로 생성하는 @DynamicInsert도 있다.**

<br/>

### 3.4.4 엔티티 삭제
```java
// 영속 엔티티 조회
Member memberA = em.find(Member.class, "memberA");
em.remove(memberA);
```
1. `em.remove();` 호출
2. 호출 순간 영속성 컨텍스트에서 엔티티 제거
3. 쓰기 지연 SQL 저장소에 삭제 쿼리 등록
4. 트랜잭션 커밋시 플러시 (실제 데이터베이스에 삭제 쿼리 전달)
5. 데이터베이스 트랜잭션 커밋

<br/>
<br/>

## 3.5 플러시
**플러시는(flush())는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.** 동작 순서는 다음과 같다.
1. 변경 감지가 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.
2. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.(등록,수정,삭제 쿼리)

<br/>

**영속성 컨텍스트를 플러시하는 방법 3가지**  
1. 직접 호출 (`em.flush()`)
2. 트랜잭션 커밋
3. JPQL 쿼리 실행
    - JPQL은 SQL로 변환되어 데이터베이스에서 엔티티 조회
    - 만약 엔티티가 데이터베이스에 없으면 조회 불가
    - 따라서 플러시를 통해 변경 내용을 데이터베이스에 반영해야 함

참고로 식별자를 기준으로 조회하는 `find()` 메소드를 호출할 때는 플러시가 실행되지 않는다.

<br/>

### 3.5.1 플러시 모드 옵션
- FlushModeType.AUTO: 커밋이나 쿼리를 실행할 때 플러시(기본값)
- FlushModeType.COMMIT: 커밋할 때만 플러시
```java
em.setFlushMode(FlushModeType.COMMIT); // 플러시 모드 직접 설정
```

<br/>
<br/>

## 3.6 준영속
영속성 컨텍스트가 관리하는 **영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 준영속 상태**라 한다. 따라서 **준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.**

**영속 상태의 엔티티를 준영속 상태로 만드는 방법**  
1. `em.detach(entity)`: 특정 엔티티만 준영속 상태로 전환
2. `em.clear()`: 영속성 컨텍스트를 완전히 초기화
3. `em.close()`: 영속성 컨텍스트를 종료

<br/>

### 3.6.1 엔티티를 준영속 상태로 전환: detach()
특정 엔티티만 준영속 상태로 전환

<center><img src="/assets/images/posts/books/2/3_6_detach1.png" width="100%" height="100%"></center>

<center><img src="/assets/images/posts/books/2/3_6_detach2.png" width="100%" height="100%"></center>

<br/>

### 3.6.2 영속성 컨텍스트 초기화: clear()
영속성 컨텍스트를 초기화해서 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만듬

<center><img src="/assets/images/posts/books/2/3_6_clear1.png" width="100%" height="100%"></center>

<center><img src="/assets/images/posts/books/2/3_6_clear2.png" width="100%" height="100%"></center>

<br/>

### 3.6.3 영속성 컨텍스트 종료: close()
영속성 컨텍스트를 종료하면 해당 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모둔 준영속 상태가 된다.

<center><img src="/assets/images/posts/books/2/3_6_close.png" width="100%" height="100%"></center>

<center><img src="/assets/images/posts/books/2/3_6_close2.png" width="100%" height="100%"></center>

<br/>

### 3.6.4 준영속 상태의 특징
- 거의 비영속 상태에 가깝다.
- 식별자 값을 가지고 있다.
  - 준영속 상태는 이미 한 반 영속 상태였으므로 식별자 값을 가지고 있다.
- 지연 로딩을 할 수 없다.

<br/>

### 3.6.5 병합: merge()
준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용한다. `merge()` 메소드는 준영속 상태의 엔티티를 받아서 그 정보로 **새로운 영속 상태의 엔티티를 반환한다.**

```java
Member mergeMember = em.merge(member);
```

<br/>

**준영속 병합**  
준영속 상태인 `member`엔티티와 영속 상태인 `mergeMember` 엔티티는 서로 다른 인스턴스다. 따라서 다음과 같이 참조하도록 사용하는 것이 안전하다.
```java
// Member mergeMember = em.merge(member); // 아래 코드로 변경
member = em2.merge(member);
```

<br/>

**비영속 병합**  
병합은 비영속 엔티티도 영속 상태로 만들 수 있다.  
```java
Member member = new Member();
Mmeber newMember = em.merge(member); // 비영속 병합
tx.commit();
```

<br/>

**병합 동작 순서**  
1. 파라미터로 넘어온 엔티티의 식별자 값으로 영속성 컨텍스트 조회
2. 찾는 엔티티가 없으면 데이터베이스 조회
3. 데이터베이스에서도 없으면 엔티티 생성해서 병합

<br/>
<br/>

## 3.7 정리
- 엔티티 매니저는 앤티티 매니저 팩토리에서 생성한다.
- 영속성 컨텍스트는 엔티티 매니저를 통해서 접근할 수 있다.
- **영속성 컨텍스트는 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할**을 한다.
- 영속성 컨텍스트 덕분에 **1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기지연, 변경 감지, 지연 로딩 기능**을 사용할 수 있다.
- 영속성 컨텍스트에 저장한 **엔티티는 플러시 시점에 데이터베이스에 반영**된다.
- **플러시는 일반적으로 트랜잭션을 커밋할 때 동작**한다.
- **영속 상태: 영속성 컨텍스트가 관리하는 엔티티**
- **준영속 상태: 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것을 준영속 상태**

<br/>
<br/>
<br/>



# 4. 엔티티 매핑
- 객체와 테이블 매핑: `@Entity`, `@Table`
- 기본 키 매핑: `@Id`
- 필드와 컬럼 매핑: `@Column`
- 연관관계 매핑: `@ManyToOne`, `@JoinColumn`

<br/>

## 4.1 @Entity
JPA를 사용해서 테이블과 매핑할 클래스

| **속성** | **기능**                                                                      | **기본값**           |
| ------ | --------------------------------------------------------------------------- | ----------------- |
| name   | JPA에서 사용할 엔티티 이름을 지정한다. 기본값은 클래스 이름이다. 만약 다른 패키지에 이름이 같은 엔티티 클래스가 있다면 출돌한다. | 클래스이름 (예: Member) |

<br/>

**주의사항**  
- 기본 생성자는 필수 (`public` 또는 `protected`)
- `final, enum, interface, inner` 클래스에는 사용할 수 없다.
- 저장할 필드에 `final`을 사용하면 안된다.

<br/>
<br/>

## 4.2 @Table
엔티티와 매핑할 테이블을 지정. 생략하면 매핑한 엔티티 이름을 테이블 이름으로 사용한다.

| **속성**           | **기능**                                                                                         | **기본값**       |
| ---------------- | ---------------------------------------------------------------------------------------------- | ------------- |
| name             | 매핑할 테이블 이름                                                                                     | 엔티티 이름을 사용한다. |
| catalog          | catalog 기능이 있는 데이터베이스에서 catalog를 매핑한다.                                                         |               |
| schema           | schema 기능이 있는 데이터베이스에서 schema를 매핑한다.                                                           |               |
| uniqueConstraints | DDL 생성 시 유니크 제약조건을 만든다. 2개 이상의 복합 유니크 제약조건도 만들 수 있다. 이 기능은 스키마 자동 생성 기능을 사용해서 DDL을 만들 때만 사용된다. |               |

<br/>
<br/>

## 4.3 다양한 매핑 사용

```java
@Entity
@Table(name="MEMBER",
    uniqueConstraints = {@UniqueConstraint(
        name = "NAME_AGE_UNIQUE",
        columnNames = {"NAME", "AGE"} 
    )}
)
public class Member {
    ...생략...

    // enum을 사용하려면 @Enumerated 어노테이션으로 매핑
    @Enumerated(EnumType.STRING)
    private RoleType roleType;

    // 자바의 날짜 타입은 @Temporal 어노테이션으로 매핑
    @Temporal(TemporalType.TIMESTAMP)
    private Date createdDate;

    // CLOB, BLOB타입은 @Lob 어노테이션으로 매핑
    @Lob
    private String description;

    ...생략...
}
```

<br/>
<br/>

## 4.4 데이터베이스 스키마 자동 생성
JPA는 데이터베이스 스키마를 자동으로 생성하는 기능을 지원한다.

```xml
<!-- 스키마 자동 생성 -->
<property name="hibernate.hbm2ddl.auto" value="create" />

<!-- 콘솔에 테이블 생성 DDL 출력 -->
<property name="hibernate.show_sql" value="true" />
```

<br/>

**hibernate.hbm2ddl.auto 속성**  

| **옵션** | **설명** |
|------|------|
| create     | 기존 테이블을 삭제하고 새로 생성한다. DROP + CREATE     |
| create-drop     | create 속성에 추가로 애플리케이션을 종료할 때 생성한 DDL을 제거한다. DROP + CREATE + DROP    |
| update     | 데이터베이스 테이블과 엔티티 매핑정보를 비교해서 변경 사항만 수정한다.     |
| validate     | 데이터 베이스 테이블과 엔티티 매핑정보를 비교해서 차이가 있으면 경고를 남기고 애플리케이션을 실행하지 않는다.      |
| none     | 자동 생성 기능을 사용하지 않으려면 hibernate.hbm2ddl.auto 속성 자체를 삭제하거나 유효하지 않은 옵션 값을 주면 된다.     |

<br/>

**HBM2DDL 주의사항**  
운영 서버에서는 DDL을 수정하는 옵션은 절대 사용하면 안된다.
- 개발 초기 단계: `create`, `update`
- 초기화 상태로 테스트, CI서버: `create`, `create-drop`
- 테스트 서버: `update`, `validate`
- 스테이징, 운영 서버: `validate`, `none`

<br/>

**기본 이름 매핑 전략 변경하기**  
테이블 명이나 컬럼 명이 생략되면 자바의 카멜 표기법을 데이터베이스 테이블의 언더스코어 표기법으로 매핑한다.

```java
<property name="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy" />
```

<br/>
<br/>

## 4.5 DDL 생성 기능

**제약 조건 추가**  
스키마 자동 생성하기를 통해 DDL에 제약조건을 추가할 수 있다. 다만 **DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.**

```java
@Entity
@Table(name="MEMBER", 
    /** 
     *  유니크 제약조건 추가
     *  ALET TABLE MEMBER
     *      ADD CONSTRAINT NAME_AGE_UNIQUE UNIQUE (NAME, AGE)
     */
    uniqueConstraints = {@UniqueConstraint(
        name = "NAME_AGE_UNIQUE",
        columnNames = {"NAME", "AGE"} 
    )}
)
public class Member {
    ...생략...

    // 컬럼명 NAME, not null, 문자크기 10
    @Column(name = "NAME", nullable = false, length = 10)
    private String username;

    ...생략...
}
```

<br/>
<br/>

## 4.6 DDL 생성 기능
JPA가 제공하는 데이터베이스 기본 키 생성 전략은 다음과 같다.
- 직접 할당: 애플리케이션에서 직접 할당
- 자동 생성: 대리 키 사용 방식
    - IDENTITY: 기본 키 생성을 데이터베이스에 위임
    - SEQUENCE: 데이터베이스 시퀀스를 사용
    - TABLE: 키 생성 테이블을 사용

자동 생성 전략이 다양한 이유는 데이터베이스 벤더마다 지원하는 방식이 다르기 때문이다. 키 생성 전략을 사용하려면 다음 속성을 추가한다.
```java
<property name="hibernate.id.new_generator_mappings" value="true" />
```

<br/>

### 4.6.1 기본 키 직접 할당 전략

```java
@Id
@Column(name = "ID")
private String id;
```
```java
Board board = new Board();
board.setId("id"); // 기본 키 직접 할당
em.persist(board);
```

<br/>

### 4.6.2 IDENTITY 전략
- `IDENTITY`는 기본 키 생성을 데이터베이스에 위임하는 전략이다.
- `IDENTITY` 식별자 생성 전략은 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있다.
- **`em.persist()`를 호출하는 즉시 `INSERT SQL`이 데이터베이스에 전달된다.**
- 따라서 **트랜잭션을 지원하는 쓰기 지연이 동작하지 않는다.**

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```
```java
Board board = new Board();
em.persist(board);
board.getId(); // 1
```

<br/>

**IDENTITY 전략과 최적화**  
IDENTITY 전략은 데이터를 데이터베이스에 INSERT한 후에 기본 키값을 조회할 수있다. 따라서 엔티티에 식별자 값을 할당하려면 JPA는 추가로 데이터베이스를 조회해야 한다. 하이버네이트는 JDBC3에 추가된 `Statement.getGeneratedKeys()` 메소드를 사용해서 데이터베이스와 한번만 통신한다.

<br/>


### 4.6.3 SEQUENCE 전략
SEQUENCE 전략은 데이터베이스 시퀀스를 이용해 기본 키를 생성한다.

```sql
-- 데이터베이스 시퀀스 생성
CREATE SEQUENCE BOARD_SEQ START WITH 1 INCREMENT BY 1;
```
```java
@Entity
@SequenceGenerator(
    name = "BOARD_SEQ_GENERATOR",
    sequenceName = "BOARD_SEQ", // 매핑할 데이터베이스 시퀀스 이름
    initialValue = 1,
    allocationsSize = 1
)
public class BOARD {

    @Id
    @GeneratedValue(
        strategy = GenerationType.SEQUENCE,
        generator = "BOARD_SEQ_GENERATOR"
    )
    private Long id;
}
```

<br/>

**@SequenceGenerator**  


| **속성**          | **기능**                                          | **기본값**            |
| --------------- | ----------------------------------------------- | ------------------ |
| name            | 식별자 생성기 이름                                      | 필수                 |
| sequenceName    | 데이터베이스에 등록되어 있는 시퀀스 이름                          | hibernate_sequence |
| initialValue    | DDL 생성 시에만 사용됨. 시퀀스 DDL을 생성할 때 처음 시작하는 수를 지정한다. | 1                  |
| allocationsSize | 시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용됨)                | 50                 |
| catalog, schema | 데이터베이스 catalog, schema 이름                       |                    |

<br/>

**SEQUENCE 전략과 최적화**  
SEQUENCE 전략은 데이터베이스와 2번 통신한다.
1. 식별자 구하기
   - SELECT BOARD_SEQ.NEXTVAL FROM DUAL
2. 조회한 시퀀스를 기본 키 값으로 사용해 데이터베이스에 저장
   - INSERT INTO BOARD ...

JPA는 시퀀스 접근하는 횟수를 줄이기 위해 `@SequenceGenerator.allocationsSize`를 사용한다. 여기에 설정한 값만큼 한 번에 시퀀스 값을 증가시키고, 그만큼 메모리에 시퀀스 값을 할당한다.

이 방법은 시퀀스 값을 선점하므로 여러 JVM이 동시에 동작해도 기본 키 값이 충돌하지 않는다. 반면에 시퀀스 값을 한 번에 많이 증가시킨다. 이런 상황이 부담스럽고 `INSERT` 성능이 중요하지 않으면 `allocationsSize`값을 1로 설정한다.

<br/>


### 4.6.4 TABLE 전략
TABLE 전략은 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 컬럼을 만들어 데이터베이스 시퀀스를 흉내내는 전략이다.

```sql
-- 데이터베이스 키 생성 용도 테이블 생성
create table MY_SEQUENCES (
    sequence_name varchar(255) not null,
    next_val bigint,
    primary key (sequence_name)
)
```
```java
@Entity
@TableGenerator(
    name = "BOARD_SEQ_GENERATOR",
    table = "MY_SEQUENCES",
    pkColumnValue = "BOARD_SEQ",
    allocationsSize = 1
)
public class BOARD {

    @Id
    @GeneratedValue(
        strategy = GenerationType.TABLE,
        generator = "BOARD_SEQ_GENERATOR"
    )
    private Long id;
}
```

<br/>

**@TableGenerator**  

| **속성**                 | **기능**                           | **기본값**             |
| ---------------------- | -------------------------------- | ------------------- |
| name                   | 식별자 생성기 이름                       | 필수                  |
| table                  | 키생성 테이블명                         | hibernate_sequences |
| pkColumnName           | 시퀀스 컬럼명                          | sequence_name       |
| valueColumnName        | 시퀀스 값 컬럼명                        | next_val            |
| pkColumnValue          | 키로 사용할 값 이름                      | 엔티티 이름              |
| initialValue           | 초기 값, 마지막으로 생성된 값이 기준이다.         | 0                   |
| allocationsSize        | 시퀀스 한 번 호출에 증가하는 수 (성능 최적화에 사용됨) | 50                  |
| catalog, schema        | 데이터베이스 catalog, schema 이름        |                     |
| uniqueConstraints(DDL) | 유니크 제약 조건을 지정할 수 있다.             |                     |

<br/>

**TABLE 전략과 최적화**  
TABLE 전략은 값을 조회하면서 SELECT 쿼리를 사용하고, 다음 값으로 증가시키기 위해 UPDATE 쿼리를 사용한다. SEQUENCE 전략과 비교해서 데이터베이스와 한 번 더 통신하는 단점이 있다.

<br/>

### 4.6.5 AUTO 전략
데이터베이스의 방언에 따라 IDENTITY, SEQUENCE, TABLE 전략 중 하나를 자동으로 선택한다. **@GeneratedValue.strategy의 기본값은 AUTO다.**

```java
@Id @GeneratedValue
private Long id;
```

<br/>

### 4.6.6 기본 키 매핑 정리
- 직접 할당: 애플리케이션에서 직접 식별자 값을 할당
- SEQUENCE: 데이터베이스 시퀀스에서 식별자 값을 획득 후 영속성 컨텍스트에 저장
- TABLE: 데이터베이스 시퀀스 생성용 테이블에서 식별자 값을 획등 후 영속성 컨텍스트에 저장
- IDENTITY: 데이터베이스에 엔티티를 저장해서 식별자 값을 획득한 후 영속성 컨텍스트에 저장

<br/>

**식별자 선택 전략**  
테이블의 기본 키를 선택하는 전략은 크게 2가지가 있다.
1. 자연 키(natural key)
  - 비즈니스에 의미가 있는 키
  - 예) 주민등록번호, 이메일, 전화번호
2. 대리 키(surrogate key)
  - 비즈니스와 관련이 없는 임의로 만들어진 키, 대체 키로도 불린다
  - 예) 오라클 시퀀스, auto_increment, 키 생성 테이블 사용

<br/>

**권장하는 식별자 선택 전략**  
자연 키보다는 **대리 키를 권장**한다.  
- 자연 키는 변경될 수 있다.
- 비즈니스 환경은 언젠가 변한다.
- 테이블은 한 번 정의하면 변경하기 어렵다.

<br/>
<br/>



## 4.7 필드와 컬럼 매핑: 레퍼런스

<table>
    <thead>
        <tr>
            <th>분류</th>
            <th>매핑 어노테이션</th>
            <th>설명</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan="5">필드와 컬럼 매핑</td>
            <td>@Column</td>
            <td>컬럼을 매핑한다.</td>
        </tr>
        <tr>
            <td>@Enumerated</td>
            <td>자바의 enum 타입을 매핑한다.</td>
        </tr>
        <tr>
            <td>@Temporal</td>
            <td>날짜 타입을 매핑한다.</td>
        </tr>
        <tr>
            <td>@Lob</td>
            <td>BLOB, CLOB 타입을 매핑한다.</td>
        </tr>
        <tr>
            <td>@Transient</td>
            <td>특정 필드를 데이터베이스에 매핑하지 않는다.</td>
        </tr>
        <tr>
            <td>기타</td>
            <td>@Access</td>
            <td>JPA가 엔티티에 접근하는 방식을 지정한다.</td>
        </tr>
    </tbody>
</table>

<br/>

### 4.7.1 @Column
@Column은 객체 필드를 테이블 컬럼에 매핑한다.

| **속성** | **기능** | **기본값** |
|------|------|------|
| name     | 필드와 매핑할 테이블의 컬럼 이름     | 객체의 필드 이름     |
| insertable (거의 사용하지 않음)     | 엔티티 저장 시 이 필드도 같이 저장한다. false로 설정하면 이 필드는 데이터베이스에 저장하지 않는다.     | true     |
| updatable (거의 사용하지 않음)    | 엔티티 수정 시 이 필드도 같이 수정한다. false로 설정하면 이 필드는 데이터베이스에 수정하지 않는다.     | true     |
| table (거의 사용하지 않음)     | 하나의 엔티티를 두 개 이상의 테이블에 매핑할 때 사용한다. 지정한 필드를 다른 테이블에 매핑할 수 있다.     | 현재 클래스가 매핑된 테이블      |
| nullable (DDL)     | null 값의 허용 여부 설정.      | true     |
| unique (DDL)     | @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용한다. 만약 두 컬럼 이상을 사용해서 유니크 제약조건을 사용하려면 @Table.uniqueConstraints를 사용해야 한다.     |      |
| length (DDL)     | 문자 길이 제약조건, String 타입에만 사용한다.     | 255     |
| precision, scale (DDL)     | BigDecimal 타입에서 사용한다. precision은 소수점을 포함한 전체 자릿수, scale은 소수의 자릿수다. double, float타입에는 적용되지 않는다.    | precision = 19, scale=2     |
| columnDefinition | 데이터베이스 컬럼 정보를 직접 줄 수 있다. | 필드의 자바 타입과 방언 정보를 사용해서 적절한 컬럼 타입을 생성한다.  |


<br/>

### 4.7.2 @Enumerated
자바의 enum 타입을 매핑할 때 사용한다.

<table>
    <thead>
        <tr>
            <th>속성</th>
            <th>기능</th>
            <th>기본값</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>value</td>
            <td style="word-break:break-all">EnumType.ORDINAL: enum 순서를 데이터베이스에 저장 <br/>
            EnumType.STRING: enum 이름을 데이터베이스에 저장
            </td>
            <td>EnumType.ORDINAL</td>
        </tr>
    </tbody>
</table>


### 4.7.3 @Temporal
날짜 타입(`java.util.Date`, `java.util.Calendar`)을 매핑할 때 사용한다.

<table>
    <thead>
        <tr>
            <th>속성</th>
            <th>기능</th>
            <th>기본값</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>value</td>
            <td style="word-break:break-all">
            - TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑 (예: 2013-10-11)
            <br/>
            - TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑 (예: 11:11:11)
            <br/>
            - TemporalType.TIMESTAMP: 날짜와 시간, 데이터베이스 timestamp 타입과 매핑 (예: 2013-10-11 11:11:11)
            </td>
            <td>TemporalType은 필수 지정</td>
        </tr>
    </tbody>
</table>

<br/>

### 4.7.4 @Lob
데이터베이스 BLOB, CLOB 타입과 매핑한다. 매핑하는 필드 타입에 따라 매핑을 달리한다.
- CLOB: String, char[], java.sql.CLOB
- BLOB: byte[], java.sql.BLOB

<br/>

### 4.7.5 @Transient
이 필드는 매핑하지 않는다. 따라서 데이터베이스에 저장하지 않고 조회하지 않는다.

<br/>

### 4.7.6 @Access
JPA가 엔티티 데이터에 접근하는 방식을 지정한다.
- AccessType.FIELD: 필드 접근
- AccessType.PROPERTY: 프로퍼티 접근, 접근자(Getter) 사용

```java
@Entity
@Access(AccessType.FIELD)
public class Member {...}
```
```java
@Entity
@Access(AccessType.PROPERTY)
public class Member {...}
```
```java
/**
 * 두 접근 방식을 함께 사용할 수도 있다.
 *
 * @Id는 필드 접근 방식
 * getFullName()는 프로퍼티 접근 방식
 * Member 엔티티를 저장하면 테이블의 FULLNAME 컬럼에
 * firstName + lastName의 결과가 저장된다.
 */
@Entity
public class Member {
    
    @Id
    private String id;

    @Transient
    private String firstName;

    @Transient
    private String lastName;

    @Access(AccessType.PROPERTY)
    public String getFullName() {
        return firstName + lastName;
    }
    ...
}
```

<br/>
<br/>

## 4.8 정리
- 객체와 테이블 매핑, 기본 키 매핑, 필드와 컬럼 매핑
- 데이터베이스 스키마 자동 생성 기능

<br/>
<br/>
<br/>




# 5. 연관관계 매핑 기초
연관관계 매핑 키워드 정리
- 방향(Direction): **[단방향, 양방향]**이 있다. 방향은 객체관계에서만 존재하고 테이블 관계는 항상 양방향이다.
- 다중성(Multiplcity): **[다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)]** 다중성이 있다.
- 연관관계 주인(Owner): **객체를 양방향 연관관계로 만들면 연관관계 주인을 정해야 한다.**

<br/>

## 5.1 단방향 연관관계
<center><img src="/assets/images/posts/books/2/5_1_객체테이블연관관계.png" width="100%" height="100%"></center>

<br/>

**객체 연관관계와 테이블 연관관계의 차이**  
- 객체
  - 참조(주소)로 연관관계를 맺는다.
  - 언제나 단방향
  - 양방향을 하려면 서로다른 단방향 관계 2개로 구현
- 테이블
  - 외래 키로 연관관계를 맺는다.
  - 외래 키 하나로 양방향 조인 가능


<br/>

### 5.1.1 순수한 객체 연관관계
객체 참조를 사용해서 연관관계를 탐색할 수 있는데 이것을 **객체 그래프 탐색**이라 한다.
```java
public static void main(String[] args) {
    Member member1 = new Memeber("member1", "회원1");
    Member member2 = new Memeber("member2", "회원1");
    Team team = new Team("team", "팀");

    member1.setTeam(team);
    member2.setTeam(team);

    // 객체 그래프 탐색
    Team findTeam = member1.getTeam();
}
```

<br/>

### 5.1.2 테이블 연관관계
외래 키를 사용해서 연관관계를 탐색할 수 잇는데 이것을 조인이라 한다.
```sql
SELECT T.*
FROM MEMBER M
    JOIN TEAM T ON M.TEAM_ID = T.ID
WHERE M.MEMBER_ID = 'member1'
```

<br/>

### 5.1.3 객체 관계 매핑

```java
@Entity
public class Member {

    @Id
    @Column(name = "MEMBER_ID")
    private Long id;

    private String username;

    //연관 관계 매핑
    @ManyToOne
    @JoinColumn(name="TEAM_ID")
    private Team team;

    //연관관계 설정
    public void setTeam(Team team) {
        this.team = team;
    }
    ...생략...
}
```
```java
@Entity
public class Team {
    
    @Id
    @Column(name = "TEAM_ID")
    private String id;
    ...생략...
}
```

<br/>

**@ManyToOne**  
- 다대일(N:1) 관계라는 매핑 정보
- 연관관계 매핑할 때 다중성을 나타내는 어노테이션 필수로 사용해야 한다.

<br/>

**@JoinColumn(name="TEAM_ID")**  
- 조인컬럼은 외래 키를 매핑할 때 사용한다.
- name 속성에 매핑할 외래 키 이름을 지정한다. (여기선 팀 테이블의 TEAM_ID)
- 생략할 수 있다.


<br/>

### 5.1.4 @JoinColumn
@JoinColumn은 외래 키를 매핑할 때 사용한다.

| **속성**                                                           | **기능**                                          | **기본값**                  |
| ---------------------------------------------------------------- | ----------------------------------------------- | ------------------------ |
| name                                                             | 매핑할 외래 키 이름                                     | 필드명 + \_ + 참조하는 테이블의 컬러명 |
| referencedColumnName                                             | 외래 키가 참조하는 대상 테이블의 컬럼명                          | 참조하는 테이블의 기본 키 컬럼명       |
| foreignKey (DDL)                                                 | 외래 키 제약조건을 직접 지정할 수 있다. 이 속성은 테이블을 생성할 때만 사용한다. |                          |
| unique, nullable, insertable, updatable, columnDefinition, table | @Column의 속성과 같다.                                |                          |

<br/>

### 5.1.5 @ManyToOne
@ManyToOne 어노테이션은 다대일 관계에서 사용한다.

| **속성**                    | **기능**                                                             | **기본값**                                                |
| ------------------------- | ------------------------------------------------------------------ | ------------------------------------------------------ |
| optional                  | false로 설정하면 연관된 엔티티가 항상 있어야 한다.                                    | true                                                   |
| fetch                     | 글로벌 페치 전략을 설정한다.                                                   | @ManyToOne=FetchType.EAGER   @OneToMany=FetchType.LAZY |
| cascade                   | 영속성 전이 기능을 사용한다.                                                   |                                                        |
| targetEntity (거의 사용하지 않음) | 연관된 엔티티의 타입 정보를 설정한다. 이 기능을 사용하지 않고 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다. |                                                        |

<br/>
<br/>

## 5.2 연관관계 사용
연관관계를 등록, 수정, 삭제, 조회하는 예제를 통해 연관관계를 어떻게 사용하는지 알아본다.

### 5.2.1 저장
JPA에서 엔티티를 저장할때 **연관된 모든 엔티티는 영속 상태**여야 한다.

```java
public void testSave() {

    // 팀1 저장
    Team team1 = new Team("team1", "팀1");
    em.persist(team1);

    // 회원1 저장
    Member member1 = new Member("member1", "회원1");
    member1.setTeam(team1); //연관관계 설정 member1 -> team1
    em.persist(member1);

    // 회원2 저장
    Member member2 = new Member("member2", "회원2");
    member2.setTeam(team1); //연관관계 설정 member2 -> team1
    em.persist(member2);
}
```

<br/>

### 5.2.2 조회
연관관계가 있는 엔티티 조회 방법은 크게 2가지다.
- 객체 그래프 탐색(객체 연관관계를 사용한 조회)
- 객체지향 쿼리 사용(JPQL)

**객체 그래프 탐색**  

```java
Member member = em.find(Member.class, "member1");
Team team = member.getTeam(); // 객체 그래프 탐색
System.out.println("팀 이름 = " + team.getName());
```

<br/>

**객체 지향 쿼리 사용**  
```java
public static void testJPQL(EntityManager em) {
    String jpql1 = "select m from Member m join m.team t where t.name=:teamName";

    List<Member> resultList = em.createQuery(jpql1, Member.class)
        .setParameter("teamName", "팀1")
        .getResultList();

    for (Member member : resultList) {
        System.out.println("[query] member.username = " + member.getUsername());
    }
}

// 결과: [query] member.username=회원1
// 결과: [query] member.username=회원2
```
실행되는 SQL은 다음과 같다.
```sql
SELECT M.* FROM MEMBER MEMBER 
INNER JOIN 
    TEAM TEAM ON MEMBER.TEAM_ID = TEAM1_.ID 
WHERE
    TEAM1_.NAME='팀1'
```
실행된 SQL과 JPQL을 비교하면 **JPQL은 객체(엔티티)를 대상**으로 하고 SQL보다 간결하다.

<br/>

### 5.2.3 수정

```java
private static void updateRelation(EntityManager em) {

    // 새로운 팀2
    Team team2 = new Team("team2", "팀2");
    em.persist(team2);

    //회원1에 새로운 팀2 설정
    Member member = em.find(Member.class, "member1");
    member.setTeam(team2);
}
```
실행되는 수정 SQL은 다음과 같다.
```sql
UPDATE MEMBER
SET
    TEAM_ID='team2', ...
WHERE ID = 'member1' 
```



<br/>

### 5.2.4 연관관계 제거

```java
private static void deleteRelation(EntityManager em) {

    Member member1 = em.find(Member.class, "member1");
    member1.setTeam(null); //연관관계 제거
}
```
실행되는 연관관계 제거 SQL은 다음과 같다.
```sql
UPDATE MEMBER
SET
    TEAM_ID=null, ...
WHERE ID = 'member1' 
```


<br/>

### 5.2.5 연관관계 삭제
연관된 엔티티를 삭제하려면 기존에 있던 연관관계를 먼저 제거하고 삭제해야 한다. 그렇지 않으면 외래 키 제약조건으로 인해, 데이터베이스에서 오류가 발생한다.

```java
member1.setTeam(null); // 회원1 연관관계 제거
member2.setTeam(null); // 회원2 연관관계 제거
em.remove(team);       // 팀 삭제
```



<br/>
<br/>

## 5.3 양방향 연관관계

**객체**
<center><img src="/assets/images/posts/books/2/5_3_양방향객체연관관계1.png" width="100%" height="100%"></center>
- 회원과 팀은 다대일 관계
- 팀에서 회원의 관계는 일대다 관계

<br/>

**데이터베이스 테이블**
<center><img src="/assets/images/posts/books/2/5_3_양방향테이블연관관계.png" width="100%" height="100%"></center>
- 데이터베이스 테이블은 외래 키 하나로 양방향 조회


<br/>

### 5.3.1 양방항 연관관계 매핑

```java
@Entity
public class Member {
    ...생략...

    // 연관 관계 매핑
    @ManyToOne
    @JoinColumn(name="TEAM_ID")
    private Team team;

    ...생략...
}
```
```java
@Entity
public class Team {
    ...생략...

    // @OneToMany 매핑 정보를 사용했다.
    // mappedBy 속성은 양방향 매핑일 때 사용하는데 반대쪽 매핑의 필드 이름을 값으로 주면 된다.
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<Member>();
    
    ...생략...  
}
```

<br/>
<br/>

## 5.4 연관관계 주인
- 객체에는 양방향 연관관계라는 것이 없다.
- 서로 다른 단방향 연관관계 2개를 양방향인 것처럼 보이게 할 뿐이다.
- 엔티티를 양방향 연관관계로 설정하면 객체의 참조는 둘인데 왜래 키는 하나다.
- JPA에서는 **두 객체 연관관계 중 하나를 정해서 테이블의 외래 키를 관리해야 하는데 이것을 연관관계의 주인**이라 한다.

<br/>

### 5.4.1 양방향 매핑의 규칙: 연관관계의 주인
- 두 연관관계 중 하나를 연관관계 주인으로 정해야 한다.
- 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 왜래 키를 관리(등록,수정,삭제)할 수 있다.
- 주인이 아닌 쪽은 읽기만 할 수 있다.

<br/>

**mappedBy**  
- 주인은 `mappedBy` 속성을 사용하지 않는다.
- 주인이 아니면 `mappedBy` 속성을 사용해서 속성의 값으로 연관관계 주인을 지정한다.
- (상대편에게 매핑된다라고 이해하면 편하다. 실제로 그런 뜻 😂)

**연관관계 주인을 정한다는 것은 외래 키 관리자를 선택하는 것이다.**


<br/>
<br/>

### 5.4.2 연관관계의 주인은 외래 키가 있는 곳
<center><img src="/assets/images/posts/books/2/5_4_연관관계의주인과반대편.png " width="100%" height="100%"></center>

- 연관관계의 주인은 테이블에 외래 키가 있는 곳으로 정해야 한다.
- 다대일, 일대다 관계에서는 **항상 다 쪽이 외래 키를 가진다**.
- 다 쪽인 `@ManyToOne`은 항상 연관관계의 주인이 되므로 mappedBy를 설정할 수 없다.
- 따라서 `@ManyToOne`에는 `mappedBy` 속성이 없다.




<br/>
<br/>

## 5.5 양방향 연관관계 저장

```java
public void testSave() {

    // 팀1 저장
    Team team1 = new Team("team1", "팀1");
    em.persist(team1);

    // 회원1 저장
    Member member1 = new Member("member1", "회원1");
    member1.setTeam(team1); //연관관계 설정 member1 -> team1
    em.persist(member1);

    // 회원2 저장
    Member member2 = new Member("member2", "회원2");
    member2.setTeam(team1); //연관관계 설정 member2 -> team1
    em.persist(member2);
}
```
```java
// 주인이 아닌 곳에 입력된 값은 외래 키에 영향을 주지 않는다. 
team1.getMembers().add(member1); //무시(연관관계의 주인이 아님)
team1.getMembers().add(member2); //무시(연관관계의 주인이 아님)
```
```java
// Member.team은 연관관계의 주인이다.
// 엔티티 매니저는 이곳에 입력된 값을 사용해 외래 키 관리한다.
member1.setTeam(team1); //연관관계 설정(연관관계의 주인)
member2.setTeam(team1); //연관관계 설정(연관관계의 주인)
```




<br/>
<br/>

## 5.6 양방향 연관관계의 주의점
가장 흔한 실수는 연관관계 주인에는 값을 입력하지 않고, 주인이 아닌 곳에만 값을 입력하는 것
```java
public void testSaveNonOwner() {

    // 회원1 저장
    Member member1 = new Member("member1", "회원1");
    em.persist(member1);

    // 회원2 저장
    Member member2 = new Member("member2", "회원2");
    em.persist(member2);

    Team team1 = new Team("team1", "팀1");

    // 주인이 아닌 곳에 연관관계 설정
    team1.getMembers().add(member1);
    team2.getMembers().add(member2);

    em.persist(team1);
}
```
조회 결과는 다음과 같다.

| **MEMBER_ID** | **USERNAME** | **TEAM_ID** |
| ------------- | ------------ | ----------- |
| member1       | 회원1          | null        |
| member2       | 회원2          | null        |



<br/>

### 5.6.1 순수한 객체까지 고려한 양방향 연관관계
그렇다면 정말 연관관계의 주인에만 값을 저장하고 주인이 아닌 곳에는 값을 저장하지 않아도 될까? **객체 관점에서는 양쪽 방향 모두 값을 입력해주는 것이 가장 안전하다.**

```java
member1.setTeam(team1); // 회원 -> 팀
team1.getMembers().add(member1); // 팀 -> 회원
```

<br/>

### 5.6.2 연관관계 편의 메소드
한 번에 양방향 관계를 설정하는 메소드를 연관관계 편의 메소드라 한다. 이렇게 하면 실수도 줄어들고 좀 더 편하게 양방향 연관관계를 설정할 수 있다.

```java
public class Member {

    private Team team;

    public void setTeam(Team team) {
        this.team = team;
        team.getMembers().add(this);
    }
}
```

<br/>

### 5.6.3 연관관계 편의 메소드 작성 시 주의사항
연관관계를 변경할 때는 기존 팀이 있으면 기존 팀과 회원의 연관관계를 작제하는 코드를 추가해야 한다.

```java
member1.setTeam(teamA); // 1
member1.setTeam(teamB); // 2
Member findMember = teamA.getMember(); // member1이 여전히 조회된다.
```
```java
public void setTeam(Team team) {

    // 기존 팀과 관계를 제거
    if (this.team != null) {
        this.team.getMembers().remove(this);
    }    
    this.team = team;
    team.getMembers().add(this);
}
```



<br/>
<br/>

## 5.7 정리
- 단방향 매핑은 언제나 연관관계 주인이다.
- 양방향은 단방향에 주인이 아닌 연관관계를 하나 추가했을 뿐이다.
- 양방향의 장점은 반대방향으로 객체 그래프 탐색 기능이 추가된 것 뿐이다.
- 주인의 반대편은 `mappedBy`로 주인을 지정해야 한다.
- 주인의 반대편은 단순히 보여주는 일만 할 수 있다.
- 연관관계 주인은 외래 키의 위치와 관련해서 정해야지 비즈니스 중요도로 접근하면 안된다.





<br/>
<br/>
<br/>

# 6. 다양한 연관관계 매핑
엔티티 연관관계를 매핑할 때 고려사항  

- **다중성**
  - 다대일(@ManyToOne)
  - 일대다(@OneToMany)
  - 일대일(@OneToOne)
  - 다대다(@ManyToMany)
- **단방향, 양방향**
  - 단방향: 한쪽만 참조하는 것
  - 양방향: 양쪽이 서로 참조하는 것
- **연관관계 주인**


<br/>

## 6.1 다대일
데이터베이스 테이블의 일대다 관계에서 외래 키는 항상 다쪽에 있다. 따라서 객체 양방향 관계에서 연관관계의 주인은 항상 다쪽이다.

### 6.1.1 다대일 단방향 [N:1]
<center><img src="/assets/images/posts/books/2/6_1_다대일단방향.png" width="100%" height="100%"></center>

- `@ManyToOne` 어노테이션을 사용해서 다대일 관계를 매핑한다.
- `@JoinColumn`은 필드를 외래 키와 매핑할 때 사용한다.

```java
public class Member {
    ...생략...
    @ManyToOne
    @JoinCoulmn(name="TEAM_ID")
    private Team team;
    ...생략...
}
```

<br/>

### 6.1.2 다대일 양방향 [N:1, 1:N]
<center><img src="/assets/images/posts/books/2/6_1_다대일양방향.png" width="100%" height="100%"></center>

```java
public class Member {
    ...생략...
    @ManyToOne
    @JoinCoulmn(name="TEAM_ID")
    private Team team;

    public void setTeam(Team team) {
        this.team = team;

        // 무한루프에 빠지지 않도록 체크
        if(!team.getMembers().contains(this)) {
            team.getMembers().add(this);
        }
    }
    ...생략...
}
```
```java
public class Team {
    ...생략...
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();

    public void addMember(Member member) {
        this.members.add(member);

        // 무한루프에 빠지지 않도록 체크
        if (member.getTeam() != this) {
            member.setTeam(this);
        }
    }
    ...생략...
}
```
- 양방향은 외래 키가 있는 쪽이 연관관계 주인이다.
- 양방향 연관관계는 항상 서로를 참조해야 한다.


<br/>
<br/>

## 6.2 일대다
일대다 관계는 엔티티를 하나 이상 참조할 수 있으므로 자바 컬렉션인 Collection, List, Set, Map 중에 하나를 사용해야 한다.

### 6.2.1 일대다 단방향 [1:N]
<center><img src="/assets/images/posts/books/2/6_1_일대다단방향.png" width="100%" height="100%"></center>

```java
public class Team {
    ...생략...
    @OneToMany(mappedBy = "team")
    @JoinColumn(name = "TEAM_ID") // MEMBER 테이블의 TEAM_ID (FK)
    private List<Member> members = new ArrayList<>();
    ...생략...
}
```
- 일대다 관계에서는 일이 연관관계의 주인이다.
- 일 쪽에서 외래키를 관리하겠다는 의미가 된다.
- 일대 다 단방향 관계를 매핑할 때는 `@JoinColumn`을 명시해야 한다.
- 그렇지 않으면 JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인 테이블 전략을 기본으로 사용한다.

**문제점**  
- 엔티티를 매핑한 테이블이 아닌 다을 테이블의 외래 키를 관리해야 한다.
- 성능 문제

```java
Member member1 = new Memeber("member1");
Member member2 = new Memeber("member2");

Team team1 = new Team("team1");
team1.getMembers().add(member1);
team1.getMembers().add(member2);

em.persist(member1); // INSERT MEMBER1
em.persist(member2); // INSERT MEMBER2
em.persist(team1); // INSERT TEAM, UPDATE MEMBER1, UPDATE MEMBER2

tx.commit();
```
```sql
-- 업데이트 쿼리가 추가된다.
insert into Member (MEMBER_ID, username) values (null, ?);
insert into Team (TEAM_ID, name) values (null, ?);
update Member set TEAM_ID=? where MEMBER_ID=?
```

**일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자**  



<br/>

### 6.2.2 일대다 양방향 [1:N, N:1]
<center><img src="/assets/images/posts/books/2/6_2_일대다양방향.png" width="100%" height="100%"></center>

```java
public class Team {
    ...생략...
    @OneToMany
    @JoinColumn(name = "TEAM_ID")
    private List<Member> members = new ArrayList<>();
    ...생략...
}
```
```java
public class Member {
    ...생략...
    @ManyToOne
    @JoinCoulmn(name = "TEAM_ID",
        insertable = false, updatable = false) // 읽기 전용 매핑
    private Team team;
    ...생략...
}
```

- 일대다 단방향 매핑이 가지는 단점을 그대로 가진다.
- 될 수 있으면 **일대다 단방향 매핑을 사용하지 말고, 다대일 양방향 매핑을 사용하자.**


<br/>
<br/>

## 6.3 일대일 [1:1]
일대일 관계 특징
- 일대일 관계는 그 반대도 일대일 관계다.
- 테이블 관계에서 일대다, 다대일은 항상 다(N)쪽이 외래 키를 가진다. 반면 일대일 관계는 **주 테이블이나 대상 테이블 둘 중 어느 곳이나 외래 키를 가질 수 있다.**


### 6.3.1 주 테이블에 외래 키
주 테이블에 외래 키가 있는 단방향 관계를 먼저 살펴보고, 양방향 관계도 살펴 보자.

**단방향**  
<center><img src="/assets/images/posts/books/2/6_3_주테이블단방향.png" width="100%" height="100%"></center>

```java
@Entity
public class Member {

    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @OneToOne
    @JoinColumn(name = "LOCKER_ID")
    private Locker locker;
    ...생략...
}
```
```java
@Entity
public class Locker {
    @Id @GeneratedValue
    @Column(name = "LOCKER_ID")
    private Long id;

    ...생략...
}
```
- `@OneToOne`을 사용해 일대일 매핑한다.

<br/>

**양방향**  
<center><img src="/assets/images/posts/books/2/6_3_주테이블양방향.png" width="100%" height="100%"></center>

```java
@Entity
public class Member {

    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @OneToOne
    @JoinColumn(name = "LOCKER_ID")
    private Locker locker;
    ...생략...
}
```
```java
@Entity
public class Locker {
    @Id @GeneratedValue
    @Column(name = "LOCKER_ID")
    private Long id;

    @OneToOne(mappedBy = "locker") // 연관관계 주인 필드명을 선언
    private Member member;

    ...생략...
}
```

<br/>
<br/>

### 6.3.2 대상 테이블에 외래 키
대상 테이블에 외래 키가 있는 일대일 관계를 알아본다.

**단방향**  
<center><img src="/assets/images/posts/books/2/6_3_대상테이블단방향.png" width="100%" height="100%"></center>

- **일대일 단방향은 이런 매핑을 허용하지 않는다.**

<br/>

**양방향**  
<center><img src="/assets/images/posts/books/2/6_3_대상테이블양방향.png" width="100%" height="100%"></center>

```java
@Entity
public class Member {

    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @OneToOne(mappedBy = "member")
    private Locker locker;
    ...생략...
}
```
```java
@Entity
public class Locker {
    @Id @GeneratedValue
    @Column(name = "LOCKER_ID")
    private Long id;

    @OneToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;

    ...생략...
}
```

- **일대일 매핑에서 대상 테이블에 외래 키를 두고 싶으면** 이렇게 **양방향으로 매핑한다**.





<br/>
<br/>


## 6.4 다대다 [N:N]
<center><img src="/assets/images/posts/books/2/6_4_다대다1.png" width="100%" height="100%"></center>
테이블 2개로는 다대다 관계를 표현할 수 없다.

<br/>

<center><img src="/assets/images/posts/books/2/6_4_다대다2.png" width="100%" height="100%"></center>
중간에 연결 테이블을 추가해야 한다.

<br/>


### 6.4.1 다대다: 단방향

```java
@Entity
public class Member {

    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @ManyToMany
    @JoinTable(
        name = "MEMBER_PRODUCT", // 연결 테이블 지정
        joinColumn = @JoinColumn(name = "MEMBER_ID"), // 현재 엔티티와 매핑할 연결 테이블의 조인 컬럼
        inverseJoinColumns = @JoinColumn(name = "PRODUCT_ID") // 상대 엔티티와 매핑할 연결 테이블의 조인 컬럼
    )
    private List<Product> products = new ArrayList<Product>();
    ...생략...
}
```
```java
@Entity
public class Product {
    @Id @Column(name = "PRODUCT_ID")
    private Long id;
    ...생략...
}
```

<br/>

### 6.4.2 다대다: 양방향

```java
@Entity
public class Member {

    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @ManyToMany
    @JoinTable(
        name = "MEMBER_PRODUCT", // 연결 테이블 지정
        joinColumn = @JoinColumn(name = "MEMBER_ID"), // 현재 엔티티와 매핑할 연결 테이블의 조인 컬럼
        inverseJoinColumns = @JoinColumn(name = "PRODUCT_ID") // 상대 엔티티와 매핑할 연결 테이블의 조인 컬럼
    )
    private List<Product> products = new ArrayList<Product>();
    ...생략...
}
```
```java
@Entity
public class Product {
    @Id @Column(name = "PRODUCT_ID")
    private Long id;

    @ManyToMany(mappedBy = "products") // 역방향 추가
    private List<Member> members;
    ...생략...
}
```

<br/>

### 6.4.3 다대다: 매핑의 한계와 극복, 연결 엔티티 사용
연결테이블의 기본 키를 `@IdClass` 사용한 복합 키 사용 예제라서 넘김.

### 6.4.4 다대다: 새로운 기본 키 사용
- `@ManyToMany`는 편리하지만, 실무에서 사용하기에는 한계가 있다.
- 보통은 **연결 테이블에 새로운 컬럼이 추가되기 마련**이다.
- 결국 **연결 테이블을 매핑하는 연결 엔티티를 만들고 일대다, 다대일 관계로 풀어야 한다**.

```java
@Entity
public class Member {

    @Id @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @OneToMany(mappedBy = "member")
    private List<MemberProduct> memberProducts;
    ...생략...
}
```
```java
// 상품 엔티티에서 회원상품 엔티티로 객체 그래프 탐색 기능이 필요 없다 판단.
// 연관관계를 만들지 않았다.
@Entity
public class Product {
    @Id @Column(name = "PRODUCT_ID")
    private Long id;

    // @OneToMany(mappedBy = "product")
    // private List<MemberProduct> memberProducts = new ArrayList<>();
}
```
```java
@Entity
public class MemberProduct {

    @Id @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;

    @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    private Product product;
}
```

<br/>


### 6.4.5 다대다 연관관계 정리
- 다대다 관계를 일대다, 다대일 관계로 풀어낸다.
- 연결 테이블을 만들 때 식별자를 어떻게 구성할지 선택한다.
  - 식별 관계: 받아온 식별자를 기본 키 + 외래 키로 사용한다.
  - 비식별 관계: 받아온 식별자는 외래 키로만 사용하고 새로운 식별자를 추가한다. 추천 👍

## 6.5 정리
- 다대일, 일대다, 일대일, 다대다 연관관계를 단방향, 양방향으로 매핑하는 방법
- 다대다 연관관계를 일대다, 다대일 연관관계로 풀어보는 방법


<br/>
<br/>
<br/>



# 7. 고급 매핑
다룰 내용
- **상속 관계 매핑**: 객체의 상속 관계를 데이터베이스에 어떻게 매핑하는지
- **@MappedSuperclass**: 등록일, 수정일 같이 여러 엔티티에서 공통으로 사용하는 매핑 정보만 상속받고 싶을 때
- **복합 키와 식별 관계 매핑**: 데이터베이스의 식별자가 하나 이상일 때 매핑하는 방법
- **조인 테이블**: 연결 테이블을 매핑하는 방법
- **엔티티 하나에 여러 테이블 매핑**하는 방법


## 7.1 상속 관계 매핑
<center><img src="/assets/images/posts/books/2/7_1_객체상속모델.png" width="100%" height="100%"></center>

<br/>

슈퍼타입 서브타입 논리 모델을 테이블로 구현하는 3가지 방법
- 각각의 테이블로 변환: JPA에서는 **조인 전략**이라 한다.
- 통합 테이블로 변환: JPA에서는 **단일 테이블 전략**이라 한다.
- 서브타입 테이블로 변환: JPA에서는 **구현 클래스마다 테이블 전략**이라 한다.

<br/>

### 7.1.1 조인 전략
엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략
<center><img src="/assets/images/posts/books/2/7_1_조인전략.png" width="100%" height="100%"></center>

```java
@Entity
@Inheritance(strategy = InheritanceType.JOIN) // 부모 클래스에 상속 매핑, 전략 지정
@DiscriminatorColumn(name = "DTYPE") // 부모 클래스에 구분 컬럼 지정
public abstract class Item {

    @Id @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name; //이름
    private int price;   //가격
}
```
```java
@Entity
@DiscriminatorValue("A") // 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정
public class Album extends Item {

    private String artist;
}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {

    private String director;
    private String actor;
}

@Entity
@DiscriminatorValue("B")
@PrimaryKeyJoinColumn(name = "BOOK_ID") // 기본 키 컬럼명 변경, 기본값은 부모 테이블 ID 컬럼명
public class Book extends Item {

    private String author;
    private String isbn;
}
```

**장점**  
- 테이블이 정규화된다.
- 외래 키 참조 무결성 제약조건을 활용할 수 있다.
- 저장공간을 효율적으로 사용한다.

**단점**  
- 조회할 때 조인이 많이 사용되어 성능이 저하될 수 있다.
- 조회 쿼리가 복잡하다.
- 데이터를 등록할 때 INSERT SQL이 두 번 실행된다.

**특징**  
- `@DiscriminatorColumn` 없이도 동작한다.

**관련 어노테이션**  
- `@PrimaryKeyJoinColumn`, `@DiscriminatorColumn`, `@DiscriminatorValue`

<br/>
<br/>



### 7.1.2 단일 테이블 전략
<center><img src="/assets/images/posts/books/2/7_1_단일테이블전략.png" width="100%" height="100%"></center>

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 부모 클래스에 상속 매핑, 전략 지정
@DiscriminatorColumn(name = "DTYPE") // 부모 클래스에 구분 컬럼 지정
public abstract class Item {

    @Id @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}
```
```java
@Entity
@DiscriminatorValue("A")
public class Album extends Item {...}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {...}

@Entity
@DiscriminatorValue("B")
public class Book extends Item {...}
```

**장점**  
- 조인이 필요 없으므로 조회 성능이 빠르다.
- 조회 쿼리가 단순하다.

**단점**  
- 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 한다.
- 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 그러므로 상황에 따라서는 조회 성능이 오히려 느려질 수 있다.

**특징**  
- `@DiscriminatorColumn`을 꼭 설정해야 한다.
- `@DiscriminatorValue`를 지정하지 않으면 기본으로 엔티티 이름을 사용한다.

<br/>
<br/>



### 7.1.3 구현 클래스마다 테이블 전략
<center><img src="/assets/images/posts/books/2/7_1_구현클래스마다테이블전략.png" width="100%" height="100%"></center>

```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {

    @Id @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;

    private String name;
    private int price;
}
```
```java
@Entity
@DiscriminatorValue("A")
public class Album extends Item {...}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {...}

@Entity
@DiscriminatorValue("B")
public class Book extends Item {...}
```

**일반적으로 추천하지 않는 전략이다.**  

**장점**  
- 서브 타입을 구분해서 처리할 때 효과적이다.
- not null 제약 조건을 사용할 수 있다.

**단점**  
- 여러 자식 테이블을 함께 조회할 때 성능이 느리다. (UNION을 사용해야 한다)
- 자식 테이블을 통합해서 쿼리하기 어렵다.

**특징**  
- 구분 컬럼을 사용하지 않는다.

<br/>
<br/>


## 7.2 @MappedSuperclass
**부모 클래스는 테이블과 매핑하지 않고 자식 클래스에게 매핑 정보만 제공**하고 싶으면 `@MappedSuperclass`을 사용한다.

<center><img src="/assets/images/posts/books/2/7_2_mappedSuperclass.png" width="100%" height="100%"></center>

```java
// 공통 매핑 정보 정의
@MappedSuperclass
public abstract class BaseEntity {

    @Id @GeneratedValue
    private Long id;
    private String name;
}
```
```java
@Entity
public class Member extends BaseEntity {
    private String email;
}
@Entity
public class Seller extends BaseEntity {
    private String shopName;
}
```

<br/>

- 연관관계를 재정의 하려면 `@AssociationOverrides`, `@AssociationOverride` 사용한다.
- **부모로부터 물려받은 매핑 정보를 재정의 하려면 `@AttributeOverrides`, `@AttributeOverride` 사용한다.**

```java
// 매핑 정보 재정의
// 부모에게 상속받은 id 속성의 컬럼명을 MEMBER_ID로 재정의
@Entity
@AttributeOverride(name = "id", column = @Column(name = "MEMBER_ID"))
public class Member extends BaseEntity {
    private String email;
}
```
```java
// 둘 이상의 매핑 정보 재정의
@Entity
@AttributeOverrides({
    @AttributeOverride(name = "id", column = @Column(name = "MEMBER_ID")),
    @AttributeOverride(name = "name", column = @Column(name = "MEMBER_NAME"))
})

public class Member extends BaseEntity {
    private String email;
}
```

**@MappedSuperclass 특징**
- 테이블과 매핑되지 않는다.
- 자식 클래스에게 엔티티의 매핑 정보를 상속하기 위해 사용한다.
- 엔티티가 아니므로 `em.find()`, `JPQL`에서 사용할 수 없다.
- 직접 생성해서 사용할 일이 거의 없으므로 추상 클래스로 만드는 것을 권장한다.
- 등록일자, 수정일자, 등록자, 수정자 같은 곹오 속성을 효과적으로 관리할 수 있다.

<br/>

## 7.3 복합 키와 식별 관계 매핑
복합 키를 매핑하는 방법과 식별 관계, 비식별 관계를 매핑하는 방법을 알아본다.

### 7.3.1 식별 관계 vs 비식별 관계
**식별 관계**  
부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용하는 관계다.
<center><img src="/assets/images/posts/books/2/7_3_식별관계.png" width="100%" height="100%"></center>

<br/>

**비식별 관계**  
부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계다.
<center><img src="/assets/images/posts/books/2/7_3_비식별관계.png" width="100%" height="100%"></center>
- 필수적 비식별 관계(Mandatory): 외래 키에 null을 허용하지 않는다. 연관관계를 필수적으로 맺어야 한다.
- 선택적 비식별 관계(Optional): 외래 키에 null을 허용한다. 연관관계를 맺을지 말지 선택할 수 있다.

**최근에는 비식별 관계를 주로 사용하고 꼭 필요한 곳에만 식별 관계를 사용하는 추세**

<br/>
<br/>




### 7.3.2 복합 키: 비식별 관계 매핑
JPA는 복합 키를 지원하기 위해 다음 2가지 방법을 제공한다. 
- `@IdClass`: 관계형 데이터베이스에 가까운 방법
- `@EmbeddedId`: 객체지향에 가까운 방법

<br/>

**@IdClass**  
<center><img src="/assets/images/posts/books/2/7_3_복합키테이블.png" width="100%" height="100%"></center>

```java
@Entity
@IdClass(ParentId.class)
public class Parent {

    @Id
    @Column(name = "PARENT_ID1")
    private String id1;

    @Id
    @Column(name = "PARENT_ID2")
    private String id1;
}
```
```java
public class ParentId implements Serializable {
    private String id1;
    private String id2;

    public ParentId() {}

    ...

    @Override
    public boolean equals (Object o) {...}

    @Override
    public int hashCode() {...}
}
```

**@IdClass를 사용할 때 식별자 클래스는 다음 조건을 만족해야 한다.**
- 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야 한다.
- `Serializable` 인터페이스를 구현해야 한다.
- `equals`, `hashCode`를 구현해야 한다.
- 기본 생성자가 있어야 한다.
- 식별자 클래스는 `public`이어야 한다.

**사용방법**
```java
// 저장
Parent parent = new Parent();
parent.setId1("1");
parent.setId2("2");

em.persist(parent);
```
```java
// 조회
ParentId parentId = new ParentId("1","2");
Parent parent = em.find(Parent.class, parentId);
```

<br/>

**자식 클래스**  
자식 테이블에서 외래 키 매핑 방법
```java
@Entity
public class Child {

    @Id
    private String id;

    @ManyToOne
    @JoinColumns({
        @JoinColumn(name = "PARENT_ID1", referencedColumnName = "PARENT_ID1"),
        @JoinColumn(name = "PARENT_ID2", referencedColumnName = "PARENT_ID2")
    })
    private Parent parent;
}
```

<br/>
<br/>




**@EmbeddedId**
```java
@Entity
public class Parent {

    @EmbeddedId
    private ParentId id;
}
```
```java
@Embeddable
public class ParentId implements Serializable {

    @Column(name = "PARENT_ID1")
    private String id1;
    @Column(name = "PARENT_ID2")
    private String id2;

    public ParentId() {}

    ...

    @Override
    public boolean equals (Object o) {...}

    @Override
    public int hashCode() {...}
}
```

**@EmbeddedId를 사용할 때 식별자 클래스는 다음 조건을 만족해야 한다.**
- `@Embeddable` 어노테이션을 붙여주어야 한다.
- `Serializable` 인터페이스를 구현해야 한다.
- `equals`, `hashCode`를 구현해야 한다.
- 기본 생성자가 있어야 한다.
- 식별자 클래스는 `public`이어야 한다.

**사용방법**
```java
// 저장
Parent parent = new Parent();
ParentId parentId = new ParentId("1","2");
parent.setId(parentId);

em.persist(parent);
```
```java
// 조회
ParentId parentId = new ParentId("1","2");
Parent parent = em.find(Parent.class, parentId);
```

<br/>
<br/>



**복합 키와 equals(), hashCode()**  
- 영속성 컨텍스트는 엔티티의 식별자를 키로 사용해서 엔티티를 관리한다.
- 식별자를 비교할 때 `equals()`, `hashCode()`를 사용한다.
- 따라서 식별자 객체의 동등성이 지켜져야 한다.

<br/>

**@IdClass vs @EmbeddedId**
- `@IdClass`: 관계형 데이터베이스에 가까운 방법
- `@EmbeddedId`: 객체지향에 가까운 방법

```java
// JPQL
em.createQuery("select p.id.id1, p.id.id2 from Parent p"); // @EmbeddedId
em.createQuery("select p.id1, p.id2 from Parent p"); // @IdClass
```

**참고**  
복합 키에는 `@GenerateValue`를 사용할 수 없다. 복합 키를 구성하는 여러 컬럼중 하나에도 사용할 수 없다.

<br/>
<br/>


### 7.3.3 복합 키: 식별 관계 매핑
<center><img src="/assets/images/posts/books/2/7_3_식별관계구현.png" width="100%" height="100%"></center>

```java
// 부모
@Entity
public class Parent {

    @Id
    @Column(name = "PARENT_ID")
    private String id;
}
```
```java
// 자식
@Entity
@IdClass(ChildId.class)
public class Child {

    @Id
    @ManyToOne
    @JoinColumn(name = "PARENT_ID")
    private Parent parent;

    @Id @Column(name = "CHILD_ID")
    private String childId;
}

// 자식 ID
public class ChildId implements Serializable {
    
    private String parent;
    private String childId;
    ...생략...
}
```
```java
// 손자
@Entity
@IdClass(GrandChildId.class)
public class GrandChild {

    @Id
    @ManyToOne
    @JoinColumns({
        @JoinColumn(name = "PARENT_ID"),
        @JoinColumn(name = "CHILD_ID")
    })
    private Child child;

    @Id @Column(name = "GRANDCHILD_ID")
    private String id;
}

// 손자 ID
public class GrandChildId implements Serializable {
    
    private ChildId child;
    private String id;
    ...생략...
}
```

<br/>
<br/>



**@EmbeddedId와 식별 관계**  
```java
// 부모
@Entity
public class Parent {

    @Id
    @Column(name = "PARENT_ID")
    private String id;
}
```
```java
// 자식
@Entity
public class Child {

    @EmbeddedId
    private ChildId id;

    @MapsId("parentId")
    @ManyToOne
    @JoinColumn(name = "PARENT_ID")
    private Parent parent;
}

// 자식 ID
@Embeddable
public class ChildId implements Serializable {
    
    private String parentId; // @MapsId("parentId")로 매핑
    
    @Column(name = "CHILD_ID")
    private String id;
    ...생략...
}
```
```java
// 손자
@Entity
public class GrandChild {

    @EmbeddedId
    private GrandChildId id;

    @MapsId("childId")
    @ManyToOne
    @JoinColumns({
        @JoinColumn(name = "PARENT_ID"),
        @JoinColumn(name = "CHILD_ID")
    })
    private Child child;
}

// 손자 ID
@Embeddable
public class GrandChildId implements Serializable {
    
    private ChildId childId; // @MapsId("childId")로 매핑
    
    @Column(name = "GRANDCHILD_ID")
    private String id;
    ...생략...
}
```

<br/>
<br/>



### 7.3.4 비식별 관계로 구현
<center><img src="/assets/images/posts/books/2/7_3_비식별관계구현.png" width="100%" height="100%"></center>

식별 관계의 복합 키를 사용한 코드와 비교하면 매핑도 쉽고 코드도 단순하다.
```java
// 부모
@Entity
public class Parent {

    @Id @GeneratedValue
    @Column(name = "PARENT_ID")
    private Long id;
}
```
```java
// 자식
@Entity
public class Child {

    @Id @GeneratedValue
    @Column(name = "CHILD_ID")
    private Long id;

    @ManyToOne
    @JoinColumn(name = "PARENT_ID")
    private Parent parent;
}
```
```java
// 손자
@Entity
public class GrandChild {

    @Id @GeneratedValue
    @Column(name = "GRANDCHILD_ID")
    private Long id;

    @ManyToOne
    @JoinColumn(name = "CHILD_ID")
    private Child child;
}
```

<br/>
<br/>




### 7.3.5 일대일 식별 관계
<center><img src="/assets/images/posts/books/2/7_3_식별관계일대일.png" width="100%" height="100%"></center>

일대일 식별 관계는 자식 테이블의 기본 키 값으로 부모 테이블의 기본 키 값만 사용한다.

```java
// 부모
@Entity
public class Board {

    @Id @GeneratedValue
    @Column(name = "BOARD_ID")
    private Long id;

    @OneToOne(mappedBy = "board")
    private BoardDetail boardDetail;
}
```
```java
@Entity
public class BoardDetail {

    @Id
    private Long boardId;

    // 식별자가 단순히 컬럼 하나면 @MapsId를 사용하고 속성 값은 비워두면 된다.
    @MapsId // BoardDetail.boardId 매핑
    @OneToOne
    @JoinColumn(name = "BOARD_ID")
    private Board board;
}
```

**사용방법**  
```java
Board board = new Board();
em.persist(board);

BoardDetail boardDetail = new BoardDetail();
boardDetail.setBoard(board);
em.persist(boardDetail);
```

<br/>
<br/>



### 7.3.6 식별, 비식별 관계의 장단점

**식별 관계 장점**  
- 특정 상황에서 조인 없이 하위 테이블만으로 검색할 수 있다.

**식별 관계 단점**  
- 식별 관계는 부모 테이블의 기본 키를 자식 테이블로 전파하면서 자식 테이블의 기본 키 컬럼이 점점 늘어난다.
  - **SQL복잡, 기본 키 인덱스가 커짐**
- 식별 관계는 복합 기본 키를 만들어야 하는 경우가 많다.
- 식별 관계를 사용할 때 기본 키로 **비즈니스 의미가 있는 자연 키 컬럼을 조합 하는 경우가 많다**.
  - **비즈니스 요구사항은 언제나 변할 수 있다**.
- 식별 관계는 **테이블 구조가 유연하지 못하다**.
- 식별 관계는 일대일 관계를 제외하고 별도의 복합 키 클래스를 사용한다.
  - **기본 키 매핑에 많은 노력이 필요하다.**

<br/>

**비식별 관계 장점**  
- `@GenerateValue`처럼 편리한 대리 키 생성 방법 사용 가능
- 식별자 컬럼이 하나여서 매핑이 쉽다.

**비식별 관계 단점**  
- JPQL 조회시 길어질 수 있다.

<br/>

**결론**  
비식별 관계를 사용하고 기본 키는 `Long` 타입의 대리 키를 사용한다.

<br/>
<br/>




## 7.4 조인 테이블
데이터베이스 테이블의 연관관계를 설계하는 방법은 크게 2가지다.

**조인 컬럼**
<center><img src="/assets/images/posts/books/2/7_4_조인컬럼사용.png" width="100%" height="100%"></center>

<br/>

**조인 테이블**
<center><img src="/assets/images/posts/books/2/7_4_조인테이블사용.png" width="100%" height="100%"></center>

<br/>

**추천 방법**  
기본은 조인 컬럼을 사용하고 필요하다고 판단되면 조인 테이블을 사용하자.

<br/>
<br/>




### 7.4.1 일대일 조인 테이블
<center><img src="/assets/images/posts/books/2/7_4_조인테이블일대일.png" width="100%" height="100%"></center>

```java
// 부모
@Entity
public class Parent {

    @Id @GeneratedValue
    @Column(name = "PARENT_ID")
    private Long id;


    @OneToOne
    @JoinTable(
        name = "PARENT_CHILD",
        joinColumn = @JoinColumn(name = "PARENT_ID"),
        inverseJoinColumns = @JoinColumn(name = "CHILD_ID")
    )
    private Child child;
}
```
```java
// 자식
@Entity
public class Child {

    @Id @GeneratedValue
    @Column(name = "CHILD_ID")
    private Long id;

    // 양방향으로 매핑하려면 다음 코드를 추가한다.
    // @OneToOne(mappedBy = "child")
    // private Parent parent;
}
```
<br/>
<br/>



### 7.4.2 일대다 조인 테이블
<center><img src="/assets/images/posts/books/2/7_4_조인테이블일대다.png" width="100%" height="100%"></center>

```java
// 부모
@Entity
public class Parent {

    @Id @GeneratedValue
    @Column(name = "PARENT_ID")
    private Long id;


    @OneToMany
    @JoinTable(
        name = "PARENT_CHILD",
        joinColumn = @JoinColumn(name = "PARENT_ID"),
        inverseJoinColumns = @JoinColumn(name = "CHILD_ID")
    )
    private List<Child> child = new ArrayList<Child>();
}
```
```java
// 자식
@Entity
public class Child {

    @Id @GeneratedValue
    @Column(name = "CHILD_ID")
    private Long id;
}
```
<br/>
<br/>



### 7.4.2 다대일 조인 테이블

```java
// 부모
@Entity
public class Parent {

    @Id @GeneratedValue
    @Column(name = "PARENT_ID")
    private Long id;


    @OneToMany(mappedBy = "parent")
    private List<Child> child = new ArrayList<Child>();
}
```
```java
// 자식
@Entity
public class Child {

    @Id @GeneratedValue
    @Column(name = "CHILD_ID")
    private Long id;

    @ManyToOne
    @JoinTable(
        name = "PARENT_CHILD",
        joinColumn = @JoinColumn(name = "CHILD_ID"),
        inverseJoinColumns = @JoinColumn(name = "PARENT_ID")
    )
    private Parent parent;
}
```
<br/>
<br/>




### 7.4.4 다대다 조인 테이블

```java
// 부모
@Entity
public class Parent {

    @Id @GeneratedValue
    @Column(name = "PARENT_ID")
    private Long id;


    @ManyToMany
    @JoinTable(
        name = "PARENT_CHILD",
        joinColumn = @JoinColumn(name = "PARENT_ID"),
        inverseJoinColumns = @JoinColumn(name = "CHILD_ID")
    )
    private List<Child> child = new ArrayList<Child>();
}
```
```java
// 자식
@Entity
public class Child {

    @Id @GeneratedValue
    @Column(name = "CHILD_ID")
    private Long id;
}
```
<br/>
<br/>
<br/>





## 7.5 엔티티 하나에 여러 테이블 매핑
`@SecondaryTable`을 사용하면 한 엔티티에 여러 테이블을 매핑할 수 있다.

<center><img src="/assets/images/posts/books/2/7_5_하나의엔티티에여러테이블매핑.png" width="100%" height="100%"></center>

```java
@Entity
@Table(name="BOARD")
@SecondaryTable( 
    name = "BOARD_DETAIL",
    pkJoinColumns = @PrimaryKeyJoinColumn(name = "BOARD_DETAIL_ID")
)
public class Board {
    
    @Id @GeneratedValue
    @Column(name = "BOARD_ID")
    private Long id;

    private String title;

    @Column(name = "BOARD_DETAIL")
    private String content;
}
```

- `@SecondaryTable.name`: 매핑할 다른 테이블 이름
- `@SecondaryTable.pkJoinColumns`: 매핑할 다른 테이블의 기본 키 컬럼 속성

```java
// 여러개 가능
@SecondaryTables({
    @SecondaryTable(name="BOARD_DETAIL"),
    @SecondaryTable(name="BOARD_FILE")
})
```
`@SecondaryTable`을 사용하는 것보단 **테이블당 엔티티를 각각 만들어서 사용하는 것을 권장한다.**

<br/>
<br/>



## 7.6 정리
- 객체의 상속 관계를 데이터베이스에 매핑하는 방법
- `@MappedSuperclass`
- 복합 키를 매핑하는 방법
- 데이터베이스의 식별 관계, 비식별 관계
- 조인 테이블
- 엔티티 하나에 여러 테이블 매핑하는 방법

<br/>
<br/>
<br/>





# 8. 프록시와 연관관계 관리
- 프록시와 즉시로딩, 지연로딩
- 영속성 전이와 고아 객체

## 8.1 프록시
- 엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다.
- 사용하지 않는 엔티티를 함께 조회해 두는 것은 효율적이지 않다.
- JPA는 이런 문제를 해결하려고 지연 로딩을 제공한다.
- 지연 로딩이란 실제 사용하는 시점에 데이터베이스를 조회하는 것이다.
- 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 가짜 객체가 필요한데 이것을 프록시 객체라 한다.


### 8.1.1 프록시 기초
**프록시의 특징** 
<center><img src="/assets/images/posts/books/2/8_1_프록시구조.png" width="100%" height="100%"></center>

- 프록시 클래스는 실제 클래스를 상속 받아서 만들어진다.
- 따라서 사용하는 입장에서는 이것이 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다.
- 프록시 객체는 실제 객체에 대한 참조를 보관한다.
- 프록시 객체의 메소드를 호출하면, 프록시 객체는 실제 객체의 메소드를 호출한다.
- 프록시 객체는 처음 사용할 때 한 번만 초기화 한다.

<br/>

**프록시 객체의 초기화**  
<center><img src="/assets/images/posts/books/2/8_1_프록시초기화.png" width="100%" height="100%"></center>

- 프록시 객체는 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다.
- 이를 프록시 객체의 초기화라 한다.

<br/>

**준영속 상태와 초기화**  
```java
// em.getReference()를 호출하면 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미룬다.
// MemberProxy 반환
Member member = em.getReference(Member.class, "id1");

tx.commit();
em.close(); // 영속성 컨텍스트 종료
member.getName(); // 준영속 상태에서 초기화 시도
                  // org.hibernate.LazyInitializationException 발생
```
<br/>
<br/>




### 8.1.2 프록시와 식별자
엔티티를 프록시로 조회할 때 식별자(PK) 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관한다.

```java
Team team = em.getReference(Team.class, "team1"); // 식별자 보관
team.getId(); // 초기화되지 않음
```
단 `@Access(AccessType.PROPERTY)`일 때만 위처럼 동작하고, `@Access(AccessType.FIELD)`로 설정하면 프록시 객체를 초기화 한다.

<br/>



### 8.1.3 프록시 확인
JPA가 제공하는 `PersistenceUnitUtil.isLoaded(Object entity)` 메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인할 수 있다.

```java
boolean isLoad = em.getEntityManagerFactory()
                .getPersistenceUnitUtil().isLoaded(entity);
```
<br/>
<br/>




## 8.2 즉시 로딩과 지연 로딩
JPA는 개발자가 연관된 엔티티의 조회 시점을 선택할 수 있도록 다음 두 가지 방법을 제공한다.
- 즉시 로딩: 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.
  - 설정 방법: `@ManyToOne(fetch = FetchType.EAGER)`
- 지연 로딩: 연관된 엔티티를 실제 사용할 때 조회한다.
  - 설정 방법: `@ManyToOne(fetch = FetchType.LAZY)`

<br/>



### 8.2.1 즉시 로딩
즉시 로딩을 사용하려면 `@ManyToOne(fetch = FetchType.EAGER)`로 지정한다.

```java
@Entity
public class Member {
    ...생략...
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    ...생략...
}
```

**NULL 제약조건과 JPA 조인 전략**
- @JoinColumn(nullable=true): null 허용(기본값), 외부 조인 SQL 사용
- @JoinColumn(nullable=false): null 허용하지 않음, 내부 조인 SQL 사용

<br/>




### 8.2.2 지연 로딩
지연 로딩을 사용하려면 `@ManyToOne(fetch = FetchType.LAZY)`로 지정한다. 지연 로딩은 프록시 객체를 이용한다.

```java
@Entity
public class Member {
    ...생략...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    ...생략...
}
```
**참고**  
조회 대상이 영속성 컨텍스트에 이미 있으면 프록시 객체를 사용할 이유가 없다. 따라서 실제 객체를 사용한다.

<br/>



### 8.2.3 즉시 로딩, 지연 로딩 정리
- 지연 로딩: 연관된 엔티티를 프록시로 조회한다. 프록시를 실제 사용할 때 초기화하면서 데이터베이스를 조회한다.
- 즉시 로딩: 연관된 엔티티를 즉시 조회한다. 하이버네이트는 가능하면 SQL 조인을 사용해서 한 번에 조회한다.

<br/>
<br/>




## 8.3 지연 로딩 활용
- 연관된 엔티티가 자주 함께 사용되는지 아닌지에 따라 즉시 로딩, 지연 로딩을 결정한다.

### 8.3.1 프록시와 컬렉션 래퍼
컬렉션의 지연 로딩
```java
Member member = em.find(Member.class, "member1");
List<Order> = member.getOrders();
System.out.println(orders.getClass().getName());
// org.hibernate.collection.internal.PersistenBag
```
<br/>


### 8.3.2 JPA 기본 페치 전략
- `@ManyToOne`, `@OneToOne`: 즉시 로딩(FetchType.EAGER)
- `@OneToMany`, `@ManyToMany`: 지연 로딩(FetchType.LAZY)
**추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것이다.** 그리고 꼭 필요한 곳에만 즉시 로딩을 사용하도록 한다.

<br/>


### 8.3.3 컬렉션에 FetchType.EAGER 사용 시 주의점
컬렉션에 `FetchType.EAGER`를 사용할 경우 주의할 점은 다음과 같다.
- **컬렉션을 즉시 로딩하는 것은 권장하지 않는다**.
  - 너무 많은 데이터를 반환할 수 있고, 결과적으로 **성능이 저하될 수 있다**.
- 컬렉션 즉시 로딩은 항상 `OUTER JOIN`을 사용한다.
- `@ManyToOne`, `@OneToOne`
  - (optional = false): 내부 조인
  - (optional = true): 외부 조인
- `@OneToMany`, `@ManyToMany`
  - (optional = false): 외부 조인
  - (optional = true): 내부 조인

<br/>
<br/>




## 8.4 영속성 전이: CASCADE
특정 엔티티를 연속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면영속성 전이 기능을 사용한다. **JPA에서 엔티티를 저장할 때 연관된 모든 엔티티는 영속 상태여야 한다.**

### 8.4.1 영속성 전이: 저장

```java
@Entity
public class Parent {
    ...생략...
    @OneToMany(mappedBy = "parent", cascade = CascadeType.PERSIST)
    private List<Child> children = new ArrayList<Child>();
    ...생략...
}
```
```java
Parent parent = new Parent();
Child child = new Child();

child.setParent(parent);
parent.getChildren().add(child);

// Parent만 저장했지만, 영속성 전이에 의해 Child도 저장됨
em.persist(parent);
```
영속성 전이는 연관관계를 매핑하는 것과는 아무 관련이 없다. 단지 **엔티티를 영속화할 때 연관된 엔티티도 같이 영속화하는 편리함을 제공할 뿐이다.**

<br/>



### 8.4.2 영속성 전이: 삭제
```java
@Entity
public class Parent {
    ...생략...
    @OneToMany(mappedBy = "parent", cascade = CascadeType.REMOVE)
    private List<Child> children = new ArrayList<Child>();
    ...생략...
}
```
```java
Parent parent = em.find(Parent.class, 1L);

// Parent만 삭제했지만, 영속성 전이에 의해 Child도 삭제됨
em.remove(parent);
```
<br/>



### 8.4.3 CASCADE의 종류
```java
public enum CascadeType {
    ALL,        // 모두 적용
    PERSIST,    // 영속
    MERGE,      // 병합
    REMOVE,     // 삭제
    REFRESH,
    DETACH
}
```
<br/>
<br/>



## 8.5 고아 객체
JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체(ORPHAN) 제거라 한다. **부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제된다.**

```java
@Entity
public class Parent {
    ...생략...
    @OneToMany(mapeedBy = "parent", orphanRemoval = true)
    private List<Child> children = new ArrayList<Child>();
    ...생략...
}
```
```java
Parent parent = em.find(Parent.class, id);
parent.getChildren().remove(0); // 자식 엔티티를 컬렉션에서 삭제

// SQL
DELETE FROM CHILD WHERE ID=?
```
고아 객체 제거는 **참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능**이다. 또, 부모를 제거하면 자식도 같이 제거된다.

<br/>



## 8.6 영속성 전이 + 고아 객체, 생명 주기
`CascadeType.All + orphanRemoval = true`를 동시에 사용하면 어떻게 될까? 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리 할 수 있다.
- 자식을 저장하려면 부모에 등록하면 된다 (CASCADE)
- 자식을 삭제하려면 부모에서 제거하면 된다 (orphanRemoval)

<br/>

## 8.7 정리
- 프록시 기술
- 즉시 로딩, 지연 로딩
- 영속성 전이
- 고아 객체

<br/>
<br/>
<br/>





# 9. 값 타입
JPA의 데이터 타입
- 엔티티 타입
  - `@Entity`
- 값 타입
  - 기본값 타입
    - 자바 기본 타입(예: int, double)
    - 래퍼 클래스(예: Integer)
    - String
  - 임베디드 타입
    - embedded type
  - 컬렉션 값 타입
    - collection value type

<br/>



## 9.1 기본값 타입
```java
private String name;
private int age;
...
```

## 9.2 임베디드 타입(복합 값 타입)
```java
@Entity
public class Member {
    @Embedded Address homeAddress;
}
```
```java
@Embeddable
public class Address {
    @Column(name="city")
    private String city;
    private String street;
    private String zipcode;
    ...
}
```
- `@Embeddable`: 값 타입을 정의하는 곳에 표시
- `@Embedded`: 값 타입을 사용하는 곳에 표시

<br/>

### 9.2.1 임베디드 타입과 테이블 매핑
<center><img src="/assets/images/posts/books/2/9_2_값타입테이블매핑.png" width="100%" height="100%"></center>


<center><img src="/assets/images/posts/books/2/9_2_값타입테이블매핑2.png" width="100%" height="100%"></center>
UML에서 임베디드 값 타입은 단순하게 표현하는 것이 편리하다.

<br/>
<br/>



### 9.2.2 임베디드 타입과 연관관계
<center><img src="/assets/images/posts/books/2/9_2_임베디드타입과연관관계.png" width="100%" height="100%"></center>

```java
@Entity
public class Member {
    @Embedded Address address;
    @Embedded PhoneNumber phoneNumber;
}

@Embeddable
public class Address {
    String city;
    String street;
    String state;
    @Embedded Zipcode zipcode;
}

@Embeddable
public class Zipcode {
    String zip;
    String plusFour;
}

@Embeddable
public class PhoneNumber {
    String areaCode;
    String localNumber;
    @ManyToOne PhoneServiceProvider provider;
}

@Entity
public class PhoneServiceProvider {
    @Id String name;
}
```
<br/>



### 9.2.3 @AttributeOverride: 속성 재정의
임베디드 타입에 정의한 매핑정보를 재정의 하려면 엔티티에 `@AttributeOverride`를 사용한다.
```java
@Entity
public class Member {
    @Embedded
    private Address address;

    @Embedded
    @AttributeOverrides({
        @AttributeOverride(ame="city", column=@Column(name="COMPANY_CITY")),
        @AttributeOverride(name="street", column=@Column(name="COMPANY_STREET")),
        @AttributeOverride(name="zipcode", column=@Column(name="COMPANY_ZIPCODE"))
    })
    private Address companyAddress;
}
```
<br/>



### 9.2.4 임베디드 타입과 null
임베디드 타입이 null이면 매핑한 컬럼 값은 모두 null이 된다.
```java
member.setAddress(null);
em.persist(member);
// 회원 테이블의 주소와 관련된 CITY,STREET,ZIPCODE 컬럼 값은 모두 null이 된다.
```
<br/>



## 9.3 값 타입과 불변 객체
값 타입은 복잡한 객체를 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.

### 9.3.1 값 타입 공유 참조
임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위함하다.
```java
member1.setAddress(new Address("OldCity"));
Address address = member1.getAddress();

address.setCity("NewCity");
member2.setAddress(address);

// 회원2의 주소만 NewCity로 변경되기를 기대하지만 회원1의 주소도 NewCity로 변경되어 버린다.
```
<br/>


### 9.3.2 값 타입 복사
값 타입의 실제 인스턴스인 값을 공유하는 것은 위험하다. 대신에 값(인스턴스)을 복사해서 사용해야 한다.
```java
member1.setAddress(new Address("OldCity"));
Address address = member1.getAddress();

// 복사
Address newAddress = address.clone();
newAddress.setCity("NewCity");
member2.setAddress(newAddress);
```
<br/>



### 9.3.3 불변 객체
값 타입은 부작용 걱정 없이 사용할 수 있어야 한다. **객체를 불변하게 만들면 값을 수정할 수 없으므로 부작용을 원천 차단할 수 있다.**
```java
// 주소 불변 객체
@Embeddable
public class Address {
    private String city;
    
    protected Address () {}

    public Address(String city) {
        this.city = city;
    }
    

    public String getCity() {
        return city;
    }

    // Setter는 만들지 않는다.
}
```
<br/>



## 9.4 값 타입의 비교
- 동일성 비교: 인스턴스의 참조 값을 비교, `==` 사용
- 동등성 비교: 인스턴스의 값을 비교, `equals()` 사용
- 값 타입을 비교할 때는 `equals()`를 사용해서 동등성 비교를 해야 한다.
- 값 타입의 `equals()`, `hashCode()` 메소드를 재정의해야 한다.
<br/>


## 9.5 값 타입 컬렉션
값 타입을 하나 이상 저장하려면 컬렉션에 보관하고 `@ElementCollection`, `@CollectionTable` 어노테이션을 사용하면 된다.

```java
@Entity
public class Member {

    @Id @GeneratedValue
    private Long id;

    @ElementCollection
    @CollectionTable(
        name = "FAVORITE_FOODS",
        joinColumns = @JoinColumn(name = "MEMBER_ID")
    )
    @Column(name = "FOOD_NAME")
    private Set<String> favoriteFoods = new HashSet<String>();

    @ElementCollection
    @CollectionTable(
        name = "ADDRESS",
        joinColumns = @JoinColumn(name = "MEMBER_ID")
    )
    private List<Address> addressHistory = new ArrayList<Address>();
}
```
```java
@Embeddable
public class Address {

    @Column
    private String city;
    private String street;
    private String zipcode;
}
```
<center><img src="/assets/images/posts/books/2/9_5_값타입컬렉션.png" width="100%" height="100%"></center>
<br/>



### 9.5.1 값 타입 컬렉션 사용
값 타입 컬렉션은 영속성 전이(Cascade) + 고아 객체 제거(Orphan remove) 기능이 포함되어 있다.
```java
// 값 타입 컬렉션도 조회할 때 페치 전략을 선택할 수 있다.
@ElementCollection(fetch = FetchType.LAZY) // 기본값 LAZY
```
<br/>



### 9.5.2 값 타입 컬렉션의 제약사항

**제약사항**  
- 값 타입 컬렉션에 보관된 값 타입들은 별도의 테이블에 보관한다.
- 따라서 여기에 보관된 값 타입의 값이 변경되면 데이터베이스에서 데이터를 찾기 어렵다.
- 이런 문제로 JPA 구현체들은 값 타입 변경 사항이 발생하면 값 타입 컬렉션이 매핑된 테이블의 연관된 모든 데이터를 삭제, 현재 값으로 저장한다.
- 성능 문제 발생
- 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성 해야한다.
- 따라서 데이터베이스 기본 키 제약 조건으로 인해 컬럼에 null을 입력할 수 없고, 값은 값을 중복해서 저장할 수 없는 제약도 있다.

**해결방법**  
- 따라서 실무에서는 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 **값 타입 컬렉션 대신에 일대다 관계를 고려**해야 한다.
- 그리고 영속성 전이 + 고아 객체 제거 기능을 적용하면 값 타입 컬렉션 처럼 사용할 수 있다.

```java
// 값 타입 컬렉션 대신에 일대다 관계 사용
@Entity
public class AddressEntity {

    @Id @GeneratedValue
    private Long id;

    @Embedded
    private Address address;
}

@Embeddable
public class Address {

    @Column
    private String city;
    private String street;
    private String zipcode;
}
```
```java
// 설정 코드
@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
@JoinColumn(name = "MEMBER_ID")
private List<AddressEntity> addressHistory = new ArrayList<AddressEntity>();
```
<br/>
<br/>



## 9.6 정리
**엔티티 타입의 특징**  
- 식별자(`@Id`)가 있다.
- 생명 주기가 있다.
  - 생성, 영속, 소멸
- 공유할 수 있다.
  - 참조 값을 공유할 수 있다.
  - 예를 들어 회원 엔티티가 있다면 다른 엔티티에서 회원 엔티티를 참조할 수 있다.

**값 타입의 특징**
- 식별자가 없다
- 생명 주기를 엔티티에 의존한다.
  - 의존하는 엔티티를 제거하면 같이 제거된다.
- 공유하지 않는 것이 안전하다.
  - 대신에 값을 복사해서 사용한다.
  - 오직 하나의 주인만이 관리해야 한다.
  - 불변 객체로 만드는 것이 안전하다.


<br/>
<br/>
<br/>





# 10. 객체지향 쿼리 언어

## 10.1 객체지향 쿼리 소개
**JPQL 이란?**  
- 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리다
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
- SQL이 데이터베이스 테이블을 대상으로 하는 데이터 중심의 쿼리라면 JPQL은 엔티티 객체를 대상으로 하는 **객체지향 쿼리다.**

<br/>

JPA는 JPQL뿐만 아니라 다양한 검색 방법을 제공한다.  

**공식 지원 기능**  
- JPQL(Java Persistence Query Language)
- Criteria 쿼리: JPA을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
- 네이티브 SQL: JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다.

**비 공식 기능**  
- **QueryDSL**: Criteria 쿼리처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음, 비표준 오픈소스 프레임워크다.
- JDBC 직접 사용
- MyBatis 같은 SQL 매퍼 프레임워크 사용

<br/>
<br/>




### 10.1.1 JPQL 소개
- JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.
  - 방언만 변경하면 된다.
- JPQL은 SQL보다 간결하다.
  - 엔티티 직접 조회
  - 묵시적 조인
  - 다형성 지원

```java
@Entity(name="Member")
public class Member {
    ...생략...
    @Column(name = "name")
    private String name;
    ...생략...
}
```
```java
// JPQL 사용
String jpql = "select m from Member as m where m.username = 'kim'";
List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
```
```sql
-- 실제 실행된 SQL, 별칭은 너무 복잡해 임의 수정
select
    member.id as id,
    member.age as age,
    member.team_id as team,
    member.name as name
from
    Member member
where
    member.name='kim'
```
<br/>



### 10.1.2 Criteria 소개
Criteria는 JPQL을 생성하는 빌더 클래스다. **Criteria의 장점은 문자가 아닌 `query.select(m).where(...)`처럼 프로그래밍 코드로 JPQL을 작성할 수 있다는 점이다.**


**장점**  
- 컴파일 시점에 오류를 발견할 수 있다.
- IDE를 사용하면 코드 자동완성을 지원한다.
- 동적 쿼리를 작성하기 편하다.

```java
// Criteria 사용 준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

// 루트 클래스(조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

// 쿼리 생성
CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("username"), "kim"));
List<Member> resultList = em.createQuery(cq).getResultList();
```
**Criteria가 가진 장점이 많지만 모든 장점을 상쇄할 정도로 복잡하고 장황하다.**

<br/>





### 10.1.3 QueryDSL 소개
- QueryDSL도 Criteria처럼 JPQL 빌더 역할을 한다.
- 코드 기반이다
- 단순하고 사용하기 쉽다
- 작성한 코드도 JPQL과 비슷해서 한눈에 들어온다

```java
// 준비
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

// 쿼리, 결과조회
List<Member> members = query.from(member)
                    .where(member.username.eq("kim"))
                    .list(member);
```
<br/>






### 10.1.4 네이티브 SQL 소개
JPA는 SQL을 직접 사용할 수 있는 기능을 지원하는데 이것을 네이티브 SQL이라 한다.

```java
String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
List<Member> resultList = em.createNativeQuery(sql, Member.class).getResultList();
```
네이티브 SQL의 단점은 특정 데이터베이스에 의존하는 SQL을 작성해야 한다는 것이다. 따라서 데이터베이스를 변경하면 네이티브 SQL도 수정해야 한다.

<br/>





### 10.1.5 JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크 사용
다음은 하이버네이트에서 직접 JDBC Connection을 획득하는 방법이다.
```java
Session session = entityManager.unwrap(Session.class);
session.doWork(new Work() {

    @Override
    public void execute(Connection connection) throw SQLException {...}
});
```
- **JDBC나 마이바티스를 JPA와 함께 사용하면 영속성 컨텍스트를 적절한 시점에 강제로 플러시해야 한다.**
- **데이터베이스와 영속성 컨텍스트를 동기화 하기 위함이다.**

<br/>
<br/>




## 10.2 JPQL
**JPQL 특징**
- JPQL은 객체지향 쿼리 언어다. 따라서 테이블이 아닌 엔티티 객체를 대상으로 쿼리한다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.
- JPQL은 결국 SQL로 변환된다.


### 10.2.1 기본 문법과 쿼리 API
```
JPQL 문법

select_문 :: =
    select_절
    from_절
    [where_절]
    [groupby_절]
    [having_절]
    [orderby_절]

update_문 :: update_절 [where_절]
delete_문 :: delete_절 [where_절]
```
<br/>


**SELECT 문**  
```sql
SELECT m FROM Member AS m where m.username = 'Hello'
```

- 대소문자 구분
  - 엔티티와 속성은 대소문자를 구분한다.
  - JPQL 키워드(SELECT, FROM, AS..)는 대소문자를 구분하지 않는다.

- 엔티티 이름
  - 테이블 명이 아니라 엔티티 명을 사용한다.
  - @Entity(name="xxx")로 지정할 수 있다.
  - 엔티티 명을 지정하지 않으면 클래스명을 기본값으로 사용한다.

- 별칭은 필수
  - JPQL은 별칭을 필수로 사용해야 한다. (JPA 명세로 치면 정확히는 식별 변수)
  - AS는 생략할 수 있다.

<br/>


**TypeQuery, Query**  
작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 한다.
- TypeQuery 객체: 반환 타입을 명확하게 지정할 수 있으면 사용
- Query 객체: 반환 타입을 명확하게 지정할 수 없으면 사요

```java
// TypeQuery 사용

TypeQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);

List<Member> resultList = query.getResultList();
for (Member member : resultList) {
    ...
}
```
```java
// Query 사용

Query query = em.createQuery("SELECT m FROM Member m");

List resultList = query.getResultList();
for (Object o : resultList) {
    Object[] result = (Object[]) o; // 결과가 둘 이상이면 Object[] 반환
    System.out.println("username = " + result[0]);
    System.out.println("age = " + result[1]);
}
```
<br/>


**결과 조회**  
다음 메소드들을 호출하면 실제 쿼리를 실행해서 데이터베이스를 조회한다.
- query.getResultList(): 결과를 반환. 만약 결과가 없으면 빈 컬렉션 반환
- query.getSingleResult(): 결과가 정확히 하나일 때 사용한다.
  - 결과가 없으면 javax.persistence.NoResultException 발생
  - 결과가 1개보다 많으면 javax.persistence.NonUniqueResultException 발생

<br/>
<br/>




### 10.2.2 파라미터 바인딩
JDBC는 위치 기준 파라미터 바인딩만 지원하지만 JPQL은 이름 기준 파라미터 바인딩도 지원한다.

**이름 기준 파라미터**  
```java
String usernameParam = "user1";

// 파라미터 앞에 :을 붙인다.
TypeQuery<Member> query = em.createQuery("SELECT m FROM Member m where m.username = :username", Member.class);
query.setParameter("username", usernameParam);

List<Member> resultList = query.getResultList();
```
<br/>


**위치 기준 파라미터**  
```java
String usernameParam = "user1";

// 파라미터는 ? 다음에 위치 값을 주면 된다.
List<Member> members = em.createQuery("SELECT m FROM Member m where m.username = ?1", Member.class);

query.setParameter(1, usernameParam);
List<Member> resultList = query.getResultList();
```
<br/>


**참고**  
파라미터 바인딩 방식을 사용하지 않고 직접 JPQL을 만들면 SQL 인젝션 공격을 당할 수 있다.
```java
"SELECT m FROM Member m where m.username = '" + usernameParam + "'"
```
<br/>



### 10.2.3 프로젝션
**SELECT 절에 조회할 대상을 지정하는 것을 프로젝션이라고 한다**. [SELECT {프로젝션 대상} FROM]으로 대상을 선택한다. **프로젝션 대상은 엔티티, 임베디드 타입, 스칼라 타입이 있다.** 스칼라 타입은 숫자, 문자 등 기본 데이터 타입을 뜻한다.


**엔티티 프로젝션**  
```java
SELECT m FROM Member m      // 회원
SELECT m.team FROM Member m // 팀
```
조회한 엔티티는 영속성 컨텍스트에서 관리한다.

<br/>



**임베디드 타입 프로젝션**  
임베디드 타입은 조회의 시작점이 될 수 없다는 제약이 있다. 아래에 Address는 임베디드 타입이다.
```java
// 잘못된 쿼리
String query = "SELECT a From Address a";
```
```java
// 올바른 쿼리
String query = "SELECT o.address From Order o";
List<Address> addresses = em.createQuery(query, Address.class).getResultList();
```
실행된 쿼리는 다음과 같다.
```sql
select
    order.city,
    order.street,
    order.zipcode
from
    Orders order
```
임베디드 타입은 엔티티 타입이 아니다. 따라서 이렇게 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다.

<br/>




**스칼라 타입 프로젝션**  
숫자, 문자, 날짜와 같은 기본 데이터 타입들은 스칼라 타입이라 한다.
```java
String query = "SELECT username FROM Member m";
List<String> usernames = em.createQuery(query, String.class).getResultList();


// 중복 데이터를 제거하려면 DISTINCT를 사용한다.
SELECT DISTINCT username From Member m

// 통계
String query = "SELECT AVG(o.orderAmount) FROM Order o"
Double orderAmountAvg = em.createQuery(query, Double.class).getSingleResult();
```
<br/>



**여러 값 조회**  
꼭 필요한 데이터들만 선택해서 조회해야 할 때도 있다. 이 때는 TypeQuery를 사용할 수 없고 대신에 Query를 사용해야 한다.
```java
Query query = em.createQuery("SELECT m.username, m.age FROM Member m");
List resultList = query.getResultList();

Iterator iterator = resultList.iterator();
while (iterator.hasNext()) {
    Object[] row = (Object[]) iterator.next();
    String username = (String) row[0];
    Integer age = (Integer) row[1];
}
```
```java
Query query = em.createQuery("SELECT m.username, m.age FROM Member m");
List<Object[]> resultList = query.getResultList();

for (Object[] row : resultList) {
    String username = (String) row[0];
    Integer age = (Integer) row[1];
}
```
스칼라 타입뿐만 아니라 엔티티 타입도 여러 값을 함께 조회할 수 있다.
```java
Query query = em.createQuery("SELECT o.member, o.product, o.orderAmount FROM Order o");
List<Object[]> resultList = query.getResultList();

for (Object[] row : resultList) {
    Member member = (Member) row[0];    // 엔티티
    Product product = (Product) row[1]; // 엔티티
    int orderAmount = (Integer) row[2]; // 스칼라
}
```
물론 이때도 조회한 엔티티는 영속성 컨텍스트에서 관리된다.

<br/>



**NEW 명령어**  
프로젝션을 UserDTO처럼 의미 있는 객체로 변환해서 사용할 수 있다.

```java
public class UserDTO {
    private String username;
    private int age;

    public UserDTO(String username, int age) {
        this.username = username;
        this.age = age;
    }
    ...
}
```
```java
TypeQuery<UserDTO> query = em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m", UserDTO.class);

List<UserDTO> resultList = query.getResultList();
```
NEW 명령어 사용시 주의 사항은 다음과 같다.
- 패키지 명을 포함한 전체 클래스 명을 입력해야 한다.
- 순서와 타입이 일치하는 생성자가 필요한다.

<br/>



### 10.2.4 페이징 API
JPA 페이징
```java
TypeQuery<Member> query = em.createQuery("SELECT m FROM Member m ORDER BY m.username DESC", Member.class);

query.setFirstResult(10); // 조회 시작 위치(0부터 시작)
query.setMaxResult(20);   // 조회할 데이터 수
query.getResultList();
```
<br/>


**HSQLDB 페이징**  
```sql
SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
FROM
    MEMBER M
ORDER BY
    M.NAME DESC OFFSET ? LIMIT ?
```
<br/>

**MySQL 페이징**
```sql
SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
FROM
    MEMBER M
ORDER BY
    M.NAME DESC LIMIT ?, ?
```
<br/>

**PostgreSQL 페이징**
```sql
SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
FROM
    MEMBER M
ORDER BY
    M.NAME DESC LIMIT ? OFFSET ?
```
<br/>

**오라클 페이징**
```sql
SELECT *
FROM
    (
        SELECT ROW_.*, ROWNUM ROWNUM_
            FROM
                (
                    SELECT
                        M.ID AS ID,
                        M.AGE AS AGE,
                        M.TEAM_ID AS TEAM_ID,
                        M.NAME AS NAME
                    FROM
                        MEMBER M
                    ORDER BY M.NAME
                ) ROW_
            WHERE ROWNUM <= ?
    )
WHERE ROWNUM_ > ?
```
<br/>

**SQLServer 페이징**
```sql
WITH query AS (
    SELECT
    inner_query.*,
    ROW_NUMBER() OVER (ORDER BY CURRENT_TIMESTAMP) as
        __hibernate_row_nr__
    FROM
        (
            select
                TOP(?) m.id as id,
                m.age as age,
                m.team_id as team_id,
                m.name as name
            from Member m
            order by m.name DESC
        ) inner_query
)
SELECT id, age, team_id, name
FROM query
WHERE __hibernate_row_nr__ >= ? AND __hibernate_row_nr__ < ?
```
<br/>
<br/>




### 10.2.5 집합과 정렬
집합은 집합함수와 함께 통계 정보를 구할 때 사용한다.

**집합 함수**  


| **함수**   | **설명**                                                                                                 |
| -------- | ------------------------------------------------------------------------------------------------------ |
| COUNT    | 결과 수를 구한다. 반환 타입: Long                                                                                 |
| MAX, MIN | 최대, 최소 값을 구한다. 문자, 숫자, 날짜 등에 사용한다.                                                                     |
| AVG      | 평균값을 구한다. 숫자타입만 사용할 수 있다. 반환 타입: Double                                                                |
| SUM      | 합을 구한다. 숫자타입만 사용할 수 있다. 반환 타입: 정수합 Long, 소수합: Double, BigInteger합: BigInteger, BigDecimal합: BigDecimal |

<br/>


**집합 함수 사용 시 참고사항**
- NULL 값은 무시하므로 통계에 잡히지 않는다. (DISTINCT가 정의되어 있어도 무시된다.)
- 만약 값이 없는데 SUM, AVG, MAX, MIN 합수를 사용하면 NULL 값이 된다. 단 COUNT는 0이 된다.
- DISTINCT를 집합 함수 안에 사용해서 중복된 값을 제거하고 나서 집합을 구할 수 있다. 예: `select COUNT( DISTINCT m.age ) from Member m`
- DISTINCT를 COUNT에서 사용할 때 임베디드 타입은 지원하지 않는다.

<br/>


**GROUP BY, HAVING**  
GROUP BY는 통계 데이터를 구할 때 특정 그룹끼리 묶어준다. HAVING은 GROUP BY와 함께 사용되는데 GROUP BY로 그룹화한 통계 데이터를 기준으로 필터링 한다.
```sql
select
    t.name,
    COUNT(m.age),
    SUM(m.age),
    AVG(m.age),
    MAX(m.age),
    MIN(m.age)
from Member m LEFT JOIN m.team t
GROUP BY t.name
HAVING AVG(m.age) >= 10
```
<br/>

문법은 다음과 같다.
```
groupby_절 ::= GORUP BY {단일값 경로 | 별칭} +
having_절 ::= HAVING 조건식
```
<br/>


**정렬(ORDER BY)**  
결과를 정렬할 때 사용한다.
```sql
select m from Member m order by m.age DESC, m.username ASC
```
<br/>

문법은 다음과 같다.
```
orderby_절 ::= ORDER BY {상태필드 경로 | 결과 변수 [ASC | DESC]}+
```
- ASC: 오름차순(기본값)
- DESC: 내림차순

<br/>



### 10.2.6 JPQL 조인
JPQL도 조인을 지원하는데 SQL 조인과 기능은 같고 문법만 약간 다르다.

**내부 조인**  
내부조인은 INNER JOIN을 사용한다. 참고로 INNER는 생략할 수 있다.
```java
String teamName = "팀A";
String query = "SELECT m FROM Member m INNER JOIN m.team t WHERE t.name = :teamName";

List<Member> members = em.createQuery(query, Member.class)
                    .setParameter("teamName", teamName)
                    .getResultList();
```

**주의사항**  
**JPQL 조인은 연관 필드를 사용**한다는 것이다. SQL 조인처럼 사용하면 문법 오류가 발생한다. 다음은 잘못된 예이다.
```sql
-- 잘못된 JPQL 조인
FROM Member m JOIN Team t 
```
<br/>



**외부 조인**  
JPQL의 외부 조인은 다음과 같이 사용한다.
```sql
SELECT m
FROM Member m LEFT [OUTER] JOIN m.team t
```
<br/>



**컬렉션 조인**  
일대다 관계나 다대다 관계처럼 컬렉션을 사용하는 곳에서 조인하는 것을 컬렉션 조인이라 한다.
- [회원 -> 팀]으로의 조인은 다대일 조인, 단일 값 연관필드(m.team) 사용
- [팀 -> 회원]으로의 조인은 일대다 조인, 컬렉션 값 연관필드(m.members) 사용

```sql
-- 팀과 회원목록을 컬렉션 값 연관 필드로 외부조인 했다.
SELECT t, m FROM Team t LEFT JOIN t.members m
```
<br/>


**세타 조인**  
WHERE 절을 사용해서 세타 조인을 할 수 있다. **세타 조인은 내부 조인만 지원한다.** 세타 조인을 사용하면 전혀 관계없는 엔티티도 조인할 수 있다.

```sql
-- JPQL
select count(m) from Member m, Team t
where m.username = t.team

-- sql
select count(m.id)
from
    member m cross join team t
where
    m.username = t.name
```
<br/>



**JOIN ON 절(JPA 2.1)**  
JPA 2.1부터 조인할 때 ON 절을 지원한다. 참고로 내부 조인이 ON 절은 WHERE 절을 사용할 때와 결과가 같으므로 보통 **ON 절은 외부 조인에서만 사용한다.**
```sql
-- JPQL
select m, t
from Member m
    left join m.team t on t.name = 'A'

-- SQL
select m.*, t.*
from Member m
    left join Team t on m.team_id = t.id 
    and t.name = 'A'
```
<br/>


### 10.2.7 페치 조인
- 페치(fetch) 조인은 JPQL에서 성능 최적화를 위해 제공하는 기능이다.
- 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능이다.
- join fetch 명령어로 사용할 수 있다.

문법
```
페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로
```
<br/>


**엔티티 페치 조인**  
페치 조인을 사용해서 회원 엔티티를 조회하면서 연관된 팀 엔티티도 함께 조회 하는 JPQL
```sql
-- 페치 조인 JPQL
select m
from Member m join fetch m.team


-- 실행된 SQL
SELECT
    M.*, T.*
FROM MEMBER T
INNER JOIN TEAM T ON M.TEAM_ID = T.ID

```
JPQL조인과는 다르게 m.team 다음에 별칭이 없는데 페치 조인은 별칭을 사용할 수 없다. (하지만 하이버네이트는 페치 조인에도 별칭을 허용한다.)
<br/>


**컬렉션 페치 조인**  
일대다 관계인 컬렉션을 페치 조인
```sql
-- 컬렉션 페치 조인 JPQL
select t
from Team t join fetch t.members
where t.name = '팀A'


-- 실행된 SQL
SELECT
    T.*, M.*
FROM TEAM T
INNER JOIN MEMBER M ON T.ID = M.TEAM_ID
WHERE T.NAME = '팀A'
```
문제는 TEAM 테이블에서 팀A는 하나지만 MEMBER테이블과 조인하면서 결과가 증가한다. 테이블의 데이터가 팀A, 회원1, 회원2 있다고 하면 결과는 아래와 같다.
```
teamname = 팀A, team = Team@0x100
    username = 회원1, member = Member@0x200
    username = 회원2, member = Member@0x300
teamname = 팀A, team = Team@0x100
    username = 회원1, member = Member@0x200
    username = 회원2, member = Member@0x300
```

<br/>



**페치 조인과 DISTINCT**  
위의 컬렉션 페치 조인은 팀A가 중복으로 조회된다. 이를 해결하기 위해 DISTINCT를 사용한다.
```sql
select distinct t
from Team t join fetch t.members
where t.name = '팀A'
```
위 상황의 데이터는 SQL에서 DISTINCT를 해도 효과가 없다.

| **로우 번호** | **팀** | **회원** |
|------|------|------|
| 1 | 팀A | 회원1 |
| 2 | 팀A | 회원2 |


 하지만 **JPQL의 select distinct t의 의미는 엔티티의 중복을 제거하라는 것이다. 따라서 팀A는 하나만 조회된다.**
```
teamname = 팀A, team = Team@0x100
    username = 회원1, member = Member@0x200
    username = 회원2, member = Member@0x300
```
<br/>



**페치 조인과 일반 조인의 차이**  
- 일반 조인: JPQL의 결과를 반환할 때 연관관계까지 고려하지 않는다. 단지 SELECT 절에 지정한 엔티티만 조회할 뿐이다.
- 페치 조인: SELECT 절에 지정한 엔티티뿐만 아니라 지정하지 않았어도 연관된 엔티티도 함께 조회한다.

<br/>


**페치 조인의 특징과 한계**  
- SQL 한번으로 연관된 엔티티들을 조회하여 SQL 호출 횟수를 줄여 성능을 최적화할 수 있다.
- JPQL에서 페치 조인을 사용하면 글로벌 전략보다 우선 적용된다.
  - 글로벌 전략 예: @OneToMany(fetch = FetchType.LAZY)
- 페치 조인을 하면 쿼리 시점에 조회하므로 준영속 상태에서도 객체 그래프를 탐색할 수 있다.
- 페치 조인 대상에는 별칭을 줄 수 없다.
  - 따라서 SELECT, WHERE, 서비 쿼리에 페치 조인 대상을 사용할 수 없다.
  - 하이버네이트에서는 페치 조인에 별칭을 지원한다. 하지만 잘못 사용하면 연관된 데이터 수가 달라져 무결성이 깨질 수 있다.
- 둘 이상의 컬렉션을 페치할 수 없다.
- 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.
  - 컬렉션(일대다)이 아닌 단일 값 연관 필드(일대일, 다대일)은 페치 조인 가능
  - 하이버네이트는 컬렉션을 페치 조인하고 페이징 API를 사용하면 경고 로그를 남기고 메모리에서 페이징 처리한다. 하지만 성능 이슈가 발생할 수 있다.

**추천은 글로벌 전략은 지연 로딩을 사용하고 최적화가 필요하면 그 때 페치 조인을 적용한다.**
<br/>
<br/>



### 10.2.8 경로 표현식
경로 표현식이란 m.username, m.team 처럼 .(점)을 찍어 객체 그래프를 탐색하는 것이다.


**경로 표현식의 용어 정리**  
- 상태 필드: 단순히 값을 저장하기 위한 필드
- 연관 필드: 연관관계를 위한 필드, 임베디드 타입 포함
  - 단일 값 연관필드: @ManyToOne, @OneToOne, 대상이 엔티티
  - 컬렉션 값 연관 필드: @OneToMany, @ManyToMany, 대상이 컬렉션

```java
@Entity
public class Member {
    ...생략...
    @Column(name = "name")
    private String username;    // 상태 필드

    @ManyToOne(...)
    private Team team;          // 연관 필드 (단일 값)

    @OneToMany(...)
    private List<Order> orders; // 연관 필드 (컬렉션 값)
    ...생략...
}
```
<br/>


**경로 표현식 특징**  











<br/>
<br/>
<br/>
<br/>

**...작성중...** 📝




