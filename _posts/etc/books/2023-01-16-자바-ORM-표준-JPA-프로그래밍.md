---
layout: single
title: "📖 자바 ORM 표준 JPA 프로그래밍"
categories: [etc, books]
tag: [books, JPA, ORM]
author_profile: true
toc: true
toc_sticky: true
---

[자바 ORM 표준 JPA 프로그래밍](https://product.kyobobook.co.kr/detail/S000000935744){:target="_blank"} 책을 읽고 내용을 아주 간단하게 정리한 글입니다. 책에는 자세한 설명과 예제가 많으니 **꼭 구입해서 읽는것을 추천**합니다~👍

---

# 1. JPA 소개
## 1.1 SQL을 직접 다룰 때 발생하는 문제점
- 자바로 개발하는 애플리케이션은 대부분 관계형 데이터베이스를 데이터 저장소로 사용한다.
- JDBC API를 사용해 SQL을 전달한다.

### 1.1.1 반복, 반복 그리고 반복
객체를 데이터 베이스에 CURD 하려먼 너무많은 SQL과 JDBC API를 코드로 작성해야 한다. 테이블이 여러개라면 무수히 많은 SQL을 작성해야 한다.

### 1.1.2 SQL에 의존적인 개발
애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점
- 진정한 의미의 계층 분할이 어렵다.
- 엔티티를 신뢰할 수 없다.
- SQL에 의존적인 개발을 피하기 어렵다.

### 1.1.3 JPA와 문제 해결
JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 SQL을 작성하는 것이 아니라 JPA가 제공하는 API를 사용하면 된다.

```java
// 저장
jpa.persist(member);

// 조회
String memberId = "helloId"
Member member = jpa.find(Member.class, memberId);

// 수정
Member member = jpa.find(Member.class, memberId);
member.setName("이름변경"); // jpa는 update 메소드가 따로 없다.

// 연관된 객체 조회
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam();
```


## 1.2 패러다임 불일치
- 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르다.
- 기능과 표현 방법도 다르다.
- 객체 구조를 테이블 구조에 저장하는 데는 한계가 있다.

### 1.2.1 상속
객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다.(일부 데이터베이스는 상속 기능을 지원하지만 객체의 상속과는 약간 다르다.)

<center><img src="/assets/images/posts/books/2/1_2_객체상속모델.png" alt="객체상속모델" width="90%" height="90%"></center>

<br/>

데이터 베이스 모델링에서는 슈퍼타입 서브타입 관계를 사용하면 유사하게 만들 수 있다.

<center><img src="/assets/images/posts/books/2/1_2_테이블모델.png" alt="테이블모델" width="90%" height="90%"></center>

<br/>

위의 구조를 JDBC API를 사용해서 구현하려면 작성해야 할 코드량이 만만치 않다. 
- INSERT INTO ITEM...
- INSERT INTO ALBUM...

<br/>

**JPA와 상속**  
JPA는 상속과 관련된 패러다임 불일치 문제를 개발자 대신 해결해 준다.

```java
// 저장
jpa.persist(album);

// JPA에서 실행 해주는 SQL
INSERT INTO ITEM...
INSERT INTO ALBUM...
```

<br/>

### 1.2.2 연관관계
- **객체는 참조를 사용해 다른 객체와 연관관계**를 가진다. 참조에 접근해서 연관된 객체를 조회한다.
- **테이블은 외래 키를 사용해 다른 테이블과 연관관계**를 가진다. 조인을 사용해서 연관된 테이블을 조회한다. 
- **객체는 참조가 있는 방향으로만 조회할 수 있다.**
<center><img src="/assets/images/posts/books/2/1_2_연관관계.png" alt="연관관계" width="90%" height="90%"></center>

<br/>

**객체를 테이블에 맞추어 모델링**  
```java
// 관계형 데이터베이스가 사용하는 방식에 맞추면 객체 참조를 통해 조회할 수 없다.
class Member {
    String id;   // MEMBER_ID 컬럼 사용
    Long teamId; // TEAM_ID FK 컬럼 사용
}
```

<br/>

**객체지향 모델링**  
```java
// 패러다임 불일치를 해결하려고 소모하는 코드가 많다.
class Member {
    String id;   // MEMBER_ID 컬럼 사용
    Team team; // 참조로 연관관계를 맺는다.
}

// 데이터베이스에 저장
member.getId();
member.getTeam.getId(); // TEAM_ID FK를 직접 구해야 함
...생략...

// 조회
SQL 실행
Member member = new Member ();
Team team = new Team();
...생략...
member.setTeam(team); // 직접 회원과 팀 관계 설정
```

<br/>

**JPA와 연관관계**  
```java
// JPA는 연관관계와 관련된 패러다임 불일치 문제를 해결해준다.

// 저장
member.setTeam(team);
jpa.persist(member); // TEAM_ID FK를 직접 지정할 필요 없음

// 조회
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam(); // 바로 사용 가능
```

<br/>

### 1.2.3 객체 그래프 탐색
객체에서 회원에 소속된 팀을 조회할 때는 다음처럼 참조를 사용해서 연관된 팀을 찾으면 되는데, 이것을 객체 그래프 탐색이라 한다.

<center><img src="/assets/images/posts/books/2/1_2_객체그래프탐색.png" alt="객체그래프탐색" width="90%" height="90%"></center>

<br/>

```java
// 객체 그래프 탐색
member.getOrder().getOrderItem()...

// 문제 발생
member.getOrder(); // 만약 null이라면?
```

**SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.** 이는 객체 그래프가 언제 끊어질지 모르기 때문에 함부로 탐색할 수 없다.

**JPA와 객체 그래프 탐색**  
JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다(**지연로딩**). 따라서 JPA를 사용하면 연관된 객체를 신뢰하고 조회할 수 있다.


### 1.2.4 비교
- 데이터베이스는 기본 키의 값으로 각 row를 구분
- 객체는 동일성, 동등성 비교.
  - 동일성은 == 비교. 객체 인스턴스의 주소 값을 비교한다.
  - 동등성은 equals() 비교. 객체 내부의 값을 비교한다.

**JDBC API 비교**  
```java
String memberId = "100";
Member member1 = memberDAO.getMember(memberID);
Member member2 = memberDAO.getMember(memberID);

// false
member1 == member2;
```

**JPA 비교**  
```java
String memberId = "100";
Member member1 = jpa.find(memberID);
Member member2 = jpa.find(memberID);

// true
member1 == member2;
```

<br/>

### 1.2.5 정리
**객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다르다.** 이 패러다임 차이를 극복하려고 개발자가 너무 많은 시간과 코드를 소비한다. 결국, 객체 모델링은 힘을 잃고 점점 데이터 중심의 모델로 변해간다.

**JPA는 패러다임 불일치 문제를 해결하고, 정교한 객체 모델링을 유지하게 도와준다.**

<br/>
<br/>

## 1.3 JPA란 무엇인가?
**JPA(java persistence API)는 자바진영 ORM 기술 표준**이다. 애플리케이션과 JDBC 사이에서 동작한다.

<center><img src="/assets/images/posts/books/2/1_3_JPA.png" alt="JPA" width="90%" height="90%"></center>

<br/>

**ORM이란?**  
ORM(Object-Relational Mapping)은 **객체와 관계형 데이터 베이스를 매핑한다는 뜻**이다. 다양한 ORM 프레임워크들이 있는데 자바 진영에서는 **하이버네이트 프레임워크가 가장 많이 사용**된다.

<center><img src="/assets/images/posts/books/2/1_3_JPA조회.png" alt="JPA조회" width="80%" height="80%"></center>

<br/>
<br/>

### 1.3.1 JPA 소개
<center><img src="/assets/images/posts/books/2/1_3_JPA표준인터페이스와구현체.png" alt="JPA표준인터페이스와구현체" width="80%" height="80%"></center>

<br/>

**JPA는 자바 ORM 기술에 대한 API 표준 명세다.** 쉽게 이야기해서 인터페이스를 모아둔 것이다. 따라서 JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 한다. ORM 프레임워크 중 **하이버네이트가 가장 대중적**이다.

<br/>

### 1.3.2 왜 JPA를 사용해야 하는가?
- 생산성
- 유지보수
- 패러다임 불일치 해결
- 성능 (캐시)
- 데이터 접근 추상화와 벤더 독립성
  - 데이터베이스마다 사용법이 다르다 (예: 페이징 쿼리)
  - JPA에게 데이터베이스만 알려주면 자동으로 해결된다
- 표준
  - 자바 진영 ORM 기술 표준
  - 표준을 사용하면 다른 구현 기술로 손쉽게 변경 가능

<center><img src="/assets/images/posts/books/2/1_3_벤더독립성.png" alt="벤더독립성" width="80%" height="80%"></center>

<br/>
<br/>

## 1.4 정리
- SQL을 직접 다룰 때 발생하는 다양한 문제
- 객체지향 언어와 관계형 데이터베이스 사이의 패러다임 불일치 문제
- JPA가 각 문제를 어떻게 해결하는지
- JPA가 무엇인지
- JPA 장점


# 2. JPA 시작
## 2.1 이클립스 설치와 프로젝트 불러오기
## 2.2 H2 데이터베이스 설치
## 2.3 라이브러리와 프로젝트 구조
## 2.4 객체 매핑 시작
```java
@Entity
@Table(name="MEMBER")
public class Member {

    @Id
    @Column(name = "ID")
    private String id;

    @Column(name = "NAME")
    private String username;

    private Integer age;
    ...
}
```

| **어노테이션**    | **설명**                                                                             |
| ------------ | ---------------------------------------------------------------------------------- |
| @Entity      | 이 클래스를 테이블과 매핑한다고 JPA에게 알려준다. @Entity가 사용된 클래스를 엔티티 클래스라 한다.                       |
| @Table       | 엔티티 클래스에 매핑할 테이블 정보를 알려준다. 이 어노테이션을 생략하면 클래스 이름을 테이블 이름으로 매핑한다. (정확히는 엔티티 이름을 사용함) |
| @Id          | 엔티티 클래스의 필드를 테이블 기본키(primary key)에 매핑한다. @Id가 사용된 필드를 식별자 필드라 한다.                  |
| @Column      | 필드를 컬럼에 매핑한다.                                                                      |
| 매핑 정보가 없는 필드 | 필드명을 사용해서 컬럼명으로 매핑한다. 대소문자를 구분하는 데이터베이스를 사용하면 @Column(name="AGE")처럼 명시적으로 매핑해야 한다. |

<br>
<br>

## 2.5 객체 매핑 시작
### 2.5.1 데이터베이스 방언
데이터베이스마다 SQL 문법과 함수가 조금씩 다르다는 문제점이 있다.
- 데이터 타입: 가변 문자 타입으로 MySQL은 VARCHAR, 오라클은 VARCHAR2 사용
- 다른 함수명: 문자열을 자르는 함수로 SQL 표준은 SUBSTRING(), 오라클은 SUBSTR()
- 페이징 처리: MySQL은 LIMIT, 오라클은 ROWNUM

데이터베이스만의 고유한 기능을 JPA에서는 방언(Dialect)이라 한다. 특정 데이터베이스에 종속되는 기능을 많이 사용하면 나중에 데이터베이스를 교체하기가 어렵다. 하이버네이트를 포함한 대부분의 JPA 구현체들은 이런 문제점을 해결하려고 다양한 데이터베이스 방언 클래스를 제공한다.

<center><img src="/assets/images/posts/books/2/2_5_방언.png" alt="방언" width="80%" height="80%"></center>


```xml
<!-- 필수 속성 -->
<property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>
<property name="javax.persistence.jdbc.user" value="sa"/>
<property name="javax.persistence.jdbc.password" value=""/>
<property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>
<property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect" /> <!-- 방언 설정 -->

<!-- 옵션 -->
<property name="hibernate.show_sql" value="true" /> <!-- 하이버네이트가 실행한 SQL을 출력한다 -->
<property name="hibernate.format_sql" value="true" /> <!-- 하이버네이트가 실행한 SQL을 보기 쉽게 정렬한다 -->
<property name="hibernate.use_sql_comments" value="true" /> <!-- 쿼리를 출력할 때 주석도 함께 출력한다 -->
<property name="hibernate.id.new_generator_mappings" value="true" /> <!-- JPA 표준에 맞춘 새로운 키 생성 전략을 사용한다. -->
```

<br/>
<br/>

## 2.6 애플리케이션 개발
```java
public class JpaMain {

    public static void main(String[] args) {

        //엔티티 매니저 팩토리 생성
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
        EntityManager em = emf.createEntityManager(); //엔티티 매니저 생성

        EntityTransaction tx = em.getTransaction(); //트랜잭션 기능 획득

        try {
            tx.begin(); //트랜잭션 시작
            logic(em);  //비즈니스 로직
            tx.commit();//트랜잭션 커밋

        } catch (Exception e) {
            e.printStackTrace();
            tx.rollback(); //트랜잭션 롤백
        } finally {
            em.close(); //엔티티 매니저 종료
        }

        emf.close(); //엔티티 매니저 팩토리 종료
    }

    // 비즈니스 로직
    public static void logic(EntityManager em) {...}
}
```
코드는 크게 3부분으로 나뉘어 있다
- 엔티티 매니저 생성
- 트랜잭션 관리
- 비즈니스 로직


### 2.6.1 엔티티 매니저 설정
**엔티티 매니저 팩토리 생성**  
```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory("jpabook");
```
JPA를 동작시키기 위한 기반 객체를 만들고 데이터베이스 커넥션 풀도 생성하므로 엔티티 매니저 팩토리를 생성하는 비용은 아주 크다. 따라서 **엔티티 매니저 팩토리는 애플리케이션 전체에 딱 한 번만 생성하고 공유해서 사용해야 한다.**

**엔티티 매니저 생성**  
```java
EntityManager em = emf.createEntityManager();
```
JPA의 기능 대부분은 엔티티 매니저가 제공한다. 대표적으로 엔티티를 데이터베이스에 등록,수정,삭제,조회할 수 있다. **엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안된다.**

**종료**  
사용이 끝난 엔티티 매니저, 엔티티 매니저 팩토리는 반드시 종료해야한다.
```java
em.close(); // 엔티티 매니저 종료
emf.close() // 엔티티 매니저 팩토리 종료
```

<br/>

### 2.6.2 트랜잭션 관리
JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 한다. 트랜잭션 없이 데이터를 변경하면 예외가 발생한다.

```java
EntityTransaction tx = em.getTransaction(); //트랜잭션 기능 획득
try {
    tx.begin(); //트랜잭션 시작
    logic(em);  //비즈니스 로직
    tx.commit();//트랜잭션 커밋

} catch (Exception e) {
    e.printStackTrace();
    tx.rollback(); //트랜잭션 롤백
} finally {
    em.close(); //엔티티 매니저 종료
}

emf.close(); //엔티티 매니저 팩토리 종료
```

<br/>

### 2.6.3 비즈니스 로직
```java
public static void logic(EntityManager em) {

        String id = "id1";
        Member member = new Member();
        member.setId(id);
        member.setUsername("지한");
        member.setAge(2);

        //등록
        // INSERT INTO MEMBER ...
        em.persist(member);

        //수정
        // JPA는 엔티티 변경 추적 기능이 있어 엔티티의 값만 변경하면 수정됨
        // UPDATE MEMBER SET AGE=20, NAME='지한' WHERE ID = 'id1';
        member.setAge(20);

        //한 건 조회
        // SELECT * FROM MEMBER WHERE ID = 'id1';
        Member findMember = em.find(Member.class, id);
        System.out.println("findMember=" + findMember.getUsername() + ", age=" + findMember.getAge());

        //목록 조회
        List<Member> members = em.createQuery("select m from Member m", Member.class).getResultList();
        System.out.println("members.size=" + members.size());

        //삭제
        // DELETE FROM MEMBER WHERE ID = 'id1';
        em.remove(member);
    }
```

<br/>

### 2.6.4 JPQL
목록 조회 코드를 살펴보자.
```java
//목록 조회
List<Member> members = em.createQuery("select m from Member m", Member.class).getResultList();
System.out.println("members.size=" + members.size());
```

JPA는 엔티티 객체를 중심으로 개발하므로 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색해야 한다. JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어를 제공한다. 

**JPQL과 SQL의 가장 큰 차이점**  
- JPQL은 엔티티 객체를 대상으로 쿼리한다.
- SQL은 데이터베이스 테이블을 대상으로 쿼리한다.

**JPQL은 데이터베이스 테이블을 전혀 알지 못한다.** JPA는 JPQL을 분석해서 다음과 같은 적절한 SQL을 만들어 데이터베이스에서 데이터를 조회한다.

<br/>
<br/>

## 2.7 정리
- JPA를 사용하기 위한 개발 환경 설정
- JPA를 사용
- JPQL 설명


<br/>
<br/>
<br/>

# 3. 영속성 관리
## 3.1 엔티티 매니저 팩토리와 엔티티 매니저
- 엔티티 매니저 팩토리를 만드는 비용은 상당히 크다.
- 따라서 애플리케이션 전체에서 공유하도록 설계되어 있다. (그래서 일반적으로 하나만 생성 한다)
- **엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전**하다.
- **엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생**한다.
<center><img src="/assets/images/posts/books/2/3_1_일반적인웹애플리케이션.png" alt="일반적인웹애플리케이션" width="80%" height="80%"></center>

<br/>
<br/>

## 3.2 영속성 컨텍스트란?
영속성 컨텍스트(persistence context)란 해석하자면 **엔티티를 영구 저장하는 환경**이란 뜻이다.

```java
em.persist(memeber);
```
이 메소드는 정확히 표현하자면 **엔티티 매니저를 사용해서 회원 엔티티를 영속성 컨텍스트에 저장한다** 이다.

영속성 컨텍스트는 
- 엔티티 매니저를 생성할 때 하나 만들어진다.
- 엔티티 매니저를 통해서 접근할 수 있다.
- 엔티티 매니저를 통해 관리받는다.
- 여러 엔티티 매니저가 접근할 수도 있다.

<br/>
<br/>

## 3.3 엔티티의 생명주기
엔티티에는 4가지 상태가 존재한다.
- 비영속(new / transient): 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(managed): 영속성 컨텍스트에 저장된 상태
- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed): 삭제된 상태
<center><img src="/assets/images/posts/books/2/3_3_생명주기.png" alt="생명주기" width="90%" height="90%"></center>

<br/>
<br/>

## 3.4 영속성 컨텍스트의 특징
영속성 컨텍스트의 특징은 다음과 같다

**영속성 컨텍스트와 식별자 값**  
영속성 컨텍스트는 엔티티를 식별자값(@Id)으로 구분한다. 영속 상태는 식별자 값이 반드시 있어야 한다.

**영속성 컨텍스트와 데이터베이스 저장**  
JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 플러시(flush)라 한다.

**영속성 컨텍스트가 엔티티를 관리할 때 장점**
- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연로딩

<br/>

### 3.4.1 엔티티 조회
영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다. 영속 상태의 엔티티는 모두 이곳에 저장된다.

**1차 캐시에서 조회**  
<center><img src="/assets/images/posts/books/2/3_4_1차캐시에서조회.png" alt="1차캐시에서조회" width="90%" height="90%"></center>

- 1차 캐시의 키는 식별자(@Id) 값.
- 식별자 값은 데이터베이스 기본 키와 매핑.
- 1차 캐시에서 엔티티를 찾고 엔티티가 없으면 데이터베이스에서 조회한다.

```java
// 비영속 상태
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

// 영속 상태 (1차 캐시에 저장됨)
em.persist(member);

// 1차 캐시에서 조회
Member findMember = em.find(Member.class, "member1");
```

<br/>

**데이터베이스에서 조회**  
- 조회시 엔티티가 1차 캐시에 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성.
- 1차 캐시에 저장한 후에 영속 상태의 엔티티를 반환한다.

<center><img src="/assets/images/posts/books/2/3_4_1차캐시에없으면데이터베이스서조회.png" alt="1차캐시에없으면데이터베이스서조회" width="90%" height="90%"></center>

<br/>

**영속 엔티티의 동일성 보장**  
영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장한다.
```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.println(a == b);
```

**동일성과 동등성**  
- 동일성(identity): 실제 인스턴스가 같다. 따라서 참조 값을 비교하는 == 비교의 값이 같다.
- 동등성(equality): 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다.

<br/>

### 3.4.2 엔티티 등록
```java
EntityManager em = emf.createEntityManager(); 
EntityTransaction tx = em.getTransaction();
// 엔티티 매니저는 데이터 변경 시 트랜잭션을 시작해야 한다.
tx.begin(); //트랜잭션 시작

em.persist(memberA);
em.persist(memberB);
// 여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.

// 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.
tx.commit();
```
- 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 저장하지 않고 내부 쿼리 저장소에 INSERT SQL을 모아둔다.
- 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보낸다
- 이를 트랜잭션을 지원하는 쓰기 지연이라 한다.

<center><img src="/assets/images/posts/books/2/3_4_쓰기지연1.png" alt="쓰기지연" width="90%" height="90%"></center>
<br/>
<center><img src="/assets/images/posts/books/2/3_4_쓰기지연2.png" alt="쓰기지연" width="90%" height="90%"></center>
<br/>
<center><img src="/assets/images/posts/books/2/3_4_쓰기지연3.png" alt="쓰기지연" width="90%" height="90%"></center>

**트랜잭션 커밋의 동작**  
1. `tx.commit();` 실행
2. 엔티티 매니저가 영속성 컨텍스트를 플러시
   - 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화 하는 작업
   - 구체적으로 이야기하면 쓰기 지연 SQL을 데이터베이스에 보냄
3. 데이터베이스 트랜잭션 커밋

<br/>

**트랜잭션을 지원하는 쓰기 지연이 가능한 이유**  
- 등록 쿼리를 그때 그때 데이터베이스에 전달해도 트랜잭션을 커밋하지 않으면 아무 소용 없다.
- 결국 데이터베이스에 SQL을 그때 그때 전달하나, 커밋 직전에만 전달하나 결과는 같다.

<br/>


### 3.4.3 엔티티 수정
**SQL 수정 쿼리의 문제점**  
```sql
UPDATE MEMBER
SET
    NAME=?,
    AGE=?,
    GRADE=?
WHERE
    ID=?
```
- 수정 쿼리가 많아진다.
- 비즈니스 로직을 분석하기 위해 SQL을 계속 확인해야한다.
- 결국 직간접적으로 비즈니스 로직이 SQL에 의존한다.

<br/>

**변경감지**  
- **JPA에서 엔티티 수정은 단순히 엔티티를 조회해서 데이터만 변경**하면 된다.
- 이렇게 엔티티의 변경사항을 데이터베이스에 자동으로 반영하는 기능을 **변경 감지**라 한다.
- **변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.**

```java
EntityManager em = emf.createEntityManager(); 
EntityTransaction tx = em.getTransaction();

// 트랜잭션 시작
tx.begin();

// 영속 엔티티 조회
Member memberA = em.find(Member.class, "memberA");

// 영속 엔티티 데이터 수정
memberA.setUserName("hi");
memberA.setAge(10);

// 트랜잭션 커밋
tx.commit();
```

<center><img src="/assets/images/posts/books/2/3_4_변경감지.png" alt="변경감지" width="100%" height="100%"></center>

<br/>

변경 감지로 UPDATE SQL이 실행된다. 
```sql
UPDATE MEMBER
SET
    NAME=?,
    AGE=?,
    GRADE=?
WHERE
    ID=?
```

**JPA의 기본전략은 엔티티의 모든 필드를 업데이트** 한다. 필드가 너무 많거나 저장되는 내용이 너무 크면 수정된 데이터만 사용해서 **동적으로 UPDATE SQL을 생성하는 전략을 선택할 수 있다.**
```java
@Entity
@org.hibernate.annotations.DynamicUpdate
public class Member{...}
```
다만 상황에 따라 다르겠지만 컬럼이 대략 30개 정도가 아니라면 기본 전략의 수정 쿼리가 빠르다.  
추가로 **INSERT SQL을 동적으로 생성하는 @DynamicInsert도 있다.**

<br/>

### 3.4.4 엔티티 삭제
```java
// 영속 엔티티 조회
Member memberA = em.find(Member.class, "memberA");
em.remove(memberA);
```
1. `em.remove();` 호출
2. 호출 순간 영속성 컨텍스트에서 엔티티 제거
3. 쓰기 지연 SQL 저장소에 삭제 쿼리 등록
4. 트랜잭션 커밋시 플러시 (실제 데이터베이스에 삭제 쿼리 전달)
5. 데이터베이스 트랜잭션 커밋

<br/>
<br/>

## 3.5 플러시
**플러시는(flush())는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.** 동작 순서는 다음과 같다.
1. 변경 감지가 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾는다.
2. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.(등록,수정,삭제 쿼리)

<br/>

**영속성 컨텍스트를 플러시하는 방법 3가지**  
1. 직접 호출 (`em.flush()`)
2. 트랜잭션 커밋
3. JPQL 쿼리 실행
    - JPQL은 SQL로 변환되어 데이터베이스에서 엔티티 조회
    - 만약 엔티티가 데이터베이스에 없으면 조회 불가
    - 따라서 플러시를 통해 변경 내용을 데이터베이스에 반영해야 함

참고로 식별자를 기준으로 조회하는 `find()` 메소드를 호출할 때는 플러시가 실행되지 않는다.



<br/>
<br/>
<br/>
<br/>

**...작성중...** 📝




