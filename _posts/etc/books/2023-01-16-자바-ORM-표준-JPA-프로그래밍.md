---
layout: single
title: "📖 자바 ORM 표준 JPA 프로그래밍"
categories: [etc, books]
tag: [books, JPA, ORM]
author_profile: true
toc: true
toc_sticky: true
---

[자바 ORM 표준 JPA 프로그래밍](https://product.kyobobook.co.kr/detail/S000000935744){:target="_blank"} 책을 읽고 내용을 아주 간단하게 정리한 글입니다. 책에는 자세한 설명과 예제가 많으니 **꼭 구입해서 읽는것을 추천**합니다~👍

---

# 1. JPA 소개
## 1.1 SQL을 직접 다룰 때 발생하는 문제점
- 자바로 개발하는 애플리케이션은 대부분 관계형 데이터베이스를 데이터 저장소로 사용한다.
- JDBC API를 사용해 SQL을 전달한다.

### 1.1.1 반복, 반복 그리고 반복
객체를 데이터 베이스에 CURD 하려먼 너무많은 SQL과 JDBC API를 코드로 작성해야 한다. 테이블이 여러개라면 무수히 많은 SQL을 작성해야 한다.

### 1.1.2 SQL에 의존적인 개발
애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점
- 진정한 의미의 계층 분할이 어렵다.
- 엔티티를 신뢰할 수 없다.
- SQL에 의존적인 개발을 피하기 어렵다.

### 1.1.3 JPA와 문제 해결
JPA를 사용하면 객체를 데이터베이스에 저장하고 관리할 때, 개발자가 직접 SQL을 작성하는 것이 아니라 JPA가 제공하는 API를 사용하면 된다.

```java
// 저장
jpa.persist(member);

// 조회
String memberId = "helloId"
Member member = jpa.find(Member.class, memberId);

// 수정
Member member = jpa.find(Member.class, memberId);
member.setName("이름변경"); // jpa는 update 메소드가 따로 없다.

// 연관된 객체 조회
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam();
```


## 1.2 패러다임 불일치
- 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르다.
- 기능과 표현 방법도 다르다.
- 객체 구조를 테이블 구조에 저장하는 데는 한계가 있다.

### 1.2.1 상속
객체는 상속이라는 기능을 가지고 있지만 테이블은 상속이라는 기능이 없다.(일부 데이터베이스는 상속 기능을 지원하지만 객체의 상속과는 약간 다르다.)

<center><img src="/assets/images/posts/books/2/1_2_객체상속모델.png" alt="객체상속모델" width="90%" height="90%"></center>

<br/>

데이터 베이스 모델링에서는 슈퍼타입 서브타입 관계를 사용하면 유사하게 만들 수 있다.

<center><img src="/assets/images/posts/books/2/1_2_테이블모델.png" alt="테이블모델" width="90%" height="90%"></center>

<br/>

위의 구조를 JDBC API를 사용해서 구현하려면 작성해야 할 코드량이 만만치 않다. 
- INSERT INTO ITEM...
- INSERT INTO ALBUM...

<br/>

**JPA와 상속**  
JPA는 상속과 관련된 패러다임 불일치 문제를 개발자 대신 해결해 준다.

```java
// 저장
jpa.persist(album);

// JPA에서 실행 해주는 SQL
INSERT INTO ITEM...
INSERT INTO ALBUM...
```

<br/>

### 1.2.2 연관관계
- **객체는 참조를 사용해 다른 객체와 연관관계**를 가진다. 참조에 접근해서 연관된 객체를 조회한다.
- **테이블은 외래 키를 사용해 다른 테이블과 연관관계**를 가진다. 조인을 사용해서 연관된 테이블을 조회한다. 
- **객체는 참조가 있는 방향으로만 조회할 수 있다.**
<center><img src="/assets/images/posts/books/2/1_2_연관관계.png" alt="연관관계" width="90%" height="90%"></center>

<br/>

**객체를 테이블에 맞추어 모델링**  
```java
// 관계형 데이터베이스가 사용하는 방식에 맞추면 객체 참조를 통해 조회할 수 없다.
class Member {
    String id;   // MEMBER_ID 컬럼 사용
    Long teamId; // TEAM_ID FK 컬럼 사용
}
```

<br/>

**객체지향 모델링**  
```java
// 패러다임 불일치를 해결하려고 소모하는 코드가 많다.
class Member {
    String id;   // MEMBER_ID 컬럼 사용
    Team team; // 참조로 연관관계를 맺는다.
}

// 데이터베이스에 저장
member.getId();
member.getTeam.getId(); // TEAM_ID FK를 직접 구해야 함
...생략...

// 조회
SQL 실행
Member member = new Member ();
Team team = new Team();
...생략...
member.setTeam(team); // 직접 회원과 팀 관계 설정
```

<br/>

**JPA와 연관관계**  
```java
// JPA는 연관관계와 관련된 패러다임 불일치 문제를 해결해준다.

// 저장
member.setTeam(team);
jpa.persist(member); // TEAM_ID FK를 직접 지정할 필요 없음

// 조회
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam(); // 바로 사용 가능
```

<br/>

### 1.2.3 객체 그래프 탐색
객체에서 회원에 소속된 팀을 조회할 때는 다음처럼 참조를 사용해서 연관된 팀을 찾으면 되는데, 이것을 객체 그래프 탐색이라 한다.

<center><img src="/assets/images/posts/books/2/1_2_객체그래프탐색.png" alt="객체그래프탐색" width="90%" height="90%"></center>

<br/>

```java
// 객체 그래프 탐색
member.getOrder().getOrderItem()...

// 문제 발생
member.getOrder(); // 만약 null이라면?
```

**SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.** 이는 객체 그래프가 언제 끊어질지 모르기 때문에 함부로 탐색할 수 없다.

**JPA와 객체 그래프 탐색**  
JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다(**지연로딩**). 따라서 JPA를 사용하면 연관된 객체를 신뢰하고 조회할 수 있다.


### 1.2.4 비교
- 데이터베이스는 기본 키의 값으로 각 row를 구분
- 객체는 동일성, 동등성 비교.
  - 동일성은 == 비교. 객체 인스턴스의 주소 값을 비교한다.
  - 동등성은 equals() 비교. 객체 내부의 값을 비교한다.

**JDBC API 비교**  
```java
String memberId = "100";
Member member1 = memberDAO.getMember(memberID);
Member member2 = memberDAO.getMember(memberID);

// false
member1 == member2;
```

**JPA 비교**  
```java
String memberId = "100";
Member member1 = jpa.find(memberID);
Member member2 = jpa.find(memberID);

// true
member1 == member2;
```

<br/>

### 1.2.5 정리
**객체 모델과 관계형 데이터베이스 모델은 지향하는 패러다임이 서로 다르다.** 이 패러다임 차이를 극복하려고 개발자가 너무 많은 시간과 코드를 소비한다. 결국, 객체 모델링은 힘을 잃고 점점 데이터 중심의 모델로 변해간다.

**JPA는 패러다임 불일치 문제를 해결하고, 정교한 객체 모델링을 유지하게 도와준다.**

<br/>
<br/>

## 1.3 JPA란 무엇인가?
**JPA(java persistence API)는 자바진영 ORM 기술 표준**이다. 애플리케이션과 JDBC 사이에서 동작한다.

<center><img src="/assets/images/posts/books/2/1_3_JPA.png" alt="JPA" width="90%" height="90%"></center>

<br/>

**ORM이란?**  
ORM(Object-Relational Mapping)은 **객체와 관계형 데이터 베이스를 매핑한다는 뜻**이다. 다양한 ORM 프레임워크들이 있는데 자바 진영에서는 **하이버네이트 프레임워크가 가장 많이 사용**된다.

<center><img src="/assets/images/posts/books/2/1_3_JPA조회.png" alt="JPA조회" width="80%" height="80%"></center>

<br/>
<br/>

### 1.3.1 JPA 소개
<center><img src="/assets/images/posts/books/2/1_3_JPA표준인터페이스와구현체.png" alt="JPA표준인터페이스와구현체" width="80%" height="80%"></center>

<br/>

**JPA는 자바 ORM 기술에 대한 API 표준 명세다.** 쉽게 이야기해서 인터페이스를 모아둔 것이다. 따라서 JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택해야 한다. ORM 프레임워크 중 **하이버네이트가 가장 대중적**이다.

<br/>

### 1.3.2 왜 JPA를 사용해야 하는가?
- 생산성
- 유지보수
- 패러다임 불일치 해결
- 성능 (캐시)
- 데이터 접근 추상화와 벤더 독립성
  - 데이터베이스마다 사용법이 다르다 (예: 페이징 쿼리)
  - JPA에게 데이터베이스만 알려주면 자동으로 해결된다
- 표준
  - 자바 진영 ORM 기술 표준
  - 표준을 사용하면 다른 구현 기술로 손쉽게 변경 가능

<center><img src="/assets/images/posts/books/2/1_3_벤더독립성.png" alt="벤더독립성" width="80%" height="80%"></center>

<br/>
<br/>

## 1.4 정리
- SQL을 직접 다룰 때 발생하는 다양한 문제
- 객체지향 언어와 관계형 데이터베이스 사이의 패러다임 불일치 문제
- JPA가 각 문제를 어떻게 해결하는지
- JPA가 무엇인지
- JPA 장점







