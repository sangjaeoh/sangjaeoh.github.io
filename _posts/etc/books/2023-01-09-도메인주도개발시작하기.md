---
layout: single
title: "📖 도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지"
categories: [etc, books]
tag: [books, DDD]
author_profile: true
toc: true
toc_sticky: true
---

[도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지](https://product.kyobobook.co.kr/detail/S000001810495){:target="_blank"} 책을 읽고 내용을 아주 간단하게 정리한 글입니다. 책에는 자세한 설명과 예제가 많으니 **꼭 구입해서 읽는것을 추천**합니다~👍

---

# 1. 도메인 모델 시작하기
## 1.1 도메인이란?
소프트웨어로 해결하고자 하는 문제 영역을 도메인이라 한다.

## 1.2 도메인 전문가와 개발자 간 지식공유
"Garbage in, Garbage out" 잘못된 값이 들어가면 잘못된 결과가 나온다.  

전문가나 관련자가 요구한 내용이 항상 올바른 것은 아니다. 그래서 개발자는 요구사항을 이해할 때 왜 이런 기능일 요구하는지 또는 실제로 원하는게 무엇인지 생각하고 전문가와 대화를 통해 진짜로 원하는 것을 찾아야 한다.

## 1.3 도메인 모델
도메인 모델은 특정 도메인을 개념적으로 표현한 것이다. 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는데 도움이 된다. 도메인 모델을 이해하는 데 도움이 된다면 객체기반 표현이든, 함수 표현이든 표현 방식이 무엇인지는 중요하지 않다.
<center><img src="/assets/images/posts/books/1/1_3_객체기반도메인모델.png" alt="객체기반도메인모델" width="70%" height="70%"></center>
<center><img src="/assets/images/posts/books/1/1_3_상태다이어그램도메인모델.png" alt="상태다이어그램도메인모델" width="70%" height="70%"></center>

## 1.4 도메인 모델 패턴
<center><img src="/assets/images/posts/books/1/1_4_아키텍처구성.png" alt="아키텍처구성" width="50%" height="50%"></center>

| 영역                                          | 설명                                                                                                                                |
| --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| 사용자 인터페이스(UI) 또는 표현(Presentation) | 사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 여기서 사용자는 소프트웨어를 사용하는 사람뿐만 아니라 외부 시스템일 수도 있다. |
| 응용(Application)                             | 사용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다.                           |
| 도메인(Domain)                                | 시스템이 제공할 도메인 규칙을 구현한다.                                                                                             |
| 인프라스트럭처(Infrastructure)                | 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리한다.                                                                |

<br/>

**개념 모델과 구현 모델**  
개념 모델은 순수하게 문제를 분석한 결과물이다. 개념 모델은 데이터베이스, 트랜잭션 처리, 성능, 구현 기술과 같은 것을 고려하고 있지 않기 때문에 실제 코드를 작성할 때 개념 모델을 있는 그대로 사용할 수 없다. 그래서 개념 모델을 구현 가능한 형태의 모델로 전환하는 과정을 거치게 된다.

처음부터 완벽한 개념 모델을 만들기보다는 전반적인 개요를 알 수 있는 수준으로 개념 모델을 작성해야한다. 프로젝트 초기에는 개요 수준의 개념 모델로 도메인에 대한 전체 윤곽을 이해하는 데 집중하고, 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전시켜 나가야 한다.


## 1.5 도메인 모델 도출
도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다. 이 과정은 요구사항에서 출발한다. 요구사항을 통해 도메인 모델을 점진적으로 만들어 나간다. 이렇게 만든 모델은 요구사항 정련을 위해 도메인 전문가나 다른 개발자와 논의하는 과정에서 공유되기도 한다. 모델을 공유할 때는 화이트보드나 위키 같은 도구를 사용해서 누구나 쉽게 접근할 수 있도록 하면 좋다.


## 1.6 엔티티와 벨류
### 1.6.1 엔티티
- 식별자를 가진다.
- 식별자는 엔티티 객체마다 고유하다.

### 1.6.2 엔티티의 식별자 생성
- 특정 규칙에 따라 생성.
- UUID나 Nano ID와 같은 고유 식별자 생성기 사용.
- 값을 직접 입력.
- 일련번호 사용(시퀀스나 DB의 자동 증가 컬럼 사용).

### 1.6.3 밸류 타입
- 밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용한다.
- 의미를 명확하게 표현하기 위해 사용되기도 한다.
- 밸류 타입을 위한 기능을 추가할 수 있다.
- 불변으로 구현한다.

### 1.6.4 엔티티 식별자와 밸류 타입
- 식별자를 위한 밸류 타입을 사용해서 의미가 잘 드러나도록 할 수 있다.

### 1.6.5 도메인 모델에 set 넣지 않기
- 상태 변경을 위한 set 사용시 도메인 지식이 코드에서 사라진다.
- 객체를 생성할 때 온전하지 않은 상태가 될 수 있다. 

**DTO도 최대한 불변 객체로 사용하도록 하자**

## 1.7 도메인 용어와 유비쿼터스 언어
**도메인 용어**  
STEP1, STEP2 같은것이 아닌 PAYMENT_WAITING, PREPARING 같은 도메인 용어를 사용하여 코드를 작성한다.

**유비쿼터스 언어**  
전문가, 관계자 개발자가 도메인과 관련된 공통의 언어를 만들고 이를 대화, 문서, 도메인 모델, 코드 테스트 등 모든 곳에서 같은 용어를 사용한다. 이렇게 하면 소통 과정에서 발생하는 용어의 모호함을 줄일 수 있고 개발자는 도메인과 코드 사이에서 불필요한 해석 과정을 줄일 수 있다.

<br/>

# 2. 아키택처 개요
## 2.1 네 개의 영역
**표현 영역**  
사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할
<center><img src="/assets/images/posts/books/1/2_1_표현영역.png" alt="표현영역" width="80%" height="80%"></center>

<br/>

**응용 영역**  
표현 영역을 통해 요청을 전달받아 시스템이 사용자에게 제공해야 할 기능을 구현하는 역할. 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.
<center><img src="/assets/images/posts/books/1/2_1_응용영역.png" alt="응용영역" width="80%" height="80%"></center>

<br/>

**도메인 영역**  
도메인 모델을 구현. 도메인 모델은 도메인의 핵심 로직을 구현한다.

<br/>

**인프라스트럭처 영역**  
구현 기술에 대한 것을 다룬다. 이 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.
<center><img src="/assets/images/posts/books/1/2_1_인프라스트럭처영역.png" alt="인프라스트럭처영역" width="40%" height="40%"></center>


## 2.2 계층 구조 아키텍처
<img src="/assets/images/posts/books/1/2_2_계층구조.png" alt="계층구조" width="30%" height="30%">
<img src="/assets/images/posts/books/1/2_2_계층구조상의존관계.png" alt="계층구조상의존관계" width="50%" height="50%">
- 상위 계층에서 하위 계층으로 의존만 존재하고 하위 계층에서 상위 계층에 의존하지 않는다.

## 2.3 DIP
<center><img src="/assets/images/posts/books/1/2_3_고수준저수준.png" alt="고수준저수준" width="60%" height="60%"></center>
<center><img src="/assets/images/posts/books/1/2_3_고수준저수준2.png" alt="고수준저수준2" width="60%" height="60%"></center>
<center><img src="/assets/images/posts/books/1/2_3_고수준저수준3.png" alt="고수준저수준3" width="60%" height="60%"></center>
<center><img src="/assets/images/posts/books/1/2_3_DIP.png" alt="DIP" width="70%" height="70%"></center>

## 2.4 도메인 영역의 주요 구성요소

| **요소** | **설명** |
| ------  | ------- |
| 엔티티 ENTITY                | 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다. 주문, 회원, 상품과 같이 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다. |
| 밸류 VALUE                   | 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현한다. 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다.                                        |
| 애그리거트 AGGREGATE         | 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. 예를 들어 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 '주문' 애그리거트로 묶을 수 있다.                         |
| 리포지터리 REPOSITORY        | 도메인 모델의 영속성을 처리한다. 예를 들어 DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공한다.                                                                                  |
| 도메인 서비스 DOMAIN SERVICE | 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다.                                                            |


## 2.5 요청 처리 흐름
<center><img src="/assets/images/posts/books/1/2_5_요청처리흐름.png" alt="요청처리흐름" width="80%" height="80%"></center>

## 2.6 인프라스트럭처 개요
- 도메인 객체의 영속성 처리, 트랜젝션, REST 클라이언트 등 다른영역에서 필요로 하는 프레임워크, 구현 기술, 보조 기능을 지원한다.
- 보통 의존성역전 사용
- @Transactional 같은 DIP를 사용하지 않는 예외도 편의를 위해 허용

## 2.7 모듈 구성
<center><img src="/assets/images/posts/books/1/2_7_모듈구성1.png" alt="모듈구성1" width="60%" height="60%"></center>
<center><img src="/assets/images/posts/books/1/2_7_모듈구성2.png" alt="모듈구성2" width="60%" height="60%"></center>
<center><img src="/assets/images/posts/books/1/2_7_모듈구성3.png" alt="모듈구성3" width="60%" height="60%"></center>


# 3. 애그리거트
## 3.1 애그리거트
복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만드려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 애그리거트다. 애그리거트는 관련된 객체를 하나의 군으로 묶어 준다.
<center><img src="/assets/images/posts/books/1/3_1_애거리거트모델.png" alt="애거리거트모델" width="60%" height="60%"></center>

애그리거트는 경계를 갖는다. 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 애그리거트는 독립된 객체 군이며 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다. 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다. 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.

## 3.2 애그리거트 루트
애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트 루트 엔티티이다. 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직접 또는 간접적으로 속하게 된다.
<center><img src="/assets/images/posts/books/1/3_2_애그리거트루트.png" alt="애그리거트루트" width="50%" height="50%"></center>

### 3.2.1 도메인 규칙과 일관성
- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다. 이것은 모델의 일관성을 깨는 원인이 된다.
- 단순히 필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는다.
- 밸류 타입은 불변으로 구현한다.

### 3.2.2 애그리거트 루트의 기능 구현
- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해 기능을 완성한다.
- 애그리거트 루트가 구성요소의 상태만 참조하는 것은 아니다. 기능 실행을 위임하기도 한다.

### 3.2.3 트랜젝션 범위
- 작을수록 좋다
- 한 트랜젝션에서는 한 개의 애그리거트만 수정한다.
- 부득이하게 한 트랜젝션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 수정하지 말고, 응용 서비스에서 애그리거트를 수정하도록 구현한다.
- 두 개 이상의 애그리거트를 수정해야 한다면, 도메인 이벤트를 사용한다.

## 3.3 리포지터리와 애그리거트
- 애그리거트: 개념상 완전한 하나의 도메인 모델
- 리포지터리: 애그리거트 영속성을 처리
  - save: 애그리거트 저장
  - findById: ID로 애그리거트를 구함

## 3.4 ID를 이용한 애그리거트 참조
- 애그리거트도 다른 애그리거트를 참조한다.
- 애그리거트 참조는 애그리거트 루트가 다른 애그리거트 루트를 참조한다는 뜻이다.

<br/>

**필드 참조**
<center><img src="/assets/images/posts/books/1/3_4_필드참조.png" alt="필드참조" width="70%" height="70%"></center>

문제점  
- 편한 탐색 오용
- 결합도 증가
- 성능에 대한 고민
- 확장 어려움

<br/>

**ID를 이용한 참조**
<center><img src="/assets/images/posts/books/1/3_4_ID참조.png" alt="ID참조" width="70%" height="70%"></center>

장점
- 모델의 복잡도를 낮춘다
- 응집도 증가
- 구현 난이도 감소
- 확장 용이


### 3.4.1 ID를 이용한 참조와 조회 성능
**N + 1 문제 발생**  

해결방법
- 조회 전용 쿼리를 만들어 사용한다.
- 쿼리가 복잡하거나 특화된 기능을 사용해야 한다면 마이바티스와 같은 기술로 구현하는걸 고려한다. 

## 3.5 애그리거트 간 집합 연관
1-N, M-N 연관에 대해 살펴본다.

**1-N**
```java
public class Category {
    private Set<Product> products; //다른 애그리거트에 대한 1-N 연관
}
```
조회시 개념적으로 애거리거트 간에 1-N 연관이 있더라도 성능 문제 때문에 실제 구현에 반영하지 않는다. N-1로 연관지어 구현한다.

```java
public class Product {
    private CategoryId categoryId;
}
```
```java
public class ProductListService {
    public Page<Product> getProductOfCategory(Long categoryId, int page, int size) {
        Category category = categoryRepository.findById(categoryId);
        checkCategory(category);
        List<Product> products = productRepository.findByCategoryId(category.getId(), page, size);
        int totalCount = productRepository.countByCategoryId(category.getId());
        return new Page(page, size, totalCount, products);
    }
}
```

<br/>

**M-N**  
M-N 연관은 개념적으로 양쪽 애그리거트에 컬렉션으로 연관을 만든다. 하지만 구현은 요구사항을 고려해서 결정한다. 개념적으로는 상품과 카테고리의 양방향 M-N 연관이 존재하지만 실제 구현에서는 상품에서 카테고리로의 단방향 M-N 연관만 적용하면 되는 것이다.
```java
public class Product {
    private Set<CategoryId> categoryIds;
}
```

**RDBMS에서 M-N 연관 구현**  
<center><img src="/assets/images/posts/books/1/3_5_RDBMS_M-N연관.png" alt="RDBMS_M-N연관" width="70%" height="70%"></center>

<br/>

**JPA를 이용하여 ID 참조를 이용한 M-N 단방향 연관 구현**  
```java
@Entity
@Table(name = "product")
public class Product {
    @EmbeddedId
    private ProductId id;
    
    @ElementCollection
    @CollectionTable(name = "product_category",
        joinColumns = @JoinColumn(name = "product_id"))
    private Set<CategoryId> categoryIds;
    ...
}
```

## 3.6 애그리거트를 팩토리로 사용하기
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려한다.
- 별도의 도메인 서비스나, 팩토리 클래스를 만들 수도 있다.

```java
public class Store {

    public Product createProduct (ProductId newProductId, ...생략) {
        if (isBlocked()) {
            throw new StoreBlockedException();
        }
        return new Product(newProductId, getId(), ...생략);
    }

}
```

<br/>

# 4. 리포지터리와 모델 구현
4장과 5장은 스프링 데이터 JPA의 사용방법에 대해서 설명합니다. 여기서는 책의 자세한 설명을 하지 않습니다. 아래의 문서와 책을 읽는 것을 추천합니다. 👍
- [도메인 주도 개발 시작하기: DDD 핵심 개념 정리부터 구현까지](https://product.kyobobook.co.kr/detail/S000001810495){:target="_blank"}
- [자바 ORM 표준 JPA 프로그래밍](http://www.yes24.com/Product/Goods/19040233){:target="_blank"}
- [Spring Data JPA](https://spring.io/projects/spring-data-jpa){:target="_blank"}


## 4.1 JPA를 이용한 리포지터리 구현
### 4.1.1 모듈 위치
<center><img src="/assets/images/posts/books/1/4_1_모듈위치.png" alt="모듈위치" width="70%" height="70%"></center>

### 4.1.2 리포지터리 기본 기능 구현
```java
public interface OrderRepository {
    Order findById(OrderNo no);
    void save(Order order);
}
```
```java
public class JpaOrderRepository implements OrderRepository {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public Order findById(OrderNo id) {
        return entityManager.find(Order.class, id);
    }

    @Override
    public void save(Order order) {
        entityManager.persist(order);
    }
}
```


## 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현

```java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number;

    @Version
    private long version;

    @Embedded
    private Orderer orderer;

    ...생략...
}
```
```java
public interface OrderRepository extends Repository<Order, OrderNo> {
    Optional<Order> findById(OrderNo id);

    void save(Order order);

    default OrderNo nextOrderNo() {
        int randomNo = ThreadLocalRandom.current().nextInt(900000) + 100000;
        String number = String.format("%tY%<tm%<td%<tH-%d", new Date(), randomNo);
        return new OrderNo(number);
    }
}
```
```java
@Service
public class CancelOrderService {
    private OrderRepository orderRepository;
    private CancelPolicy cancelPolicy;

    public CancelOrderService(OrderRepository orderRepository, CancelPolicy cancelPolicy) {
        this.orderRepository = orderRepository;
        this.cancelPolicy = cancelPolicy;
    }

    @Transactional
    public void cancel(OrderNo orderNo, Canceller canceller) {
        Order order = orderRepository.findById(orderNo)
                .orElseThrow(() -> new NoOrderException());
        if (!cancelPolicy.hasCancellationPermission(order, canceller)) {
            throw new NoCancellablePermission();
        }
        order.cancel();
    }
}
```




## 4.3 매핑 구현
### 4.3.1 엔티티와 밸류 기본 매핑 구현
애그리거트와 JPA 매핑을 위한 기본 규칙
- 애그리거트 루트는 엔티티이므로 `@Entity`로 매핑 설정한다.

한 테이블에 엔티티와 밸류 데이터가 같이 있다면
- 밸류는 `@Embeddable`로 매핑 설정한다.
- 밸류 타입 프로퍼티는 `@Embedded`로 매핑 설정한다.
- 매핑할 컬럼명 변경은 `@AttributeOverrides` 를 이용한다

<center><img src="/assets/images/posts/books/1/4_3_매핑구현.png" alt="매핑구현" width="70%" height="70%"></center>

```java
@Embeddable
@Embeddable
public class ShippingInfo {
    @Embedded
    @AttributeOverrides({
            @AttributeOverride(name = "zipCode", column = @Column(name = "shipping_zip_code")),
            @AttributeOverride(name = "address1", column = @Column(name = "shipping_addr1")),
            @AttributeOverride(name = "address2", column = @Column(name = "shipping_addr2"))
    })
    private Address address;
    @Column(name = "shipping_message")
    private String message;
    @Embedded
    private Receiver receiver;
```
```java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    ...
    @Embedded
    private Orderer orderer;

    @Embedded
    private ShippingInfo shippingInfo;
    ...
```


### 4.3.2 기본 생성자
```java
protected Receiver(){}
```

### 4.3.2 필드 접근 방식 사용
`@Access`를 이용해서 명시적으로 접근 방식을 지정하지 않으면 `@Id`나 `@EmbeddedId`의 위치에 따라 접근 방식을 결정한다.
```java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    ...생략...
}
```

### 4.3.4 AttributeConverter를 이용한 밸류 매핑 처리
두 개 이상의 프로퍼티를 가진 밸류 타입을 한 개 컬럼에 매핑하려면 `@Embeddable` 애너테이션으로는 처리할 수 없다. 이럴 때 사용할 수 있는 것이 `AttributeConverter`이다.

<center><img src="/assets/images/posts/books/1/4_3_두개프러퍼컬럼매핑.png" alt="두개프러퍼컬럼매핑" width="70%" height="70%"></center>

```java
@Converter(autoApply = true)
public class MoneyConverter implements AttributeConverter<Money, Integer> { 
    // Money는 밸류 타입, Integer는 DB 타입

    // 밸류 타입을 DB 칼럼 값으로 변환
    @Override
    public Integer convertToDatabaseColumn(Money money) {
        return money == null ? null : money.getValue();
    }

    // DB 칼럼 값을 밸류로 변환
    @Override
    public Money convertToEntityAttribute(Integer value) {
        return value == null ? null : new Money(value);
    }
}
```
```java
// @Converter(autoApply = true) 작성한 타입에 대해 자동 적용
public class Order {

    @Column(name = "total_amounts")
    private Money totalAmounts;
}
```
```java
// @Converter(autoApply = false) 기본값, 직접 지정해야함
public class Order {

    @Convert(converter = MoneyConverter.class)
    @Column(name = "total_amounts")
    private Money totalAmounts;
}
```

### 4.3.5 밸류 컬렉션: 별도 테이블 매핑
밸류 컬렉션을 별도 테이블로 매핑할때는 `@ElementCollection`과 `@CollectionTable`을 함께 사용한다.

<center><img src="/assets/images/posts/books/1/4_3_밸류컬렉션테이블매핑.png" alt="밸류컬렉션테이블매핑" width="70%" height="70%"></center>

```java
@Entity
@Table(name = "purchase_order")
public class Order {
    @EmbeddedId
    private OrderNo number;

    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "order_line", joinColumns = @JoinColumn(name = "order_number"))
    @OrderColumn(name = "line_idx")
    private List<OrderLine> orderLines;
    ...생략...
}
```
```java
@Embeddable
public class OrderLine {
    @Embedded
    private ProductId productId;

    @Column(name = "price")
    private Money price;

    @Column(name = "quantity")
    private int quantity;

    @Column(name = "amounts")
    private Money amounts;
}
```

### 4.3.6 밸류 컬렉션: 한 개 컬럼 매핑
한 개 컬럼에 콤마로 구분해서 저장할 때 사용. `AttributeConverter`를 이용한다.

```java
public class EmailSet {
    private Set<Email> emails = new HashSet<>();

    public EmailSet(Set<Email> emails) {
        this.emails.addAll(emails);
    }

    public Set<Email> getEmails() {
        return Collections.unmodifiableSet(emails);
    }
}
```
```java
public class EmailSetConverter implements AttributeConverter<EmailSet, String> {
    @Override
    public String convertToDatabaseColumn(EmailSet attribute) {
        if (attribute == null) return null;
        return attribute.getEmails().stream()
                .map(email -> email.getAddress())
                .collect(Collectors.joining(","));
    }

    @Override
    public EmailSet convertToEntityAttribute(String dbData) {
        if (dbData == null) return null;
        String[] emails = dbData.split(",");
        Set<Email> emailSet = Arrays.stream(emails)
                .map(value -> new Email(value))
                .collect(toSet());
        return new EmailSet(emailSet);
    }
}
```

### 4.3.7 밸류를 이용한 ID 매핑
JPA에서 식별자 타입은 `Serializable` 타입이어야 하므로 `Serializable` 인터페이스를 상속받아야 한다. 밸류 타입으로 식별자를 구현할 때 얻을 수 있는 장점은 식별자에 기능을 추가할 수 있다는 점이다.

```java
@Entity
@Table(name = "purchase_order")
public class Order {
    @EmbeddedId
    private OrderNo number;
    ...생략...
}
```
```java
@Embeddable
public class OrderNo implements Serializable {
    @Column(name = "order_number")
    private String number;
    ...생략...
}
```

### 4.3.8 별도 테이블에 저장하는 밸류 매핑
루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해 봐야한다. 단지 별도 테이블에 데이터를 저장 한다고 해서 엔티티인 것은 아니다.

예를 들어 게시글 데이터를 `ARTICLE` 테이블과 `ARTICLE_CONTENT` 테이블로 나눠서 저장한다고 하자.

**엔티티로 매핑 예 (잘못 됨)**
<center><img src="/assets/images/posts/books/1/4_3_밸류매핑잘못.png" alt="밸류매핑잘못" width="70%" height="70%"></center>

<br/>

**별도 테이블로 매핑**  
<center><img src="/assets/images/posts/books/1/4_3_밸류매핑별도테이블.png" alt="밸류매핑별도테이블" width="70%" height="70%"></center>

밸류 매핑을 별도 테이블로 저장 하려면 `@SecondaryTable`과 `@AttributeOverride`을 사용한다.
```java
@Entity
@Table(name = "article")
@SecondaryTable(
        name = "article_content",
        pkJoinColumns = @PrimaryKeyJoinColumn(name = "id")
)
public class Article {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    @AttributeOverrides({
            @AttributeOverride(
                    name = "content",
                    column = @Column(table = "article_content", name = "content")),
            @AttributeOverride(
                    name = "contentType",
                    column = @Column(table = "article_content", name = "content_type"))
    })
    @Embedded
    private ArticleContent content;
}
```

### 4.3.9 밸류 컬렉션을 @Entity로 매핑하기
`@OneToMany` 사용
```java
@Entity
@Table(name = "product")
public class Product {
    ...생략...
    @OneToMany(cascade = {CascadeType.PERSIST, CascadeType.REMOVE},
            orphanRemoval = true, fetch = FetchType.LAZY)
    @JoinColumn(name = "product_id")
    @OrderColumn(name = "list_idx")
    private List<Image> images = new ArrayList<>();
    ...생략...
```

<br/>

`@Inheritance`를 이용한 상속 가능
```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "image_type")
@Table(name = "image")
public abstract class Image {
    ...생략...
}
```
```java
@Entity
@DiscriminatorValue("II")
public class InternalImage extends Image {
    ...생략...
}
@Entity
@DiscriminatorValue("EI")
public class ExternalImage extends Image {
    ...생략...
```


### 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑
```java
@Entity
@Table(name = "product")
public class Product {
    ...생략...
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "product_category",
            joinColumns = @JoinColumn(name = "product_id"))
    private Set<CategoryId> categoryIds;
    ...생략...
}
```


## 4.4 애그리거트 로딩 전략
```java
// @Embeddable 컬렉션에 대한 즉시 로딩 설정
@ElementCollection(fetch = FetchType.EAGER)

// @Entity 컬렉션에 대한 지연 로딩 설정
@OneToMany(fetch = FetchType.LAZY)
```
- 즉시 로딩: 에그리거트 루트를 구할 때 연관된 구성 요소를 DB에서 함께 읽어온다.
- 지연 로딩: 실제 컬렉션에 접근할 때 DB에서 조회한다.

## 4.5 애그리거트 영속성 전파
애그리거트가 완전한 상태여야 한다는 것은 애그리거트 루트를 조회할 때뿐만 아니라 저장하고 삭제할 때도 하나로 처리해야 함을 의미한다.
- 저장 메서드는 애그리거트 루트만 저장하면 안되고 애그리거트에 속한 모든 객체를 저장해야 한다.
- 삭제 메서드는 애그리거트 루트뿌만 아니라 애그리거트에 속한 모든 객체를 삭제해야 한다.
- `@Embeddable` 매핑 타입은 함께 저장되고 삭제 되므로 추가 설정이 필요없다.
- `@Entity` 타입에 대한 매핑은 `cascade` 속성을 사용한다.

```java
@OneToMany(cascade = {CascadeType.PERSIST, CascadeType.REMOVE})
```


**... 작성중 ...**