---
layout: single
title: "Kubernetes 살펴보기"
categories: [Kubernetes]
tag: [Kubernetes, k8s]
author_profile: true
toc: true
toc_sticky: true
---

💾 쿠버네티스의 기본 개념을 정리한 내용입니다.

<br/>

# 🎯 쿠버네티스란?
쿠버네티스는 컨테이너화된 애플리케이션을 배포, 관리, 확장할 때 수반되는 다수의 수동 프로세스를 자동화하는 <span class="danger-color">오픈소스 컨테이너 오케스트레이션 플랫폼</span>입니다.

| **용어** | **뜻** |
| --- | --- |
| 컨테이너 | 앱이 구동되는 환경까지 감싸서 실행할 수 있도록 하는 격리 기술 |
| 컨테이너 런타임 | 컨테이너를 다루는 도구 |
| 도커 | 컨테이너를 다루는 도구 중 가장 유명한 것 |
| 쿠버네티스 | 컨이너 런타임을 통해 컨테이너를 오케스트레이션 하는 도구 |
| 오케스트레이션 | 여러 서버에 걸친 컨테이너 및 사용하는 환경 설정을 관리하는 행위 |

<br/>
<br/>
<br/>



# 🎯 쿠버네티스가 할 수 있는 일은?
- **서비스 디스커버리와 로드 밸런싱:** 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있습니다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있습니다.
- **스토리지 오케스트레이션:** 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있습니다.
- **자동화된 롤아웃과 롤백:** 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있습니다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있습니다.
- **자동화된 빈 패킹(bin packing):** 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공합니다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시합니다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해줍니다.
- **자동화된 복구(self-healing):** 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않습니다.
- **시크릿과 구성 관리:** 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있습니다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 할 수 있습니다.
<br/>
<br/>
<br/>
<br/>



# 🎯 쿠버네티스 구성 요소
- [쿠버네티스 컴포넌트 설명](https://kubernetes.io/ko/docs/concepts/overview/components/){:target="_blank"}
- [쿠버네티스 아키텍처 설명](https://www.redhat.com/ko/topics/containers/kubernetes-architecture){:target="_blank"}
![kubernetes components](/assets/images/posts/kubernetes/20230306/589D640F-E2E0-4750-9B73-58187E0F7BB9.png)
![kubernetes components](/assets/images/posts/kubernetes/20230306/5485F1CF-F476-4537-B8D8-3B2E15FECBD2.png)




## 용어 정리
[용어 정리](https://kubernetes.io/ko/docs/reference/glossary/?fundamental=true){:target="_blank"}

- **컨트롤 플레인:** 쿠버네티스 노드를 제어하는 프로세스의 컬렉션입니다. 여기에서 모든 태스크 할당이 시작됩니다.
- **노드:** 컨트롤 플레인에서 할당된 요청 태스크를 수행하는 머신입니다.
- **포드:** 단일 노드에 배포된 하나 이상의 컨테이너 그룹입니다. 포드에 있는 모든 컨테이너는 IP 주소, IPC, 호스트 이름, 기타 리소스를 공유합니다. 포드는 기본 컨테이너에서 네트워크와 스토리지를 추상화합니다. 이렇게 하면 클러스터에서 컨테이너를 더 쉽게 이동할 수 있습니다.
- **복제 컨트롤러:** 이 컨트롤러는 클러스터에서 실행되어야 하는 동일한 포드 복사본의 개수를 제어합니다.
- **서비스:** 포드에서 작업 정의를 분리합니다. 쿠버네티스 서비스 프록시는 클러스터에서 다른 위치로 이동된 경우나 교체된 경우에 상관없이 서비스 요청을 적절한 포드로 자동 수신합니다.
- **Kubelet:** 이 서비스는 노드에서 실행되며 컨테이너 매니페스트를 읽고, 정의된 컨테이너가 시작되어 실행 중인지 확인합니다.
- **kubectl:** 쿠버네티스의 커맨드 라인 구성 툴입니다.  
<br/>
<br/>



## 컨트롤 플레인 컴포넌트
컨트롤 플레인 컴포넌트는 클러스터에 관한 전반적인 결정(예를 들어, 스케줄링)을 수행하고 클러스터 이벤트(예를 들어, 디플로이먼트의 `replicas` 필드에 대한 요구 조건이 충족되지 않을 경우 새로운 파드를 구동시키는 것)를 감지하고 반응합니다.

- **kube-apiserver:** API 서버는 쿠버네티스 API를 노출하는 컨트롤 플레인의 프론트 엔드
- **etcd:** 모든 클러스터 데이터(구성 요소들의 상태 값 등)를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소
- **Kube-scheduler:** 노드가 배정되지 않은 새로 생성된 파드를 감지하고, 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당
- **kube-controller-manager:** 쿠버네티스 클러스터의 오브젝트 상태를 관리합니다.
  - **노드 컨트롤러:** 노드가 다운되었을 때 통지와 대응에 관한 책임
  - **잡 컨트롤러:** 일회성 작업을 나타내는 잡 오브젝트를 감시한 다음, 해당 작업을 완료할 때까지 동작하는 파드를 생성
  - **엔드포인트 컨트롤러:** 서비스와 파드를 연결
  - **서비스 어카운트 & 토큰 컨트롤러:** 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성  
<br/>
<br/>



## 노드 컴포넌트
노드 컴포넌트는 동작 중인 파드를 유지시키고 쿠버네티스 런타임 환경을 제공하며, 모든 노드 상에서 동작합니다.

- **노드:** 컨트롤 플레인에서 할당된 요청 태스크를 수행하는 머신입니다. (서버)
- **파드(pod):** 한 개 이상의 컨테이너로 이루어진 최소 단위
- **컨테이너 런타임(CRI, Container Runtime Interface):** 파드를 이루는 컨테이너의 실행을 담당. 표준 인터페이스
- **kubelet:** 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링
- **kube-proxy:** 클러스터의 각 노드에서 실행되는 네트워크 프록시로, 쿠버네티스의 서비스 개념의 구현부입니다. 노드의 네트워크 규칙을 유지 관리해줍니다. 이 네트워크 규칙이 내부 네트워크 세션이나 클러스터 바깥에서 파드로 네트워크 통신을 할 수 있도록 해줍니다.
- **CoreDNS:** 클라우드 네이티브 컴퓨팅 재단에서 보증하는 프로젝트로, 빠르고 유연한 DNS 서버. 쿠버테티스 클러스터에서 도메인 이름을 이용해 통신하는 데 사용합니다.  
<br/>
<br/>


## 파드의 생명주기로 쿠버네티스 구성 요소 살펴보기
![kubernetes components](/assets/images/posts/kubernetes/20230306/86DFC708-B0C9-495C-BD60-402EC75D59AC.png)

1. `kubectl`을 통해 `API 서버`에 파드 생성을 요청
2. (업데이트가 있을 때 마다) `API 서버`에 전달된 내용이 있으면 `API 서버`는 `etcd`에 전달된 내용을 모두 기록해 클러스터의 상태 값을 최신으로 유지합니다.
3. `API 서버`에 파드 생성이 요청된 것을 `컨트롤러 매니저`가 인지하면 `컨트롤러 매니저는` `파드`를 생성하고, 이 상태를 `API서버`에 전달합니다. 참고로 아직 어떤 워커 노드에 파드를 적용할지는 결정되지 않은 상태로 파드만 생성된다.
4. `API 서버`에 `파드`가 생성됐다는 정보를 `스케줄러`가 인지합니다. `스케줄러`는 생성된 `파드`를 어떤 `워커 노드`에 적용할지 조건을 고려해 결정하고 해당 `워커 노드`에 `파드`를 띄우도록 요청합니다.
5. `API서버`에 전달된 정보대로 지정한 `워커 노드`에 `파드`가 속해 있는지 `스케줄러`가 `kubelet`으로 확인합니다.
6. `kubelet`에서 `컨테이너 런타임`으로 `파드` 생성 요청합니다.
7. `파드` 생성
8. `파드` 사용 가능한 상태가 됩니다.  
<br/>
<br/>



{% capture notice %}
**참고**  
쿠버네티스는 선언적인 시스템 구조를 가지고 있습니다. 즉, 각 요소가 추구하는 상태를 선언하면 현재 상태와 맞는지 점검하고 그것에 맞추려고 노력하는 구조입니다.

![선언적구조](/assets/images/posts/kubernetes/20230306/C43E9BFE-A4C2-4FC0-AB8C-56EBFAA99BE5.png)
{% endcapture %}
<div class="notice--info">{{ notice | markdownify }}</div>



<br/>
<br/><br/>
<br/><br/>
<br/><br/>
<br/><br/>
<br/><br/>
<br/>

작성중....



<!-- # 🙇🏻‍♂️ 참고사이트
- [https://subicura.com](https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html){:target="_blank"}
- [https://www.daleseo.com](https://www.daleseo.com/?tag=Docker){:target="_blank"} -->