---
layout: single
title: "Kubernetes 살펴보기"
categories: [Kubernetes]
tag: [Kubernetes, k8s]
author_profile: true
toc: true
toc_sticky: true
---

💾 쿠버네티스의 기본 개념을 정리한 내용입니다.

<br/>

# 🎯 쿠버네티스란?
쿠버네티스는 컨테이너화된 애플리케이션을 배포, 관리, 확장할 때 수반되는 다수의 수동 프로세스를 자동화하는 <span class="danger-color">오픈소스 컨테이너 오케스트레이션 플랫폼</span>입니다.

| **용어** | **뜻** |
| --- | --- |
| 컨테이너 | 앱이 구동되는 환경까지 감싸서 실행할 수 있도록 하는 격리 기술 |
| 컨테이너 런타임 | 컨테이너를 다루는 도구 |
| 도커 | 컨테이너를 다루는 도구 중 가장 유명한 것 |
| 쿠버네티스 | 컨이너 런타임을 통해 컨테이너를 오케스트레이션 하는 도구 |
| 오케스트레이션 | 여러 서버에 걸친 컨테이너 및 사용하는 환경 설정을 관리하는 행위 |

<br/>
<br/>
<br/>



# 🎯 쿠버네티스가 할 수 있는 일은?
- **서비스 디스커버리와 로드 밸런싱:** 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있습니다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있습니다.
- **스토리지 오케스트레이션:** 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있습니다.
- **자동화된 롤아웃과 롤백:** 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있습니다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있습니다.
- **자동화된 빈 패킹(bin packing):** 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공합니다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시합니다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해줍니다.
- **자동화된 복구(self-healing):** 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, '사용자 정의 상태 검사'에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않습니다.
- **시크릿과 구성 관리:** 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있습니다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트 할 수 있습니다.
<br/>
<br/>
<br/>
<br/>



# 🎯 쿠버네티스 구성 요소
- [쿠버네티스 컴포넌트 설명](https://kubernetes.io/ko/docs/concepts/overview/components/){:target="_blank"}
- [쿠버네티스 아키텍처 설명](https://www.redhat.com/ko/topics/containers/kubernetes-architecture){:target="_blank"}
![kubernetes components](/assets/images/posts/kubernetes/20230306/589D640F-E2E0-4750-9B73-58187E0F7BB9.png)
![kubernetes components](/assets/images/posts/kubernetes/20230306/5485F1CF-F476-4537-B8D8-3B2E15FECBD2.png)




## 용어 정리
[용어 정리](https://kubernetes.io/ko/docs/reference/glossary/?fundamental=true){:target="_blank"}

- **컨트롤 플레인:** 쿠버네티스 노드를 제어하는 프로세스의 컬렉션입니다. 여기에서 모든 태스크 할당이 시작됩니다.
- **노드:** 컨트롤 플레인에서 할당된 요청 태스크를 수행하는 머신입니다.
- **포드:** 단일 노드에 배포된 하나 이상의 컨테이너 그룹입니다. 포드에 있는 모든 컨테이너는 IP 주소, IPC, 호스트 이름, 기타 리소스를 공유합니다. 포드는 기본 컨테이너에서 네트워크와 스토리지를 추상화합니다. 이렇게 하면 클러스터에서 컨테이너를 더 쉽게 이동할 수 있습니다.
- **복제 컨트롤러:** 이 컨트롤러는 클러스터에서 실행되어야 하는 동일한 포드 복사본의 개수를 제어합니다.
- **서비스:** 포드에서 작업 정의를 분리합니다. 쿠버네티스 서비스 프록시는 클러스터에서 다른 위치로 이동된 경우나 교체된 경우에 상관없이 서비스 요청을 적절한 포드로 자동 수신합니다.
- **Kubelet:** 이 서비스는 노드에서 실행되며 컨테이너 매니페스트를 읽고, 정의된 컨테이너가 시작되어 실행 중인지 확인합니다.
- **kubectl:** 쿠버네티스의 커맨드 라인 구성 툴입니다.  
<br/>
<br/>



## 컨트롤 플레인 컴포넌트
컨트롤 플레인 컴포넌트는 클러스터에 관한 전반적인 결정(예를 들어, 스케줄링)을 수행하고 클러스터 이벤트(예를 들어, 디플로이먼트의 `replicas` 필드에 대한 요구 조건이 충족되지 않을 경우 새로운 파드를 구동시키는 것)를 감지하고 반응합니다.

- **kube-apiserver:** API 서버는 쿠버네티스 API를 노출하는 컨트롤 플레인의 프론트 엔드
- **etcd:** 모든 클러스터 데이터(구성 요소들의 상태 값 등)를 담는 쿠버네티스 뒷단의 저장소로 사용되는 일관성·고가용성 키-값 저장소
- **Kube-scheduler:** 노드가 배정되지 않은 새로 생성된 파드를 감지하고, 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당
- **kube-controller-manager:** 쿠버네티스 클러스터의 오브젝트 상태를 관리합니다.
  - **노드 컨트롤러:** 노드가 다운되었을 때 통지와 대응에 관한 책임
  - **잡 컨트롤러:** 일회성 작업을 나타내는 잡 오브젝트를 감시한 다음, 해당 작업을 완료할 때까지 동작하는 파드를 생성
  - **엔드포인트 컨트롤러:** 서비스와 파드를 연결
  - **서비스 어카운트 & 토큰 컨트롤러:** 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성  
<br/>
<br/>



## 노드 컴포넌트
노드 컴포넌트는 동작 중인 파드를 유지시키고 쿠버네티스 런타임 환경을 제공하며, 모든 노드 상에서 동작합니다.

- **노드:** 컨트롤 플레인에서 할당된 요청 태스크를 수행하는 머신입니다. (서버)
- **파드(pod):** 한 개 이상의 컨테이너로 이루어진 최소 단위
- **컨테이너 런타임(CRI, Container Runtime Interface):** 파드를 이루는 컨테이너의 실행을 담당. 표준 인터페이스
- **kubelet:** 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링
- **kube-proxy:** 클러스터의 각 노드에서 실행되는 네트워크 프록시로, 쿠버네티스의 서비스 개념의 구현부입니다. 노드의 네트워크 규칙을 유지 관리해줍니다. 이 네트워크 규칙이 내부 네트워크 세션이나 클러스터 바깥에서 파드로 네트워크 통신을 할 수 있도록 해줍니다.
- **CoreDNS:** 클라우드 네이티브 컴퓨팅 재단에서 보증하는 프로젝트로, 빠르고 유연한 DNS 서버. 쿠버테티스 클러스터에서 도메인 이름을 이용해 통신하는 데 사용합니다.  
<br/>
<br/>


## 파드의 생명주기로 쿠버네티스 구성 요소 살펴보기
![kubernetes components](/assets/images/posts/kubernetes/20230306/86DFC708-B0C9-495C-BD60-402EC75D59AC.png)

1. `kubectl`을 통해 `API 서버`에 파드 생성을 요청
2. (업데이트가 있을 때 마다) `API 서버`에 전달된 내용이 있으면 `API 서버`는 `etcd`에 전달된 내용을 모두 기록해 클러스터의 상태 값을 최신으로 유지합니다.
3. `API 서버`에 파드 생성이 요청된 것을 `컨트롤러 매니저`가 인지하면 `컨트롤러 매니저는` `파드`를 생성하고, 이 상태를 `API서버`에 전달합니다. 참고로 아직 어떤 워커 노드에 파드를 적용할지는 결정되지 않은 상태로 파드만 생성된다.
4. `API 서버`에 `파드`가 생성됐다는 정보를 `스케줄러`가 인지합니다. `스케줄러`는 생성된 `파드`를 어떤 `워커 노드`에 적용할지 조건을 고려해 결정하고 해당 `워커 노드`에 `파드`를 띄우도록 요청합니다.
5. `API서버`에 전달된 정보대로 지정한 `워커 노드`에 `파드`가 속해 있는지 `스케줄러`가 `kubelet`으로 확인합니다.
6. `kubelet`에서 `컨테이너 런타임`으로 `파드` 생성 요청합니다.
7. `파드` 생성
8. `파드` 사용 가능한 상태가 됩니다.  
<br/>
<br/>



{% capture notice %}
**참고**  
쿠버네티스는 선언적인 시스템 구조를 가지고 있습니다. 즉, 각 요소가 추구하는 상태를 선언하면 현재 상태와 맞는지 점검하고 그것에 맞추려고 노력하는 구조입니다.

![선언적구조](/assets/images/posts/kubernetes/20230306/C43E9BFE-A4C2-4FC0-AB8C-56EBFAA99BE5.png)
{% endcapture %}
<div class="notice--info">{{ notice | markdownify }}</div>
<br/>
<br/>
<br/>



# 🎯 오브젝트
쿠버네티스를 사용하는 관점에서 파드, 디플로이먼트 등은 스펙(spec)과 상태(status) 등의 값을 가지고 있습니다. 이러한 값을 가지고 있는 파드와 디플로이먼트 등을 개별 속성을 포함해 부르는 단위를 오브젝트(Object)라고 합니다.

쿠버네티스 오브젝트는 하나의 **의도를 담은 레코드**입니다. 오브젝트를 생성하게 되면, 쿠버네티스 시스템은 그 오브젝트 생성을 보장하기 위해 지속적으로 작동할 것입니다. 오브젝트를 생성함으로써, 클러스터의 워크로드를 어떤 형태로 보이고자 하는지에 대해 효과적으로 쿠버네티스 시스템에 전달합니다.
<br/>
<br/>


## 기본 오브젝트
- **파드(Pod):** 쿠버네티스에 실행되는 최소 단위, 독립적인 공간과 사용 가능한 IP를 가지고 있습니다. 하나의 파드는 1개 이상의 컨테이너를 갖고 있습니다.
- **네임스페이스(Namespaces):** 쿠버네티스 클러스터에서 사용되는 리소스들을 구분해 관리하는 그룹입니다.
- **볼륨(Volume):** 파드가 생성될 때 파드에서 사용할 수 있는 디렉터리를 제공합니다. 기본적으로 파드는 영속되는 개념이 아니라 제공되는 디렉토리도 임시로 사용합니다. 하지만 파드가 사라지더라도 저장과 보존이 가능한 디렉터리를 볼륨 오브젝트를 통해 생성하고 사용할 수 있습니다.
- **서비스(Service):** 파드는 클러스터 내에서 유동적이기 때문에 접속 정보가 고정일 수 없습니다. 따라서 파드 접속을 안정적으로 유지하도록 서비스를 통해 내/외부로 연결됩니다. 새로운 파드가 생성될 때 부여되는 새로운 IP를 기존에 제공하던 기능과 연결해 줍니다.  
<br/>
<br/>


기본 오브젝트 말고도 [여러가지 오브젝트](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/){:target="_blank"}들이 존재합니다. 

## 디플로이먼트
기본 오브젝트만으로도 쿠버네티스를 사용할 수 있지만 이를 좀 더 효율적으로 작동하도록 기능들을 조합하고 추가해 구현한 것이 디플로이먼트 입니다. 디플로이먼트 오브젝트는 파드에 기본을 두고 있으며, 레플리카셋 오브젝트를 합쳐 놓은 형태 입니다.  
![디플로이먼트](/assets/images/posts/kubernetes/20230306/701F7E06-6E1B-4DEC-8522-53ED577F2AAE.png)
<br/>
<br/>
<br/>



## 레플리카셋 
다수의 파드가 필요한데 이를 하나씩 생성한다면 매우 비효율적입니다. 그래서 쿠버네티스에서는 다수의 파드를 만드는 레플리카셋 오브젝트를 제공합니다.

예를 들어 파드를 3개 만들겠다고 레플리카셋에 선언하면 컨트롤러 매니저와 스케줄러가 워커 노드에 파드 3개를 만들도록 선언합니다. 그러나 레플리카셋은 파드 수를 보장하는 기능만 제공하기 때문에 롤링 업데이트 기능 등이 추가된 디플로이먼트를 사용해 파드 수를 관리하기를 권장합니다.
![레플리카셋](/assets/images/posts/kubernetes/20230306/19156B09-0770-4580-A1E8-47EE207F990E.png)
<br/>
<br/>
<br/>



## 오브젝트 스펙
여러가지 설정을 커맨드 명령으로만으로 실행할 수 없습니다. 이런 설정은 파일로 작성해야 합니다. 이때 작성하는 파일을 오브젝트 스펙이라고 합니다. 오브젝트 스펙은 일반적으로 야믈(YAML) 문법으로 작성합니다. 

다음은 [오브젝트 스펙의 예시](https://kubernetes.io/ko/docs/concepts/workloads/controllers/){:target="_blank"}입니다.
```yaml
apiVersion: apps/v1
kind: Deployment   # 종류
metadata:
  name: nginx-deployment     # 디플로이먼트의 이름
  labels:                    # 디플로이먼트의 레이블
    app: nginx
spec:
  replicas: 3       # 레플리카 셋을 몇 개 생성할지 결정
  selector:         # 셀렉터의 레이블 지정
    matchLabels:
      app: nginx
  template:
    metadata:       # 템플릿의 메타데이터 지정
      labels:
        app: nginx
    spec:           # 템플릿에서 사용할 컨테이너 이미지 지정
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>


# 🙇🏻‍♂️ 참고사이트
- [컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커](https://product.kyobobook.co.kr/detail/S000001834629){:target="_blank"}
- [쿠버네티스 레퍼런스](https://kubernetes.io/ko/docs/home/){:target="_blank"}
- [쿠버네티스 가이드](https://subicura.com/k8s/guide/#%E1%84%80%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3){:target="_blank"}
- [김징어의 Devlog](https://kimjingo.tistory.com/category/About/Kubernetes){:target="_blank"}